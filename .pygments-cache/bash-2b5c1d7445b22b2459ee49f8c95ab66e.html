<div class="highlight"><pre>Consider two programs attempting a socket connection <span class="o">(</span>call them a and b<span class="o">)</span>. Both <span class="nb">set </span>up sockets and transition to the LISTEN state. Then one program <span class="o">(</span>say a<span class="o">)</span> tries to connect to the other <span class="o">(</span>b<span class="o">)</span>. a sends a request and enters the SYN_SENT state, and b receives the request and enters the SYN_RECV state. When b acknowledges the request, they enter the ESTABLISHED state, and <span class="k">do</span> their business. Now a couple of things can happen:

    a wishes to close the connection, and enters FIN_WAIT1. b receives the FIN request, sends an ACK <span class="o">(</span><span class="k">then</span> a enters FIN_WAIT2<span class="o">)</span>, enters CLOSE_WAIT, tells a it is closing down and the enters LAST_ACK. Once a acknowledges this <span class="o">(</span>and enters TIME_WAIT<span class="o">)</span>, b enters CLOSE. a waits a bit to see <span class="k">if</span> anythings is left, <span class="k">then</span> enters CLOSE.
    a and b have finished their business and decide to close the connection <span class="o">(</span>simultaneous closing<span class="o">)</span>. When a is in FIN_WAIT, and instead of receiving an ACK from b, it receives a FIN <span class="o">(</span>as b wishes to close it as well<span class="o">)</span>, a enters CLOSING. But there are still some messages to send <span class="o">(</span>the ACK that a is supposed to get <span class="k">for</span> its original FIN<span class="o">)</span>, and once this ACK arrives, a enters TIME_WAIT as usual.
</pre></div>