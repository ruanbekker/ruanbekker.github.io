<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Aws | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/aws/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2020-02-04T22:50:14+02:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Setup AWS S3 Cross Account Access]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/11/26/setup-aws-s3-cross-account-access/"/>
    <updated>2019-11-26T22:40:12+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/11/26/setup-aws-s3-cross-account-access</id>
    <content type="html"><![CDATA[<p><a href="https://saythanks.io/to/ruanbekker"><img src="https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg" alt="Say Thanks!" /></a> <a href="https://linux-hackers-slack.herokuapp.com/"><img src="https://linux-hackers-slack.herokuapp.com/badge.svg" alt="Slack Status" /></a> <a href="https://linux-hackers.slack.com/"><img src="https://img.shields.io/badge/chat-on_slack-orange.svg" alt="Chat on Slack" /></a> <a href="https://github.com/ruanbekker"><img src="https://img.shields.io/github/followers/ruanbekker.svg?label=Follow&amp;style=social" alt="GitHub followers" /></a></p>

<p><a href="https://twitter.com/ruanbekker?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @ruanbekker</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>In this tutorial I will demonstrate how to setup cross account access from S3.</p>

<h2>Scenario</h2>

<p>We will have 2 AWS Accounts:</p>

<ol>
<li><p>a Green AWS Account which will host the IAM Users, this account will only be used for our IAM Accounts.</p></li>
<li><p>a Blue AWS Account which will be the account that hosts our AWS Resources, S3 in this scenario.</p></li>
</ol>


<p>We will the allow the Green Account to access the Blue Account&rsquo;s S3 Bucket.</p>

<h2>Setup the Blue Account</h2>

<p>In the Blue Account, we will setup the S3 Bucket, as well as the Trust Relationship with the Policy, which is where we will define what we want to allow for the Green Account.</p>

<p><img width="1280" alt="9488F107-A5B0-4A9E-A7A4-5A91B9805DE3" src="https://user-images.githubusercontent.com/567298/69668149-fe40ff00-1097-11ea-896a-5f3106fe5dfa.png"></p>

<p>Now we need to setup the IAM Role which will allow the Green Account and also define what needs to be allowed.</p>

<p>Go ahead to your IAM Console and create a IAM Policy (just remember to replace the bucket name if you are following along)</p>

<pre><code>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "PutGetListAccessOnS3",
            "Effect": "Allow",
            "Action": [
                "s3:PutObject",
                "s3:GetObject",
                "s3:ListBucket"
            ],
            "Resource": [
                "arn:aws:s3:::ruanbekker-prod-s3-bucket",
                "arn:aws:s3:::ruanbekker-prod-s3-bucket/*"
            ]
        }
    ]
}
</code></pre>

<p>In my case I have named my IAM Policy <code>CrossAccountS3Access</code>. After you have created your IAM Policy, go ahead and create a IAM Role. Here we need the source account that we want to allow as a trusted entity, which will be the AWS AccountId of the Green Account:</p>

<p><img width="1277" alt="E73FC957-EBFA-4E41-AFDB-D994D6D3110E" src="https://user-images.githubusercontent.com/567298/69668615-ee75ea80-1098-11ea-8536-b32c6c034f7a.png"></p>

<p>Associate the IAM Policy that you created earlier:</p>

<p><img width="1280" alt="610814A8-E8CB-45F7-A038-FE4274FD425C" src="https://user-images.githubusercontent.com/567298/69668712-19603e80-1099-11ea-8ba0-2d0bc84e21cf.png"></p>

<p>After you have done that, you should see a summary screen:</p>

<p><img width="1278" alt="ABAADD0E-9140-4EB1-855A-0B0E46F429FF" src="https://user-images.githubusercontent.com/567298/69668817-50ceeb00-1099-11ea-8bb2-98537a742857.png"></p>

<p>Make note of your IAM Role ARN, it will look something like this: <code>arn:aws:iam::xxxxxxxxxxxx:role/CrossAccountS3Access-Role</code></p>

<h2>Setup the Green Account</h2>

<p>In the Green Account is where we will create the IAM User and the credentials will be provided to the user which requires to access the S3 Bucket.</p>

<p>Let&rsquo;s create a IAM Group, I will name mine <code>prod-s3-users</code>. I will just create the group, as I will attach the policy later:</p>

<p><img width="1280" alt="459D98BF-7A5D-49B4-BBD9-11717655188D" src="https://user-images.githubusercontent.com/567298/69669190-07cb6680-109a-11ea-8193-db476f5fa1db.png"></p>

<p>From the IAM Group, select the Permissions tab and create a New Inline Policy:</p>

<p><img width="1280" alt="E55E521D-A3C1-4669-B0AB-C23A5BA51E21" src="https://user-images.githubusercontent.com/567298/69669427-81635480-109a-11ea-8b4b-7bd79f2a12cd.png"></p>

<p>Select the &ldquo;STS&rdquo; service, select the &ldquo;AssumeRole&rdquo; action, and provide the Role ARN of the Blue Account that we created earlier:</p>

<p><img width="1280" alt="FDECEF7C-14F1-41DC-94F5-B6E63FE46A7D" src="https://user-images.githubusercontent.com/567298/69669597-d8692980-109a-11ea-804c-914c9a8cb608.png"></p>

<p>This will allow the Blue account to assume the credentials from the Green account. And the Blue account will only obtain permissions to access the resources that we have defined in the policy document of the Blue Account. In summary, it should look like this:</p>

<p><img width="1280" alt="0133A1AF-D2B0-4A61-B179-B4B40B81953C" src="https://user-images.githubusercontent.com/567298/69669773-30079500-109b-11ea-83bd-69c8301c4f21.png"></p>

<p>Select the Users tab on the left hand side, create a New IAM User (I will name mine s3-prod-user) and select the &ldquo;Programmatic Access&rdquo; check box as we need API keys as we will be using the CLI to access S3:</p>

<p><img width="1278" alt="ACE1F066-4400-4000-A9D8-0FD438DB7028" src="https://user-images.githubusercontent.com/567298/69669927-82e14c80-109b-11ea-9adf-de5c01cec41c.png"></p>

<p>Then from the next window, add the user to the group that we have created earlier:</p>

<p><img width="1279" alt="0AEC8E84-091F-44CB-966D-BDA93970C881" src="https://user-images.githubusercontent.com/567298/69669976-9987a380-109b-11ea-9c16-ea63cebe2e82.png"></p>

<h2>Test Cross Account Access</h2>

<p>Let&rsquo;s configure our AWS CLI with the API Keys that we received. Our credential provider will consist with 2 profiles, the Green Profile which holds the API Keys of the Green Account:</p>

<pre><code>$ aws configure --profile green
AWS Access Key ID [None]: AKIATPRT2G4SAHA7ZQU2
AWS Secret Access Key [None]: x
Default region name [None]: eu-west-1
Default output format [None]: json
</code></pre>

<p>And configure the Blue profile that will reference the Green account as a source profile and also specify the IAM Role ARN of the Blue Account:</p>

<pre><code>$ vim ~/.aws/credentials
</code></pre>

<pre><code>[blue]
role_arn=arn:aws:iam::xxxxxxxxxxxx:role/CrossAccountS3Access-Role
source_profile=green
region=eu-west-1
</code></pre>

<p>Now we can test if we can authenticate with our Green AWS Account:</p>

<pre><code>$ aws --profile green sts get-caller-identity
{
    "UserId": "AKIATPRT2G4SAHA7ZQU2",
    "Account": "xxxxxxxxxxxx",
    "Arn": "arn:aws:iam:: xxxxxxxxxxxx:user/s3-prod-user"
}
</code></pre>

<p>Now let&rsquo;s upload an object to S3 using our blue profile:</p>

<pre><code>$ aws --profile blue s3 cp foo s3://ruanbekker-prod-s3-bucket/
upload: ./foo to s3://ruanbekker-prod-s3-bucket/foo
</code></pre>

<p>Let&rsquo;s verify if we can see the object:</p>

<pre><code>$ aws --profile blue s3 ls s3://ruanbekker-prod-s3-bucket/
2019-10-03 22:13:30      14582 foo
</code></pre>

<h2>Thank You</h2>

<p>Let me know what you think. If you liked my content, feel free to checkout my content on <strong><a href="https://ruan.dev/">ruan.dev</a></strong> or follow me on twitter at <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong></p>

<center><script type='text/javascript' src='https://ko-fi.com/widgets/widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Buy Me a Coffee', '#46b798', 'A6423ZIQ');kofiwidget2.draw();</script></center>


<p><br></p>

<p>I&rsquo;ve recently started a <a href="https://bekkerclothing.com/collections/developer">Developer Range</a> t-shirts, let me know what you think:</p>

<div id='product-component-1574800622582'></div>


<script type="text/javascript">
/*&lt;![CDATA[*/
(function () {
  var scriptURL = 'https://sdks.shopifycdn.com/buy-button/latest/buy-button-storefront.min.js';
  if (window.ShopifyBuy) {
    if (window.ShopifyBuy.UI) {
      ShopifyBuyInit();
    } else {
      loadScript();
    }
  } else {
    loadScript();
  }
  function loadScript() {
    var script = document.createElement('script');
    script.async = true;
    script.src = scriptURL;
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(script);
    script.onload = ShopifyBuyInit;
  }
  function ShopifyBuyInit() {
    var client = ShopifyBuy.buildClient({
      domain: 'bekkerclothing.myshopify.com',
      storefrontAccessToken: '68eb29a6d90539cb0321ea90bb043fae',
    });
    ShopifyBuy.UI.onReady(client).then(function (ui) {
      ui.createComponent('product', {
        id: '4392613544020',
        node: document.getElementById('product-component-1574800622582'),
        moneyFormat: '%24%7B%7Bamount%7D%7D',
        options: {
  "product": {
    "styles": {
      "product": {
        "@media (min-width: 601px)": {
          "max-width": "calc(25% - 20px)",
          "margin-left": "20px",
          "margin-bottom": "50px"
        }
      }
    },
    "text": {
      "button": "Add to cart"
    }
  },
  "productSet": {
    "styles": {
      "products": {
        "@media (min-width: 601px)": {
          "margin-left": "-20px"
        }
      }
    }
  },
  "modalProduct": {
    "contents": {
      "img": false,
      "imgWithCarousel": true,
      "button": false,
      "buttonWithQuantity": true
    },
    "styles": {
      "product": {
        "@media (min-width: 601px)": {
          "max-width": "100%",
          "margin-left": "0px",
          "margin-bottom": "0px"
        }
      }
    },
    "text": {
      "button": "Add to cart"
    }
  },
  "cart": {
    "text": {
      "total": "Subtotal",
      "button": "Checkout"
    }
  }
},
      });
    });
  }
})();
/*]]&gt;*/
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Setup VPC Peering on AWS]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/11/23/how-to-setup-vpc-peering-on-aws/"/>
    <updated>2019-11-23T09:09:40+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/11/23/how-to-setup-vpc-peering-on-aws</id>
    <content type="html"><![CDATA[<p><a href="https://saythanks.io/to/ruanbekker"><img src="https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg" alt="Say Thanks!" /></a> <a href="https://linux-hackers-slack.herokuapp.com/"><img src="https://linux-hackers-slack.herokuapp.com/badge.svg" alt="Slack Status" /></a> <a href="https://linux-hackers.slack.com/"><img src="https://img.shields.io/badge/chat-on_slack-orange.svg" alt="Chat on Slack" /></a> <a href="https://github.com/ruanbekker"><img src="https://img.shields.io/github/followers/ruanbekker.svg?label=Follow&amp;style=social" alt="GitHub followers" /></a></p>

<p><a href="https://twitter.com/ruanbekker?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @ruanbekker</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>In this tutorial I will demonstrate how to create a VPC Peering Connection between Two AWS Accounts and how to route traffic between them and then show you how we create Two EC2 Instances and demonstrate how to SSH to each other via it&rsquo;s Private IP Address.</p>

<h2>Scenario Information</h2>

<p>We will have Two AWS Accounts in this demonstration, a &ldquo;Green AWS Account&rdquo; and a &ldquo;Blue AWS Account&rdquo;.</p>

<p>In this scenario, we will have two teams, both teams manage their own account and in this scenario the two teams need to be able to communicate to each other. To keep it simple, each team has a EC2 instance and the two EC2 instances need to be able to communicate with each other.</p>

<p>Therefore we will setup a VPC Peering Connection between the two accounts. Both accounts will be operating in the eu-west-2 (London) region.</p>

<pre><code>Account, CIDR
green: 10.1.0.0/16
blue:  10.2.0.0/16
</code></pre>

<h2>Getting Started</h2>

<p>This will be our <strong>Green</strong> AWS Account:</p>

<p><img width="1291" alt="140424C7-6FD5-4D74-AD26-AA1077D3DA92" src="https://user-images.githubusercontent.com/567298/69486624-55579180-0e56-11ea-897c-55607680fb58.png"></p>

<p>This will be our <strong>Blue</strong> AWS Account:</p>

<p><img src="https://user-images.githubusercontent.com/567298/69486632-61435380-0e56-11ea-86d1-3af018fe5fe3.png" alt="AAFBF715-897D-4D54-BDF2-9A5282A60165" /></p>

<h2>Creating the VPCs</h2>

<p>From our <strong>green</strong> account, head over to VPC and create a new VPC with a CIDR of <code>10.1.0.0/16</code>:</p>

<p><img width="1291" alt="55FB3F87-9F73-4CDD-845B-8748700B0981" src="https://user-images.githubusercontent.com/567298/69486652-d6af2400-0e56-11ea-9f4d-9331001625f4.png"></p>

<p>Then head over to the <strong>blue</strong> account, head over to VPC and create a new VPC with CIDR of <code>10.2.0.0/16</code>:</p>

<p><img src="https://user-images.githubusercontent.com/567298/69486659-f1819880-0e56-11ea-8c3c-5aff2f84e2aa.png" alt="854DC039-7F83-4E6F-BD28-6843BE417EEB" /></p>

<p>So in summary we have the following resources:</p>

<pre><code>Green: vpc-0af4b247a1353b78b | 10.1.0.0/16
Blue: vpc-031c4ce3f56660c30 | 10.2.0.0/16
</code></pre>

<h2>Creating the Subnets</h2>

<p>Now we need to create subnets for the VPC&rsquo;s that we created. We will create the following subnets in our VPC, each subnet in its own availability zone:</p>

<pre><code>10.1.0.0/20 (az-2a)
10.1.16.0/20 (az-2b)
10.1.32.0/20 (az-2c)
</code></pre>

<p>Let&rsquo;s go ahead and do this, head over to your <strong>green</strong> account, from the VPC section select &ldquo;Subnets&rdquo;:</p>

<p><img width="1292" alt="BBB38DDB-D9CF-4BD4-AEA0-C30B6998F016" src="https://user-images.githubusercontent.com/567298/69486747-92705380-0e57-11ea-86da-5cafd9c22701.png"></p>

<p>Go ahead and create a subnet where you will need to specify the VPC that you created, slect the first CIDR block, in my case 10.1.0.0/20 and select the first AZ:</p>

<p><img width="1292" alt="BB1627EE-A92D-4274-BF97-40AE4E01A9A4" src="https://user-images.githubusercontent.com/567298/69486786-0d396e80-0e58-11ea-9860-7febe6e65f7d.png"></p>

<p>Do this for the other two subnets as well and then when you are done, it may look more or less like this:</p>

<p><img width="1290" alt="051767FD-2D52-48BD-B495-01ACB431B358" src="https://user-images.githubusercontent.com/567298/69487635-3660fb80-0e66-11ea-8b59-71364414d3ae.png"></p>

<p>Repeat this process that you have three subnets for your <strong>blue</strong> account as well:</p>

<p><img src="https://user-images.githubusercontent.com/567298/69486798-3823c280-0e58-11ea-8991-6518d986de31.png" alt="881A973C-7C9A-423C-B6F4-555CE78E0A16" /></p>

<h2>Setup VPC Peering Connection</h2>

<p>Now that we&rsquo;ve created our VPC&rsquo;s and subnets for each VPC we want to peer our two VPC&rsquo;s with each other so that we have a direct connection between our VPC&rsquo;s so that our EC2 instances from our <strong>green</strong> account is able to connect with our EC2 instances in our <strong>blue</strong> account.</p>

<p>Head over to your <strong>green</strong> account&rsquo;s VPC section and select &ldquo;Peering Connections&rdquo;:</p>

<p><img width="1292" alt="21972956-D24A-4C45-94C5-10A6FC742D98" src="https://user-images.githubusercontent.com/567298/69486833-c8620780-0e58-11ea-8638-de60804bdb65.png"></p>

<p>Create a new peering connection, we will first need to name our peering connection, select the source VPC which will be our green account&rsquo;s VPC, since the VPC that we want to peer with is in another account, get the AWS Account ID from the <strong>blue</strong> account, and select &ldquo;Another account&rdquo; and provide the account id that we want to peer with, select the AWS Region and provide the VPC ID of the <strong>blue</strong> account:</p>

<p><img width="1291" alt="1BDCB500-7BF0-4C5F-B171-9E09463A956A" src="https://user-images.githubusercontent.com/567298/69487659-817b0e80-0e66-11ea-83b6-4ec7c941804f.png"></p>

<p>Once you create the peering connection, you will find the peering request details:</p>

<p><img width="1291" alt="C74BAE40-9C78-45FE-BE7F-3AC495E93A41" src="https://user-images.githubusercontent.com/567298/69486874-9c935180-0e59-11ea-99a2-a54bd5982ab1.png"></p>

<p>Now let&rsquo;s head over to our <strong>blue</strong> Account, head over to VPC, select Peering connections and you will find the peering request from our <strong>green</strong> account:</p>

<p><img src="https://user-images.githubusercontent.com/567298/69486892-dbc1a280-0e59-11ea-983d-b7814257c323.png" alt="05DB8A16-6CF4-48F1-920C-20AE7492E381" /></p>

<p>From the top, hit &ldquo;Actions&rdquo; and accept the request:</p>

<p><img src="https://user-images.githubusercontent.com/567298/69486900-014eac00-0e5a-11ea-9cc2-025ef35ad921.png" alt="0FF04F44-F5B7-4AAF-9D66-89396EC2AA06" /></p>

<p>You should see that the VPC Peering connection has been established:</p>

<p><img src="https://user-images.githubusercontent.com/567298/69486904-14617c00-0e5a-11ea-8459-ab1bdf6141b0.png" alt="2D1D101F-3574-4A40-A1A6-F2F875B29158" /></p>

<p>From the <strong>blue</strong> account you should see that the VPC Peering Connection is active:</p>

<p><img src="https://user-images.githubusercontent.com/567298/69486911-2a6f3c80-0e5a-11ea-833c-bea298c55326.png" alt="A2070A8B-6247-4D75-BFF8-D5AE152EFA42" /></p>

<p>If you head back to the <strong>green</strong> account, you will see under Peering Connections that the connection has been established:</p>

<p><img width="1290" alt="1A50F913-9C6E-4F6D-A61C-5954617EBE5B" src="https://user-images.githubusercontent.com/567298/69486921-64d8d980-0e5a-11ea-86fa-cd37b44cbfdb.png"></p>

<p>We have now successfully created our VPC peering connection and the two VPC&rsquo;s from different accounts has been peered. Now we would like to launch our EC2 instances in our VPC, we will connect to our EC2 instance in our <strong>green</strong> account via the internet and then SSH to our EC2 instance in our <strong>blue</strong> account via the VPC peering connection via the Private IP Address.</p>

<h2>Setup Internet Gateway</h2>

<p>In order to connect to a Public Elastic IP, we first need to create a Internet Gateway on our VPC and add a route to route all public traffic via our Internet Gateway. This allows our resources in that VPC to be able to connect to the Internet.</p>

<p>Head over to &ldquo;Internet Gateways&rdquo;, and create a new Internet Gateway:</p>

<p><img width="1283" alt="9750329C-E89E-425E-9DCC-D420D092C5E6" src="https://user-images.githubusercontent.com/567298/69486997-5212d480-0e5b-11ea-9455-0c3d94f4d6e9.png"></p>

<p>Our IGW (Internet Gateway) will now be in a detached state, we now need to attach our IGW to our VPC. Hit &ldquo;Actions&rdquo;, then select &ldquo;Attach to VPC&rdquo;, and select your VPC:</p>

<p><img width="1281" alt="0BF7CB7A-C40A-483C-8083-410DBFFBA171" src="https://user-images.githubusercontent.com/567298/69487007-91412580-0e5b-11ea-8d3f-4ca7dff0976d.png"></p>

<p>You should now see that your IGW has been attached to your VPC:</p>

<p><img width="1073" alt="B6C3094F-233C-4A6C-A6FC-C5FD7727FBBD" src="https://user-images.githubusercontent.com/567298/69487019-b6ce2f00-0e5b-11ea-903a-cb576ab29f11.png"></p>

<p>Now that we have created an IGW and associated it to our VPC, we now need to configure our routing table so that it knows how to route non-local traffic via the IGW.</p>

<h2>Configure Routing Table</h2>

<p>Head over to VPC, select your VPC, select the &ldquo;Route Tables&rdquo; section from the left and you should see the following when you select the &ldquo;Routes&rdquo; section:</p>

<p><img width="1286" alt="FF7E141E-2C8D-4D87-BE67-513AB44784F2" src="https://user-images.githubusercontent.com/567298/69487055-55f32680-0e5c-11ea-8ce9-81de2bf5eab5.png"></p>

<p>Select &ldquo;Edit Routes&rdquo; and add a route with the destination <code>0.0.0.0/0</code> select the Internet Gateway as a target and it will filter through your available IGW&rsquo;s and select the IGW that you created earlier, then select save. (If your blue account needs internet access, repeat these steps on the blue account as well.)</p>

<p><img width="1274" alt="E223A267-1A4F-4DA4-B23A-37CE6EDAFEF5" src="https://user-images.githubusercontent.com/567298/69487097-ea5d8900-0e5c-11ea-97f6-66cd6604035f.png"></p>

<p>While we are at our routing tables configuration, we should also inform our VPC how to reach the subnet from the VPC from the other account. So that our <strong>Green</strong> App (10.1.0.0/16) can reach our <strong>blue</strong> app (10.2.0.0/16) via the Peering Connection.</p>

<p>We do this by adding a route to our routing table. From the <strong>green</strong> account&rsquo;s VPC&rsquo;s routing table add a new route with the destination of <code>10.2.0.0/16</code>, select &ldquo;Peering Connection&rdquo; as the target and it should resolve to the peering connection resource that we created, then select save:</p>

<p><img width="1271" alt="B5E8CF35-0C06-4261-9668-6C091BA19E2A" src="https://user-images.githubusercontent.com/567298/69487275-a3bd5e00-0e5f-11ea-8d4f-a2d270b3e57b.png"></p>

<p>Now our <strong>green</strong> Account knows how to route traffic to our <strong>blue</strong> account and also knows which network traffic to route. But we also need to route traffic back. Head over to your <strong>blue</strong> Account and add a route <code>10.1.0.0/16</code> to the peering connection so that we can route traffic back to our <strong>green</strong> Account:</p>

<p><img src="https://user-images.githubusercontent.com/567298/69487287-e41cdc00-0e5f-11ea-86cd-b9c9f6d77ad5.png" alt="885DCDE3-ACA5-4136-851D-3DF9D2D9D62D" /></p>

<h2>Launch EC2 Instances</h2>

<p>Now we want to launch a EC2 instance in each account and ensure to launch them into the VPC&rsquo;s that we created, I will also be creating two new SSH keys (blue-keypair + green-keypair) And I have created a Security Group that allows ICMP and SSH from anywhere, this is purely for demonstration (always review the sources that you want to allow).</p>

<p>For our <strong>green</strong> account:</p>

<p><img width="1284" alt="C60E3DAD-DD12-4670-97CD-AC524269C20E" src="https://user-images.githubusercontent.com/567298/69487311-4ece1780-0e60-11ea-9b66-b00568184790.png"></p>

<p>For our <strong>blue</strong> account:</p>

<p><img src="https://user-images.githubusercontent.com/567298/69487313-57265280-0e60-11ea-8814-fcdf4465967c.png" alt="1BFBF8B9-D090-4883-8E2B-92F29B19AEDE" /></p>

<p>Once the EC2 instances are deployed, you should see something like this. For my <strong>green</strong> account:</p>

<p><img width="1278" alt="image" src="https://user-images.githubusercontent.com/567298/69487370-2bf03300-0e61-11ea-89a5-c9fcef4ee50a.png"></p>

<p>And for my <strong>blue</strong> account:</p>

<p><img src="https://user-images.githubusercontent.com/567298/69487324-7ae99880-0e60-11ea-9d46-fb4ebcb14e07.png" alt="74F20740-17EE-46C9-9A51-D3ACAB8937B5" /></p>

<h2>Public IP Addressing</h2>

<p>Now that our EC2 instances are provisioned, we will be connecting to our <strong>green</strong> EC2 instances using a Public IP, therefore we need to create a Elastic IP. From EC2, select Elastic IPs and allocate a New Address:</p>

<p><img width="1283" alt="C4B9AC94-7AFC-465D-8D51-0497ABA475B3" src="https://user-images.githubusercontent.com/567298/69487353-d9167b80-0e60-11ea-85dd-26c94b227494.png"></p>

<p>Select the IP, hit &ldquo;Actions&rdquo; and select &ldquo;Associate Address&rdquo;, then select the EC2 instance to which you want to associate the Elastic IP to:</p>

<p><img width="771" alt="E3AA99D6-CD59-4530-B818-422E1D584932" src="https://user-images.githubusercontent.com/567298/69487364-fc412b00-0e60-11ea-88b4-f1b0b7ad83dc.png"></p>

<p>You should know see that the EC2 instance has a Public IP assigned to it:</p>

<p><img width="1048" alt="FE545350-0A45-453C-9855-4F65CC0783C6" src="https://user-images.githubusercontent.com/567298/69487694-d7e84d00-0e66-11ea-8cec-ad8142f01b9b.png"></p>

<h2>Test Network Connectivity</h2>

<p>From the downloaded SSH keypairs:</p>

<pre><code>$ ls | grep keyp
blue-keypair.pem.txt
green-keypair.pem.txt
</code></pre>

<p>Apply the correct permissions to our keypairs so that we can use them to SSH:</p>

<pre><code>$ chmod 0400 blue-keypair.pem.txt green-keypair.pem.txt
</code></pre>

<p>We will want to add both SSH keys to our agent so we can include them when we SSH:</p>

<pre><code>$ eval $(ssh-agent -t 36000)
Agent pid 6613
</code></pre>

<p>Add both keys to your ssh-agent:</p>

<pre><code>$ ssh-add blue-keypair.pem.txt
Identity added: blue-keypair.pem.txt (blue-keypair.pem.txt)

$ ssh-add green-keypair.pem.txt
Identity added: green-keypair.pem.txt (green-keypair.pem.txt)
</code></pre>

<p>SSH to our <strong>Green</strong> EC2 instance:</p>

<pre><code>$ ssh -A ec2-user@3.11.6.171

       __|  __|_  )
       _|  (     /   Amazon Linux 2 AMI
      ___|\___|___|

https://aws.amazon.com/amazon-linux-2/
[ec2-user@ip-10-1-1-190 ~]$
</code></pre>

<p>Now lets ping our <strong>Blue</strong> EC2 Instance which will be accessible via our VPC Peering Connection:</p>

<pre><code>[ec2-user@ip-10-1-1-190 ~]$ ping 10.2.1.167
PING 10.2.1.167 (10.2.1.167) 56(84) bytes of data.
64 bytes from 10.2.1.167: icmp_seq=1 ttl=255 time=0.754 ms
64 bytes from 10.2.1.167: icmp_seq=2 ttl=255 time=0.854 ms
</code></pre>

<p>And since we&rsquo;ve allowed SSH traffic, we should be able to SSH to our instance via its Private IP Address:</p>

<pre><code>[ec2-user@ip-10-1-1-190 ~]$ ssh 10.2.1.167

       __|  __|_  )
       _|  (     /   Amazon Linux 2 AMI
      ___|\___|___|

https://aws.amazon.com/amazon-linux-2/
[ec2-user@ip-10-2-1-167 ~]$
</code></pre>

<p>Now we have successfully created a VPC Peering Connection between Two AWS Accounts and demonstrated how to communicate to and from resources in those VPC&rsquo;s.</p>

<h2>Thank You</h2>

<p>Let me know what you think. If you liked my content, feel free to checkout my content on <strong><a href="https://ruan.dev/">ruan.dev</a></strong> or follow me on twitter at <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong></p>

<center><script type='text/javascript' src='https://ko-fi.com/widgets/widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Buy Me a Coffee', '#46b798', 'A6423ZIQ');kofiwidget2.draw();</script></center>


<p><br></p>

<p>Feel free to have a look at my <strong><a href="https://bekkerclothing.com/collections/developer">Developer T-Shirt Range</a>:</strong></p>

<div id='product-component-1574559271268'></div>


<script type="text/javascript">
/*&lt;![CDATA[*/
(function () {
  var scriptURL = 'https://sdks.shopifycdn.com/buy-button/latest/buy-button-storefront.min.js';
  if (window.ShopifyBuy) {
    if (window.ShopifyBuy.UI) {
      ShopifyBuyInit();
    } else {
      loadScript();
    }
  } else {
    loadScript();
  }
  function loadScript() {
    var script = document.createElement('script');
    script.async = true;
    script.src = scriptURL;
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(script);
    script.onload = ShopifyBuyInit;
  }
  function ShopifyBuyInit() {
    var client = ShopifyBuy.buildClient({
      domain: 'bekkerclothing.myshopify.com',
      storefrontAccessToken: '68eb29a6d90539cb0321ea90bb043fae',
    });
    ShopifyBuy.UI.onReady(client).then(function (ui) {
      ui.createComponent('product', {
        id: '4391499104340',
        node: document.getElementById('product-component-1574559271268'),
        moneyFormat: '%24%7B%7Bamount%7D%7D',
        options: {
  "product": {
    "styles": {
      "product": {
        "@media (min-width: 601px)": {
          "max-width": "calc(25% - 20px)",
          "margin-left": "20px",
          "margin-bottom": "50px"
        }
      }
    },
    "text": {
      "button": "Add to cart"
    }
  },
  "productSet": {
    "styles": {
      "products": {
        "@media (min-width: 601px)": {
          "margin-left": "-20px"
        }
      }
    }
  },
  "modalProduct": {
    "contents": {
      "img": false,
      "imgWithCarousel": true,
      "button": false,
      "buttonWithQuantity": true
    },
    "styles": {
      "product": {
        "@media (min-width: 601px)": {
          "max-width": "100%",
          "margin-left": "0px",
          "margin-bottom": "0px"
        }
      }
    },
    "text": {
      "button": "Add to cart"
    }
  },
  "cart": {
    "text": {
      "total": "Subtotal",
      "button": "Checkout"
    }
  }
},
      });
    });
  }
})();
/*]]&gt;*/
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Deploy a Webapp on a AWS EKS Kubernetes Cluster]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/11/17/how-to-deploy-a-webapp-on-a-aws-eks-kubernetes-cluster/"/>
    <updated>2019-11-17T00:21:19+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/11/17/how-to-deploy-a-webapp-on-a-aws-eks-kubernetes-cluster</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/68999897-f59a3d00-08cf-11ea-83c7-8624e6048106.png" alt="kubernetes-eks-deploy-webapp" /></p>

<p><a href="https://saythanks.io/to/ruanbekker"><img src="https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg" alt="Say Thanks!" /></a> <a href="https://linux-hackers-slack.herokuapp.com/"><img src="https://linux-hackers-slack.herokuapp.com/badge.svg" alt="Slack Status" /></a> <a href="https://linux-hackers.slack.com/"><img src="https://img.shields.io/badge/chat-on_slack-orange.svg" alt="Chat on Slack" /></a> <a href="https://github.com/ruanbekker"><img src="https://img.shields.io/github/followers/ruanbekker.svg?label=Follow&amp;style=social" alt="GitHub followers" /></a></p>

<p><a href="https://twitter.com/ruanbekker?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @ruanbekker</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>In our previous post, <a href="https://blog.ruanbekker.com/blog/2019/11/16/how-to-setup-a-aws-eks-kubernetes-cluster/">Part 1 - Setup a EKS Cluster</a> we went through the steps on how to Setup a EKS Cluster.</p>

<h2>What are we doing today</h2>

<p>In this post, we will deploy a sample web application to EKS and access our application using a ELB that EKS provides us.</p>

<h2>Deployment Manifests</h2>

<p>We will have two manifests that we will deploy to Kubernetes, a deployment manifest that will hold the information about our application and a service manifest that will hold the information about the service load balancer.</p>

<p>The deployment manifest, you will notice that we are specifying that we want 3 containers, we are using labels so that our service and deployment can find each other and we are using a basic http web application that will listen on port 8000 inside the container:</p>

<pre><code class="bash">$ cat deployment.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-hostname-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: my-app-container
          image: ruanbekker/hostname
          ports:
          - name: http
            containerPort: 8000
</code></pre>

<p>The service manifest, you will notice that we are specifying <code>type: LoadBalancer</code> in our service manifest, this will tell EKS to provision a ELB for your application so that we can access our application from the internet.</p>

<p>You will see that the selector is specifying <code>my-app</code> which we also provided in our deployment.yml so that our service know where to find our backend application. We are also stating that the service is listening on port 80, and will forward its traffic to our deployment on port 8000:</p>

<pre><code class="bash">$ cat service.yml
apiVersion: v1
kind: Service
metadata:
  name: my-hostname-app-service
  labels:
    app: my-app
spec:
  ports:
  - port: 80
    targetPort: 8000
  selector:
    app: my-app
  type: LoadBalancer
</code></pre>

<h2>Deployment Time</h2>

<p>Deploy our application:</p>

<pre><code class="bash">$ kubectl apply -f deployment.yml
deployment.apps/my-hostname-app created
</code></pre>

<p>Deploy our service:</p>

<pre><code class="bash">$ kubectl apply -f service.yml
service/my-hostname-app-service created
</code></pre>

<p>Now when we look at our deployment, we should see that 3 replicas of our application is running:</p>

<pre><code class="bash">$ kubectl get deployments
NAME              READY   UP-TO-DATE   AVAILABLE   AGE
my-hostname-app   3/3     3            3           4m38s
</code></pre>

<p>To see the pods of that deployment, look at the pods:</p>

<pre><code class="bash">$ kubectl get pods
NAME                               READY   STATUS    RESTARTS   AGE
my-hostname-app-5dcd48dfc5-2j8zm   1/1     Running   0          24s
my-hostname-app-5dcd48dfc5-58vkc   1/1     Running   0          24s
my-hostname-app-5dcd48dfc5-cmjwj   1/1     Running   0          24s
</code></pre>

<p>As we have more than one service in our EKS cluster, we can specify the labels that we have applied on our manifests to filter what we want to see (<code>app: my-app</code>):</p>

<pre><code class="bash">$ kubectl get service --selector app=my-app
NAME                      TYPE           CLUSTER-IP       EXTERNAL-IP                                                              PORT(S)        AGE
my-hostname-app-service   LoadBalancer   10.100.114.166   a460661ce089b11ea97cd06dd7513db6-669054126.eu-west-1.elb.amazonaws.com   80:30648/TCP   2m29s
</code></pre>

<p>As we can see EKS provisioned a ELB for us, and we can access the application by making a HTTP request:</p>

<pre><code class="bash">$ curl -i http://a460661ce089b11ea97cd06dd7513db6-669054126.eu-west-1.elb.amazonaws.com
HTTP/1.1 200 OK
Date: Sat, 16 Nov 2019 18:05:27 GMT
Content-Length: 43
Content-Type: text/plain; charset=utf-8

Hostname: my-hostname-app-5dcd48dfc5-2j8zm
</code></pre>

<h2>Scaling our Deployment</h2>

<p>Let&rsquo;s scale our deployment to 5 replicas:</p>

<pre><code class="bash">$ kubectl scale deployment/my-hostname-app --replicas 5
deployment.extensions/my-hostname-app scaled
</code></pre>

<p>After all the pods has been deployed, you should be able to see the 5 out of 5 pods that we provisioned, should be running:</p>

<pre><code class="bash">$ kubectl get deployments
NAME              READY   UP-TO-DATE   AVAILABLE   AGE
my-hostname-app   5/5     5            5           5m7s
</code></pre>

<p>We can then also see the pods that our deployment is referencing:</p>

<pre><code class="bash">$ kubectl get pods
NAME                               READY   STATUS    RESTARTS   AGE
my-hostname-app-5dcd48dfc5-2j8zm   1/1     Running   0          6m8s
my-hostname-app-5dcd48dfc5-58vkc   1/1     Running   0          6m8s
my-hostname-app-5dcd48dfc5-cmjwj   1/1     Running   0          6m8s
my-hostname-app-5dcd48dfc5-m4xcq   1/1     Running   0          67s
my-hostname-app-5dcd48dfc5-zf6xl   1/1     Running   0          68s
</code></pre>

<h2>Further Reading on Kubernetes</h2>

<p>This is one amazing resource that covers a lot of kubernetes topics and will help you throughout your EKS journey:</p>

<ul>
<li><a href="https://eksworkshop.com/introduction/">EKSWorkshop</a></li>
<li><a href="https://docs.aws.amazon.com/eks/latest/userguide/worker.html">Worker Nodes Documentation</a></li>
<li><a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-guestbook.html">Guestbook Kubernetes Sample Application</a></li>
</ul>


<h2>Thank You</h2>

<p>Let me know what you think. If you liked my content, feel free to checkout my content on <strong><a href="https://ruan.dev/">ruan.dev</a></strong> or follow me on twitter at <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong></p>

<center><script type='text/javascript' src='https://ko-fi.com/widgets/widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Buy Me a Coffee', '#46b798', 'A6423ZIQ');kofiwidget2.draw();</script></center>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Setup a AWS EKS Kubernetes Cluster]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/11/16/how-to-setup-a-aws-eks-kubernetes-cluster/"/>
    <updated>2019-11-16T22:31:36+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/11/16/how-to-setup-a-aws-eks-kubernetes-cluster</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/68999066-b8c84900-08c3-11ea-9669-5c859590296c.png" alt="kubernetes-eks-aws-cluster" /></p>

<p><a href="https://saythanks.io/to/ruanbekker"><img src="https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg" alt="Say Thanks!" /></a> <a href="https://linux-hackers-slack.herokuapp.com/"><img src="https://linux-hackers-slack.herokuapp.com/badge.svg" alt="Slack Status" /></a> <a href="https://linux-hackers.slack.com/"><img src="https://img.shields.io/badge/chat-on_slack-orange.svg" alt="Chat on Slack" /></a> <a href="https://github.com/ruanbekker"><img src="https://img.shields.io/github/followers/ruanbekker.svg?label=Follow&amp;style=social" alt="GitHub followers" /></a></p>

<p><a href="https://twitter.com/ruanbekker?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @ruanbekker</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>This will be a tutorial split up in two posts, where I will show you how to provision a EKS Cluster (Elastic Kubernetes Service) on AWS and in the <a href="https://blog.ruanbekker.com/blog/2019/11/17/how-to-deploy-a-webapp-on-a-aws-eks-kubernetes-cluster/">next post</a>, how to deploy a web application to your cluster (<a href="https://blog.ruanbekker.com/blog/2019/11/17/how-to-deploy-a-webapp-on-a-aws-eks-kubernetes-cluster/">Part2 - Deploy a Web App to EKS</a>.)</p>

<h2>And then came EKS</h2>

<p>As some of you may know, I&rsquo;m a massive AWS fan boy, and since AWS released their managed Kubernetes service, I was quite excited to test it out. A couple of months passed and I got the opportunity to test out on-the-job as we moved to Kubernetes.</p>

<p>A couple of moths has passed, and serving multiple production workloads on EKS, and I am really impressed with the service.</p>

<p>Amazon provides a vanilla Kubernetes version, they manage the master nodes and they have a extra component called the cloud controller that runs on the master nodes, which is the aws native component that talks to other aws services (as far as I can recall)</p>

<h2>What are we doing today</h2>

<p>We will cover this in this post:</p>

<table>
<thead>
<tr>
<th> <strong>Topic</strong>                                                    </th>
</tr>
</thead>
<tbody>
<tr>
<td> Deploy a EKS Cluster                                         </td>
</tr>
<tr>
<td> View the resources to see what was provisioned on AWS        </td>
</tr>
<tr>
<td> Interact with Kubernetes using kubectl                       </td>
</tr>
<tr>
<td> Terminate a Node and verify that the ASG replaces the node   </td>
</tr>
<tr>
<td> Scale down your worker nodes                                 </td>
</tr>
<tr>
<td> Run a pod on your cluster                                    </td>
</tr>
</tbody>
</table>


<p>In the <a href="https://blog.ruanbekker.com/blog/2019/11/17/how-to-deploy-a-webapp-on-a-aws-eks-kubernetes-cluster/">next post</a> we will deploy a web service to our EKS cluster.</p>

<h2>Install Pre-Requirements</h2>

<p>We require <code>awscli</code>, <code>eksctl</code> and <code>kubectl</code> before we continue. I will be installing this on MacOS, but you can have a look at the following links if you are using a different operating system:</p>

<ul>
<li><a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html">Install awscli</a></li>
<li><a href="https://docs.aws.amazon.com/eks/latest/userguide/getting-started-eksctl.html">Install eksctl</a></li>
<li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">Install kubectl</a></li>
</ul>


<p>Install awscli:</p>

<pre><code class="bash">$ pip install awscli
</code></pre>

<p>Install kubectl:</p>

<pre><code>$ brew update
$ brew install kubernetes-cli
</code></pre>

<p>Install eksctl:</p>

<pre><code>$ brew tap weaveworks/tap
$ brew install weaveworks/tap/eksctl
</code></pre>

<h2>Deploy EKS</h2>

<p>Create a SSH key if you would like to SSH to your worker nodes:</p>

<pre><code>$ ssh-keygen -b 2048 -f ~/.ssh/eks -t rsa -q -N ""
</code></pre>

<p>Import your public key to EC2:</p>

<pre><code>$ aws --profile dev --region eu-west-1 ec2 import-key-pair --key-name "eks" --public-key-material file://~/.ssh/eks.pub
</code></pre>

<p>Provision your cluster using eksctl. This will deploy two cloudformation stacks, one for the kubernetes cluster, and one for the node group.</p>

<p>I am creating a kubernetes cluster with 3 nodes of instance type (t2.small) and using version 1.14:</p>

<pre><code class="bash">$ eksctl --profile dev --region eu-west-1 create cluster --name my-eks-cluster --version 1.14 --nodes 3 --node-type t2.small --ssh-public-key eks

[ℹ]  eksctl version 0.9.0
[ℹ]  using region eu-west-1
[ℹ]  setting availability zones to [eu-west-1a eu-west-1b eu-west-1c]
[ℹ]  subnets for eu-west-1a - public:192.168.0.0/19 private:192.168.96.0/19
[ℹ]  subnets for eu-west-1b - public:192.168.32.0/19 private:192.168.128.0/19
[ℹ]  subnets for eu-west-1c - public:192.168.64.0/19 private:192.168.160.0/19
[ℹ]  nodegroup "ng-f27f560e" will use "ami-059c6874350e63ca9" [AmazonLinux2/1.14]
[ℹ]  using Kubernetes version 1.14
[ℹ]  creating EKS cluster "my-eks-cluster" in "eu-west-1" region
[ℹ]  will create 2 separate CloudFormation stacks for cluster itself and the initial nodegroup
[ℹ]  if you encounter any issues, check CloudFormation console or try 'eksctl utils describe-stacks --region=eu-west-1 --cluster=my-eks-cluster'
[ℹ]  CloudWatch logging will not be enabled for cluster "my-eks-cluster" in "eu-west-1"
[ℹ]  you can enable it with 'eksctl utils update-cluster-logging --region=eu-west-1 --cluster=my-eks-cluster'
[ℹ]  Kubernetes API endpoint access will use default of {publicAccess=true, privateAccess=false} for cluster "my-eks-cluster" in "eu-west-1"
[ℹ]  2 sequential tasks: { create cluster control plane "my-eks-cluster", create nodegroup "ng-f27f560e" }
[ℹ]  building cluster stack "eksctl-my-eks-cluster-cluster"
[ℹ]  deploying stack "eksctl-my-eks-cluster-cluster"
[ℹ]  building nodegroup stack "eksctl-my-eks-cluster-nodegroup-ng-f27f560e"
[ℹ]  --nodes-min=3 was set automatically for nodegroup ng-f27f560e
[ℹ]  --nodes-max=3 was set automatically for nodegroup ng-f27f560e
[ℹ]  deploying stack "eksctl-my-eks-cluster-nodegroup-ng-f27f560e"
[+]  all EKS cluster resources for "my-eks-cluster" have been created
[+]  saved kubeconfig as "/Users/ruan/.kube/config"
[ℹ]  adding identity "arn:aws:iam::000000000000:role/eksctl-my-eks-cluster-nodegroup-n-NodeInstanceRole-SNVIW5C3J3SM" to auth ConfigMap
[ℹ]  nodegroup "ng-f27f560e" has 0 node(s)
[ℹ]  waiting for at least 3 node(s) to become ready in "ng-f27f560e"
[ℹ]  nodegroup "ng-f27f560e" has 3 node(s)
[ℹ]  node "ip-192-168-42-186.eu-west-1.compute.internal" is ready
[ℹ]  node "ip-192-168-75-87.eu-west-1.compute.internal" is ready
[ℹ]  node "ip-192-168-8-167.eu-west-1.compute.internal" is ready
[ℹ]  kubectl command should work with "/Users/ruan/.kube/config", try 'kubectl get nodes'
[+]  EKS cluster "my-eks-cluster" in "eu-west-1" region is ready
</code></pre>

<p>Now that our EKS cluster has been provisioned, let&rsquo;s browse through our AWS Management Console to understand what was provisioned.</p>

<h2>View the Provisioned Resources</h2>

<p>If we have a look at the Cloudformation stacks, we can see the two stacks that I mentioned previously:</p>

<p><img width="1057" alt="image" src="https://user-images.githubusercontent.com/567298/68996480-58c1aa80-08a3-11ea-95c1-0fcf0bc1863b.png"></p>

<p>Navigating to our EC2 Instances dashboard, we can see the three worker nodes that we provisioned. Remember that AWS manages the master nodes and we cant see them.</p>

<p><img width="1106" alt="image" src="https://user-images.githubusercontent.com/567298/68996520-ea311c80-08a3-11ea-8ea3-e9e481e4ba6f.png"></p>

<p>We have a ASG (Auto Scaling Group) associated with our worker nodes, nodegroup. We can make use of autoscaling and also have desired state, so we will test this out later where we will delete a worker node and verify if it gets replaced:</p>

<p><img width="1113" alt="image" src="https://user-images.githubusercontent.com/567298/68996551-2e242180-08a4-11ea-8df6-7b962b9aa03a.png"></p>

<h2>Navigate using Kubectl:</h2>

<p>Eksctl already applied the kubeconfig to <code>~/.kube/config</code>, so we can start using kubectl. Let&rsquo;s start by viewing the nodes:</p>

<pre><code>$ kubectl get nodes
NAME                                           STATUS   ROLES    AGE     VERSION
ip-192-168-42-186.eu-west-1.compute.internal   Ready    &lt;none&gt;   8m50s   v1.14.7-eks-1861c5
ip-192-168-75-87.eu-west-1.compute.internal    Ready    &lt;none&gt;   8m55s   v1.14.7-eks-1861c5
ip-192-168-8-167.eu-west-1.compute.internal    Ready    &lt;none&gt;   8m54s   v1.14.7-eks-1861c5
</code></pre>

<p>Viewing our pods from our <code>kube-system</code> namespace (we dont have any pods in our default namespace at the moment):</p>

<pre><code>$ kubectl get pods --namespace kube-system
NAME                       READY   STATUS    RESTARTS   AGE
aws-node-btfbk             1/1     Running   0          11m
aws-node-c6ktk             1/1     Running   0          11m
aws-node-wf8mc             1/1     Running   0          11m
coredns-759d6fc95f-ljxzf   1/1     Running   0          17m
coredns-759d6fc95f-s6lg6   1/1     Running   0          17m
kube-proxy-db46b           1/1     Running   0          11m
kube-proxy-ft4mc           1/1     Running   0          11m
kube-proxy-s5q2w           1/1     Running   0          11m
</code></pre>

<p>And our services from all our namespaces:</p>

<pre><code>$ kubectl get services --all-namespaces
NAMESPACE     NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)         AGE
default       kubernetes   ClusterIP   10.100.0.1    &lt;none&gt;        443/TCP         19m
kube-system   kube-dns     ClusterIP   10.100.0.10   &lt;none&gt;        53/UDP,53/TCP   19m
</code></pre>

<h2>Testing the ASG</h2>

<p>Let&rsquo;s view our current nodes in our cluster, then select the first node, delete it and verify if the ASG replaces that node.</p>

<p>First, view the nodes and select one node&rsquo;s address:</p>

<pre><code>$ kubectl get nodes
NAME                                           STATUS   ROLES    AGE   VERSION
ip-192-168-42-186.eu-west-1.compute.internal   Ready    &lt;none&gt;   37m   v1.14.7-eks-1861c5
ip-192-168-75-87.eu-west-1.compute.internal    Ready    &lt;none&gt;   37m   v1.14.7-eks-1861c5
ip-192-168-8-167.eu-west-1.compute.internal    Ready    &lt;none&gt;   37m   v1.14.7-eks-1861c5
</code></pre>

<p>Use the awscli to lookup the EC2 instance id, as we will need this id to delete the node:</p>

<pre><code>$ aws --profile dev ec2 describe-instances --query 'Reservations[*].Instances[?PrivateDnsName==`ip-192-168-42-186.eu-west-1.compute.internal`].[InstanceId][]' --output text
i-0d016de17a46d5178
</code></pre>

<p>Now that we have the EC2 instance id, delete the node:</p>

<pre><code>$ aws --profile dev ec2 terminate-instances --instance-id i-0d016de17a46d51782
{
    "TerminatingInstances": [
        {
            "CurrentState": {
                "Code": 32,
                "Name": "shutting-down"
            },
            "InstanceId": "i-0d016de17a46d5178",
            "PreviousState": {
                "Code": 16,
                "Name": "running"
            }
        }
    ]
}
</code></pre>

<p>Now that we have deleted the EC2 instance, view the nodes and you will see the node has been terminated:</p>

<pre><code>$ kubectl get nodes
NAME                                          STATUS   ROLES    AGE   VERSION
ip-192-168-75-87.eu-west-1.compute.internal   Ready    &lt;none&gt;   41m   v1.14.7-eks-1861c5
ip-192-168-8-167.eu-west-1.compute.internal   Ready    &lt;none&gt;   41m   v1.14.7-eks-1861c5
</code></pre>

<p>Allow about a minute so that the ASG can replace the node, and when you list again you will see that the ASG replaced the node :</p>

<pre><code>$ kubectl get nodes
NAME                                          STATUS   ROLES    AGE   VERSION
ip-192-168-42-61.eu-west-1.compute.internal   Ready    &lt;none&gt;   50s   v1.14.7-eks-1861c5
ip-192-168-75-87.eu-west-1.compute.internal   Ready    &lt;none&gt;   42m   v1.14.7-eks-1861c5
ip-192-168-8-167.eu-west-1.compute.internal   Ready    &lt;none&gt;   42m   v1.14.7-eks-1861c5
</code></pre>

<h2>Run a Pod</h2>

<p>Run a busybox pod on your EKS cluster:</p>

<pre><code>$ kubectl run --rm -it --generator run-pod/v1 my-busybox-pod --image busybox -- /bin/sh
</code></pre>

<p>You will be dropped into a shell:</p>

<pre><code>/ # busybox | head -1
BusyBox v1.31.1 (2019-10-28 18:40:01 UTC) multi-call binary.
</code></pre>

<p>And exit the shell:</p>

<pre><code>/ # exit
Session ended, resume using 'kubectl attach my-busybox-pod -c my-busybox-pod -i -t' command when the pod is running
pod "my-busybox-pod" deleted
</code></pre>

<h2>Scaling Nodes</h2>

<p>While I will not be covering auto-scaling in this post, we can manually scale the worker node count. Let&rsquo;s scale it down to 1 node.</p>

<p>First we need to get the EKS cluster name:</p>

<pre><code>$ eksctl --profile dev --region eu-west-1 get clusters
NAME        REGION
my-eks-cluster  eu-west-1
</code></pre>

<p>Then we need the node group id:</p>

<pre><code>$ eksctl --profile dev --region eu-west-1 get nodegroup --cluster my-eks-cluster
CLUSTER     NODEGROUP   CREATED         MIN SIZE    MAX SIZE    DESIRED CAPACITY    INSTANCE TYPE   IMAGE ID
my-eks-cluster  ng-f27f560e 2019-11-16T16:55:41Z    3       3       3           t2.small    ami-059c6874350e63ca9
</code></pre>

<p>Now that we have the node group id, we can scale the node count:</p>

<pre><code>$ eksctl --profile dev --region eu-west-1 scale nodegroup --cluster my-eks-cluster --nodes 1 ng-f27f560e

[ℹ]  scaling nodegroup stack "eksctl-my-eks-cluster-nodegroup-ng-f27f560e" in cluster eksctl-my-eks-cluster-cluster
[ℹ]  scaling nodegroup, desired capacity from 3 to 1, min size from 3 to 1
</code></pre>

<p>Now when we use kubectl to view the nodes, we will see we only have 1 worker node:</p>

<pre><code>$ kubectl get nodes
NAME                                          STATUS   ROLES    AGE   VERSION
ip-192-168-8-167.eu-west-1.compute.internal   Ready    &lt;none&gt;   73m   v1.14.7-eks-1861c5
</code></pre>

<h2>Clean Up</h2>

<p>If you want to follow along deploying a web application to your EKS cluster before we terminate the cluster, have a look at <a href="https://blog.ruanbekker.com/blog/2019/11/17/how-to-deploy-a-webapp-on-a-aws-eks-kubernetes-cluster/">Part 2 - EKS Tutorial</a> before continuing.</p>

<p>Once you are ready to terminate your EKS cluster, you can go ahead and terminate the cluster:</p>

<pre><code>$ eksctl --profile dev --region eu-west-1 delete cluster --name my-eks-cluster

[ℹ]  eksctl version 0.9.0
[ℹ]  using region eu-west-1
[ℹ]  deleting EKS cluster "my-eks-cluster"
[+]  kubeconfig has been updated
[ℹ]  cleaning up LoadBalancer services
[ℹ]  2 sequential tasks: { delete nodegroup "ng-f27f560e", delete cluster control plane "my-eks-cluster" [async] }
[ℹ]  will delete stack "eksctl-my-eks-cluster-nodegroup-ng-f27f560e"
[ℹ]  waiting for stack "eksctl-my-eks-cluster-nodegroup-ng-f27f560e" to get deleted
[ℹ]  will delete stack "eksctl-my-eks-cluster-cluster"
[+]  all cluster resources were deleted
</code></pre>

<h2>Further Reading on Kubernetes</h2>

<p>This is one amazing resource that covers a lot of kubernetes topics and will help you throughout your EKS journey:
- <a href="https://eksworkshop.com/introduction/">EKSWorkshop</a></p>

<h2>Thank You</h2>

<p>Let me know what you think. If you liked my content, feel free to checkout my content on <strong><a href="https://ruan.dev/">ruan.dev</a></strong> or follow me on twitter at <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong></p>

<center><script type='text/javascript' src='https://ko-fi.com/widgets/widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Buy Me a Coffee', '#46b798', 'A6423ZIQ');kofiwidget2.draw();</script></center>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing AWS Lambda Functions Locally on Docker With LambCi]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/11/14/testing-aws-lambda-functions-locally-on-docker-with-lambci/"/>
    <updated>2019-11-14T23:57:10+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/11/14/testing-aws-lambda-functions-locally-on-docker-with-lambci</id>
    <content type="html"><![CDATA[<p><a href="https://saythanks.io/to/ruanbekker"><img src="https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg" alt="Say Thanks!" /></a> <a href="https://linux-hackers-slack.herokuapp.com/"><img src="https://linux-hackers-slack.herokuapp.com/badge.svg" alt="Slack Status" /></a> <a href="https://linux-hackers.slack.com/"><img src="https://img.shields.io/badge/chat-on_slack-orange.svg" alt="Chat on Slack" /></a> <a href="https://github.com/ruanbekker"><img src="https://img.shields.io/github/followers/ruanbekker.svg?label=Follow&amp;style=social" alt="GitHub followers" /></a></p>

<p><a href="https://twitter.com/ruanbekker?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @ruanbekker</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>I discovered a Docker image called <strong>LambCi</strong> that allows you to test lambda functions locally on docker and wanted to share with you how it works.</p>

<h2>Python Lambda Function</h2>

<p>We will create a basic lambda function to demonstrate how it works.</p>

<pre><code>$ mkdir task
$ cat &gt; task/lambda_function.py &lt;&lt; EOF
import json

def lambda_handler(event, context):
    if event:

        try:
            event['name']
            name = event['name']
            output_string = 'My name is {}'.format(name.capitalize())

        except KeyError:
            output_string = 'A name was not defined in the event payload'

    return output_string
EOF
</code></pre>

<p>Now that we&rsquo;ve created the function, run the docker container with the parameters of the functions handler method and the event parameters:</p>

<pre><code>$ docker run --rm -v "$PWD/task":/var/task lambci/lambda:python3.7 lambda_function.lambda_handler '{"name": "ruan"}'
START RequestId: 70025895-1233-1362-8006-c2784b5d80b6 Version: $LATEST
END RequestId: 70025895-1233-1362-8006-c2784b5d80b6
REPORT RequestId: 70025895-1233-1362-8006-c2784b5d80b6  Duration: 7.51 ms   Billed Duration: 100 ms Memory Size: 1536 MB    Max Memory Used: 23 MB
"My name is Ruan"
</code></pre>

<p>And another call:</p>

<pre><code>$ docker run --rm -v "$PWD/task":/var/task lambci/lambda:python3.7 lambda_function.lambda_handler '{"nam": "ruan"}'
START RequestId: f7ab2e97-05db-1184-a009-11b92638534f Version: $LATEST
END RequestId: f7ab2e97-05db-1184-a009-11b92638534f
REPORT RequestId: f7ab2e97-05db-1184-a009-11b92638534f  Duration: 5.32 ms   Billed Duration: 100 ms Memory Size: 1536 MB    Max Memory Used: 23 MB
"A name was not defined in the event payload"
</code></pre>

<p>Checkout the dockerhub page for more info:
- <a href="https://hub.docker.com/r/lambci/lambda/">https://hub.docker.com/r/lambci/lambda/</a></p>

<h2>Thank You</h2>

<p>Let me know what you think. If you liked my content, feel free to checkout my content on <strong><a href="https://ruan.dev/">ruan.dev</a></strong> or follow me on twitter at <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong></p>

<center><script type='text/javascript' src='https://ko-fi.com/widgets/widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Buy Me a Coffee', '#46b798', 'A6423ZIQ');kofiwidget2.draw();</script></center>

]]></content>
  </entry>
  
</feed>
