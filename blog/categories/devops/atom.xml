<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Devops | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2019-09-08T13:25:07+02:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Concourse CI to Deploy to Docker Swarm]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/05/04/using-concourse-ci-to-deploy-to-docker-swarm/"/>
    <updated>2019-05-04T23:11:17+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/05/04/using-concourse-ci-to-deploy-to-docker-swarm</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/gzkdu9.jpg?nocache=1511644783495" alt="" /></p>

<p>In this tutorial we will use Concourse to Deploy our application to Docker Swarm.</p>

<h2>The Flow</h2>

<ul>
<li>Our application code resides on Github</li>
<li>The pipeline triggers when a commit is pushed to the master branch</li>
<li>The pipeline will automatically deploy to the staging environment</li>
<li>The pipeline requires a manual trigger to deploy to prod</li>
<li>Note: Staging and Prod on the same swarm for demonstration</li>
</ul>


<p>The code for this tutorial is available on my <strong><a href="https://github.com/ruanbekker/concourse-swarm-app-demo">github repository</a></strong></p>

<h2>Application Structure</h2>

<p>The application structure for our code looks like this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57184912-1d412f00-6ec3-11e9-85e9-6517d83e96e8.png" alt="" /></p>

<h2>Pipeline Walktrough</h2>

<p>Our <code>ci/pipeline.yml</code></p>

<pre><code class="yaml">resources:
  - name: main-repo
    type: git
    source:
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      branch: master
      private_key: ((github_private_key))

  - name: main-repo-staging
    type: git
    source:
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      branch: master
      private_key: ((github_private_key))
      paths:
        - config/staging/*

  - name: main-repo-prod
    type: git
    source:
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      branch: master
      private_key: ((github_private_key))
      paths:
        - config/prod/*

  - name: slack-alert
    type: slack-notification
    source:
      url: ((slack_notification_url))

  - name: version-staging
    type: semver
    source:
      driver: git
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      private_key: ((github_private_key))
      file: version-staging
      branch: version-staging

  - name: version-prod
    type: semver
    source:
      driver: git
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      private_key: ((github_private_key))
      file: version-prod
      branch: version-prod

resource_types:
  - name: slack-notification
    type: docker-image
    source:
      repository: cfcommunity/slack-notification-resource
      tag: v1.3.0

jobs:
  - name: bump-staging-version
    plan:
    - get: main-repo-staging
      trigger: true
    - get: version-staging
    - put: version-staging
      params:
        bump: major

  - name: bump-prod-version
    plan:
    - get: main-repo-prod
      trigger: true
    - get: version-prod
    - put: version-prod
      params:
        bump: major

  - name: deploy-staging
    plan:
    - get: main-repo-staging
    - get: main-repo
    - get: version-staging
      passed:
      - bump-staging-version
      trigger: true
    - task: deploy-staging
      params:
        DOCKER_SWARM_HOSTNAME: ((docker_swarm_staging_host))
        DOCKER_SWARM_KEY: ((docker_swarm_key))
        DOCKER_HUB_USER: ((docker_hub_user))
        DOCKER_HUB_PASSWORD: ((docker_hub_password))
        SERVICE_NAME: app-staging
        SWARM: staging
        ENVIRONMENT: staging
        AWS_ACCESS_KEY_ID: ((aws_access_key_id))
        AWS_SECRET_ACCESS_KEY: ((aws_secret_access_key))
        AWS_DEFAULT_REGION: ((aws_region))
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: rbekker87/build-tools
            tag: latest
            username: ((docker_hub_user))
            password: ((docker_hub_password))
        inputs:
        - name: main-repo-staging
        - name: main-repo
        - name: version-staging
        run:
          path: /bin/sh
          args:
            - -c
            - |
              ./main-repo/ci/scripts/deploy.sh
      on_failure:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) FAILED :rage: - TestApp Deploy to staging-swarm failed
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
      on_success:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) SUCCESS :aww_yeah: - TestApp Deploy to staging-swarm succeeded
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME

  - name: deploy-prod
    plan:
    - get: main-repo-prod
    - get: main-repo
    - get: version-prod
      passed:
      - bump-prod-version
    - task: deploy-prod
      params:
        DOCKER_SWARM_HOSTNAME: ((docker_swarm_prod_host))
        DOCKER_SWARM_KEY: ((docker_swarm_key))
        DOCKER_HUB_USER: ((docker_hub_user))
        DOCKER_HUB_PASSWORD: ((docker_hub_password))
        SERVICE_NAME: app-prod
        SWARM: prod
        ENVIRONMENT: production
        AWS_ACCESS_KEY_ID: ((aws_access_key_id))
        AWS_SECRET_ACCESS_KEY: ((aws_secret_access_key))
        AWS_DEFAULT_REGION: ((aws_region))
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: rbekker87/build-tools
            tag: latest
            username: ((docker_hub_user))
            password: ((docker_hub_password))
        inputs:
        - name: main-repo-prod
        - name: main-repo
        - name: version-prod
        run:
          path: /bin/sh
          args:
            - -c
            - |
              ./main-repo/ci/scripts/deploy.sh
      on_failure:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) FAILED :rage: - TestApp Deploy to prod-swarm failed
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
      on_success:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) SUCCESS :aww_yeah: - TestApp Deploy to prod-swarm succeeded
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
</code></pre>

<p>Our <code>ci/credentials.yml</code> which will hold all our secret info, which will remain local:</p>

<pre><code>username: yourdockerusername
password: yourdockerpassword
docker_swarm_prod_host: 10.20.30.40
...
</code></pre>

<p>The first step of our deploy will invoke a shell script that will establish a ssh tunnel to the docker host, mounting the docker socket to a tcp local port, then exporting the docker host port to the tunneled port, <code>ci/scripts/deploy.sh</code>:</p>

<pre><code>#!/usr/bin/env sh

export DOCKER_HOST="localhost:2376"

echo "${DOCKER_SWARM_KEY}" | sed -e 's/\(KEY-----\)\s/\1\n/g; s/\s\(-----END\)/\n\1/g' | sed -e '2s/\s\+/\n/g' &gt; key.pem
chmod 600 key.pem

screen -S \
  sshtunnel -m -d sh -c \
  "ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -i ./key.pem -NL localhost:2376:/var/run/docker.sock root@$DOCKER_SWARM_HOSTNAME"

sleep 5
docker login -u "${DOCKER_HUB_USER}" -p "${DOCKER_HUB_PASSWORD}"
docker stack deploy --prune -c ./main-repo/ci/docker/docker-compose.${ENVIRONMENT}.yml $SERVICE_NAME --with-registry-auth

if [ $? != "0" ]
  then
    echo "deploy failure for: $SERVICE_NAME"
    screen -S sshtunnel -X quit
    exit 1
  else
    set -x
    echo "deploy success for: $SERVICE_NAME"
    screen -S sshtunnel -X quit
fi
</code></pre>

<p>The deploy script references the docker-compose files, first our <code>ci/docker/docker-compose.staging.yml</code>:</p>

<pre><code>version: "3.4"

services:
  web:
    image: ruanbekker/web-center-name
    environment:
      - APP_ENVIRONMENT=Staging
    ports:
      - 81:5000
    networks:
      - web_net
    deploy:
      mode: replicated
      replicas: 2

networks:
  web_net: {}
</code></pre>

<p>Also, our docker-compose for production, <code>ci/docker/docker-compose.production.yml</code>:</p>

<pre><code>version: "3.4"

services:
  web:
    image: ruanbekker/web-center-name
    environment:
      - APP_ENVIRONMENT=Production
    ports:
      - 80:5000
    networks:
      - web_net
    deploy:
      mode: replicated
      replicas: 10

networks:
  web_net: {}
</code></pre>

<h2>Set the Pipeline in Concourse</h2>

<p>Create 2 branches in your github repository for versioning: <code>version-staging</code> and <code>version-prod</code>, then logon to concourse and save the target:</p>

<pre><code>$ fly -t ci login -n main -c http://&lt;concourse-ip&gt;
</code></pre>

<p>Set the pipeline, point the config, local variables definition and name the pipeline:</p>

<pre><code>$ fly -t ci sp -n main -c ci/pipeline.yml -p &lt;pipeline-name&gt; -l ci/&lt;variables&gt;.yml
</code></pre>

<p>You will find that the pipeline will look like below and that it will be in a paused state:</p>

<p><img src="https://user-images.githubusercontent.com/567298/54060759-96dfd800-4206-11e9-9236-e3b86783417c.png" alt="" /></p>

<p>Unpause the pipeline:</p>

<pre><code>$ fly -t ci up -p swarm-demo
</code></pre>

<p>The pipeline should kick-off automatically due to the trigger that is set to true:</p>

<p><img src="https://user-images.githubusercontent.com/567298/54060811-cbec2a80-4206-11e9-8de7-a0b308f20cef.png" alt="" /></p>

<p>Deployed automatically to staging, prod is a manual trigger:</p>

<p><img src="https://user-images.githubusercontent.com/567298/54060991-8e3bd180-4207-11e9-9726-2c01ca10d24a.png" alt="" /></p>

<h2>Testing our Application</h2>

<p>For demonstration purposes we have deployed staging on port 81 and production on port 80.</p>

<p>Testing Staging on <a href="http://">http://</a><swarm-ip>:81/</p>

<p><img src="https://user-images.githubusercontent.com/567298/57185377-73fe3700-6eca-11e9-91d3-953e754cbde9.png" alt="" /></p>

<p>Testing Production on <a href="http://">http://</a><swarm-ip>:80/</p>

<p><img src="https://user-images.githubusercontent.com/567298/57185383-8d06e800-6eca-11e9-8cff-c3a665f9f377.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using MongoDB Inside Drone CI Services for Unit Testing]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/05/04/using-mongodb-inside-drone-ci-services-for-unit-testing/"/>
    <updated>2019-05-04T20:52:37+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/05/04/using-mongodb-inside-drone-ci-services-for-unit-testing</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/57184017-4b1f7700-6eb5-11e9-886d-4b811687221a.png" alt="" /></p>

<p>Another nice thing about Drone CI is the &ldquo;Services&rdquo; configuration within your pipeline. At times your unit or integration testing steps might be dependent of a database such as MongoDB, MySQL etc.</p>

<p>Drone allows you to spin up a ephemeral database service such as MongoDB using a Docker container as the fist step within your pipeline, defined in the services section. This step will always run first.</p>

<p>The service container will be reachable via the configured container name as its hostname. Keep note that if you run multiple paralel jobs that the service container will only be reachable from the container where the mongodb container is running.</p>

<h2>What are we doing today</h2>

<p>We will setup a really basic (and a bit useless) pipeline that will spin up a mongodb service container, use a step to write random data to mongodb and a step that reads data from mongodb.</p>

<p>For demonstration purposes, the data is really random but more focused on the service section.</p>

<p>All the source code for this demonstration is available on my <strong><a href="https://github.com/ruanbekker/demo-drone-mongodb-tests">github repository</a></strong></p>

<h2>Our Drone Pipeline</h2>

<p>First we define our service, mongodb. Once the mongodb service is running, we will have our build step, our step that runs the mongodb version against our database, write data into our mongodb database, then read the data from mongodb, then the last step running a shell command with the date.</p>

<p>Our <code>.drone.yml</code> pipeline definition:</p>

<pre><code class="yaml">---
kind: pipeline
name: mongotests

services:
- name: mongo
  image: mongo:4
  command: [ --smallfiles ]
  ports:
  - 27017

steps:
- name: build-step
  image: alpine
  commands:
  - echo "this should be a step that does something"

- name: mongodb-return-version
  image: mongo:4
  commands:
  - date
  - mongo --host mongo --eval "db.version()"

- name: mongodb-test-writes
  image: mongo:4
  commands:
  - date
  - sh scripts/write_mongo.sh

- name: mongodb-test-reads
  image: mongo:4
  commands:
  - date
  - sh scripts/read_mongo.sh

- name: last-step
  image: alpine
  commands:
  - echo "completed at $(date)"
</code></pre>

<p>Our scripts referenced in our steps:</p>

<p>The first will be our script that write random data into mongodb, <code>scripts/write_mongo.sh</code>:</p>

<pre><code class="bash">#!/bin/sh
set -ex
echo "start writing"
mongo mongo:27017/mydb scripts/write.js
echo "done writing"
</code></pre>

<p>We are referencing a <code>scripts/write.js</code> file which is a function that randomizes data and generates a 1000 documents to write to mongodb:</p>

<pre><code class="javascript">var txs = []
for (var x = 0; x &lt; 1000 ; x++) {
 var transaction_types = ["credit card", "cash", "account"];
 var store_names = ["edgards", "cna", "makro", "picknpay", "checkers"];
 var random_transaction_type = Math.floor(Math.random() * (2 - 0 + 1)) + 0;
 var random_store_name = Math.floor(Math.random() * (4 - 0 + 1)) + 0;
 txs.push({
   transaction: 'tx_' + x,
   transaction_price: Math.round(Math.random()*1000),
   transaction_type: transaction_types[random_transaction_type],
   store_name: store_names[random_store_name]
   });
}
db.mycollection.insert(txs)
</code></pre>

<p>Our script that will read data from mongodb, <code>scripts/read_mongo.sh</code>:</p>

<pre><code>#!/bin/sh
set -ex
echo "start reading"
mongo mongo:27017/mydb &lt;&lt;EOF
db.mycollection.find().count();
db.mycollection.find({transaction_price: { \$gt: 990}}).forEach( printjson );
EOF
echo "done reading"
</code></pre>

<p>The <code>README.md</code> to include the build status:</p>

<pre><code>## project-name ![](https://cloud.drone.io/api/badges/&lt;user-name&gt;/&lt;project-name&gt;/status.svg?branch=master)
</code></pre>

<p>Once your source code is set in github, enable the repository on drone and push to github to trigger the build.</p>

<h2>Demo and Screenshots</h2>

<p>After pushing to github to trigger the build, heading over to drone, I can see that mongodb is running and our step has completed that executes the <code>db.version()</code> against mongodb:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183883-317d3000-6eb3-11e9-9aa0-7dd729514033.png" alt="" /></p>

<p>Next our step executes to write the random data into mongodb:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183911-989ae480-6eb3-11e9-942a-a9c1af191b7f.png" alt="" /></p>

<p>After the data has been written to mongodb, our next step will read the number of documents from mongodb, and also run a query for transaction prices more than 990:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183917-bc5e2a80-6eb3-11e9-802d-87e268b2fc43.png" alt="" /></p>

<p>Once that has completed, we will have a shell command returning the time when the last step completed:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183934-fa5b4e80-6eb3-11e9-9eb3-e58248e2286c.png" alt="" /></p>

<h2>Resources</h2>

<ul>
<li><a href="https://cloud.drone.io">Drone Hosted Service</a></li>
<li><a href="https://docs.drone.io/user-guide/pipeline/services/">Drone Services Documentation</a></li>
<li><a href="https://github.com/ruanbekker/demo-drone-mongodb-tests">Github Repository</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Drone CI to Build a Jekyll Site and Deploy to Docker Swarm]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/04/23/using-drone-ci-to-build-a-jekyll-site-and-deploy-to-docker-swarm/"/>
    <updated>2019-04-23T23:57:02+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/04/23/using-drone-ci-to-build-a-jekyll-site-and-deploy-to-docker-swarm</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/56618556-3de7ca00-6623-11e9-995f-c22792f0ab21.png" alt="image" /></p>

<p>CICD Pipelines! &lt;3</p>

<p>In this post I will show you how to setup a cicd pipeline using drone to build a jekyll site and deploy to docker swarm.</p>

<h2>Environment Overview</h2>

<p><strong>Jekyll&rsquo;s Codebase</strong>: Our code will be hosted on Github (I will demonstrate how to set it up from scratch)</p>

<p><strong>Secret Store</strong>: Our secrets such as ssh key, swarm host address etc will be stored in drones secrets manager</p>

<p><strong>Docker Swarm</strong>: Docker Swarm has Traefik as a HTTP Loadbalancer</p>

<p><strong>Drone Server and Agent</strong>: If you dont have drone, you can setup <a href="https://blog.ruanbekker.com/blog/2019/04/18/setup-a-drone-cicd-environment-on-docker-with-letsencrypt/">drone server and agent on docker</a> or have a look at <a href="https://cloud.drone.io">cloud.drone.io</a></p>

<p><strong>Workflow:</strong></p>

<pre><code>* Whenever a push to master is receive on github, the pipeline will be triggered
* The content from our github repository will be cloned to the agent on a container
* Jekyll will build and the output will be transferred to docker swarm using rsync
* The docker-compose.yml will be transferred to the docker swarm host using scp
* A docker stack deploy is ran via ssh
</code></pre>

<h2>Install Jekyll Locally</h2>

<p>Install Jekyll locally, as we will use it to create the initial site. I am using a mac, so I will be using <code>brew</code>. For other operating systems, have a look at <a href="https://jekyllrb.com/docs/installation/">this post</a>.</p>

<p>I will be demonstrating with a weightloss blog as an example.</p>

<p>Install jekyll:</p>

<pre><code>$ brew install jekyll
</code></pre>

<p>Go ahead and create a new site which will host the data for your jekyll site:</p>

<pre><code>$ jekyll new blog-weightloss
</code></pre>

<h2>Create a Github Repository</h2>

<p>First we need to create an empty github repository, in my example it was <code>github.com/ruanbekker/blog-weightloss.git</code>. Once you create the repo change into the directory created by the <code>jekyll new</code> command:</p>

<pre><code>$ cd blog-weightloss
</code></pre>

<p>Now initialize git, set the remote, add the jekyll data and push to github:</p>

<pre><code>$ git init
$ git remote add origin git@github.com:ruanbekker/blog-weightloss.git # &lt;== change to your repository
$ git add .
$ git commit -m "first commit"
$ git push origin master
</code></pre>

<p>You should see your data on your github repository.</p>

<h2>Create Secrets on Drone</h2>

<p>Logon to the Drone UI, sync repositories, activate the new repository and head over to settings where you will find the secrets section.</p>

<p>Add the following secrets:</p>

<pre><code>Secret Name: swarm_host
Secret Value: ip address of your swarm

Secret Name: swarm_key
Secret Value: contents of your private ssh key

Secret Name: swarm_user
Secret Value: the user that is allowed to ssh
</code></pre>

<p>You should see the following:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56619871-5c4fc480-6627-11e9-8820-c9d4ddff698c.png" alt="image" /></p>

<h2>Add the Drone Config</h2>

<p>Drone looks from a <code>.drone.yml</code> file in the root directory for instructions on how to do its tasks. Lets go ahead and declare our pipeline:</p>

<pre><code>$ vim .drone.yml
</code></pre>

<p>And populate the drone config:</p>

<pre><code>pipeline:
  jekyll-build:
    image: jekyll/jekyll:latest
    commands:
      - touch Gemfile.lock
      - chmod a+w Gemfile.lock
      - chown -R jekyll:jekyll /drone
      - gem update --system
      - gem install bundler
      - bundle install
      - bundle exec jekyll build

  transfer-build:
    image: drillster/drone-rsync
    hosts:
      from_secret: swarm_host
    key:
      from_secret: swarm_key
    user:
      from_secret: swarm_user
    source: ./*
    target: ~/my-weightloss-blog.com
    recursive: true
    delete: true
    when:
      branch: [master]
      event: [push]

  transfer-compose:
    image: appleboy/drone-scp
    host:
      from_secret: swarm_host
    username:
      from_secret: swarm_user
    key:
      from_secret: swarm_key
    target: /root/my-weightloss-blog.com
    source:
      - docker-compose.yml
    when:
      branch: [master]
      event: [push]

  deploy-jekyll-to-swarm:
    image: appleboy/drone-ssh
    host:
      from_secret: swarm_host
    username:
      from_secret: swarm_user
    key:
      from_secret: swarm_key
    port: 22
    script:
      - docker stack deploy --prune -c /root/my-weightloss-blog.com/docker-compose.yml apps
    when:
      branch: [master]
      event: [push]
</code></pre>

<h2>Notifications?</h2>

<p>If you want to be notified about your builds, you can add a slack notification step as the last step.</p>

<p>To do that, create a new webhook integration, you can <a href="https://blog.ruanbekker.com/blog/2019/04/18/setup-a-slack-webhook-for-sending-messages-from-applications/">follow this post for a step by step guide</a>. After you have the webhook, go to secrets and create a <code>slack_webhook</code> secret.</p>

<p>Then apply the notification step as shown below:</p>

<pre><code>  notify-via-slack:
    image: plugins/slack
    webhook:
      from_secret: slack_webhook
    channel: system_events
    template: &gt;
      
        [DRONE CI]: ** : /
        ( -  | )

      
        [DRONE CI]: ** : /
        ( -  | )
      
</code></pre>

<p>Based on the status, you should get a notification similar like this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56622206-6e356580-662f-11e9-8d93-286c9c126d24.png" alt="image" /></p>

<h2>Add the Docker Compose</h2>

<p>Next we need to declare our docker compose file which is needed to deploy our jekyll service to the swarm:</p>

<pre><code>$ vim docker-compose.yml
</code></pre>

<p>And populate this info (just change the values for your own environment/settings):</p>

<pre><code class="yaml">version: '3.5'

services:
  myweightlossblog:
    image: ruanbekker/jekyll:contrast
    command: jekyll serve --watch --force_polling --verbose
    networks:
      - appnet
    volumes:
      - /root/my-weightloss-blog.com:/srv/jekyll
    deploy:
      mode: replicated
      replicas: 1
      labels:
        - "traefik.backend.loadbalancer.sticky=false"
        - "traefik.backend.loadbalancer.swarm=true"
        - "traefik.backend=myweightlossblog"
        - "traefik.docker.network=appnet"
        - "traefik.entrypoints=https"
        - "traefik.frontend.passHostHeader=true"
        - "traefik.frontend.rule=Host:www.my-weightloss-blog.com,my-weightloss-blog.com"
        - "traefik.port=4000"
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
          - node.role == manager
networks:
  appnet:
    external: true
</code></pre>

<h2>Push to Github</h2>

<p>Now we need to push our <code>.drone.yml</code> and <code>docker-compose.yml</code> to github. Since the repository is activated on drone, any push to master will trigger the pipeline, so after this push we should go to drone to look at our pipeline running.</p>

<p>Add the untracked files and push to github:</p>

<pre><code>$ git add .drone.yml
$ git add docker-compose.yml
$ git commit -m "add drone and docker config"
$ git push origin master
</code></pre>

<p>As you head over to your drone ui, you should see your pipeline output which will look more or less like this (just look how pretty it is! :D )</p>

<p><img src="https://user-images.githubusercontent.com/567298/56620236-91a8e200-6628-11e9-9278-38e3305fdcd7.png" alt="image" /></p>

<h2>Test Jekyll</h2>

<p>If your deployment has completed you should be able to access your application on the configured domain. A screenshot of my response when accessing Jekyll:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56620280-af764700-6628-11e9-9d4f-c2592e6cf561.png" alt="image" /></p>

<p>Absolutely Amazingness! I really love drone!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a Drone CICD Environment on Docker With Letsencrypt]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/04/18/setup-a-drone-cicd-environment-on-docker-with-letsencrypt/"/>
    <updated>2019-04-18T18:53:49+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/04/18/setup-a-drone-cicd-environment-on-docker-with-letsencrypt</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/56378979-ed313500-620e-11e9-9ac0-4fcd1df803e8.png" alt="drone-ci" /></p>

<h2>What is Drone?</h2>

<p>Drone is a self-service continuous delivery platform which can be used for CICD pipelines, devopsy stuff which is really awesome.</p>

<p>With Configuration as Code, Pipelines are configured with a simple, easy‑to‑read file that you commit to your git repository such as github, gitlab, gogs, gitea etc.</p>

<p>Each Pipeline step is executed inside an isolated Docker container that is automatically downloaded at runtime, if not found in cache.</p>

<h2>Show me pipelines!</h2>

<p>A pipeline can look as easy as:</p>

<pre><code class="yaml">kind: pipeline
steps:
- name: test
  image: node
  commands:
  - npm install
  - npm test
services:
- name: database
  image: mysql
  ports:
  - 3306
</code></pre>

<h2>Open for Testing!</h2>

<p>I have enabled public access, so please go ahead and launch your cicd pipelines on my drone setup as I want to test the stability of it:</p>

<p>==> <a href="https://drone.rbkr.xyz/">https://drone.rbkr.xyz/</a></p>

<h2>What are we doing?</h2>

<p>We will deploy a drone server which is responsible for the actual server and 2 drone agents which will receive instructions from the server whenever steps need to be executed. Steps run on agents.</p>

<h2>Deploy the Servers</h2>

<p>I&rsquo;m using VULTR to deploy 3 nodes on coreos, 1 drone server and 2 drone agents as seen below:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56371668-d0403600-61fd-11e9-8396-01c07c136518.png" alt="image" /></p>

<p>Documentation:
<a href="https://docs.drone.io/installation/github/multi-machine/">https://docs.drone.io/installation/github/multi-machine/</a>
<a href="https://github.com/settings/developers">https://github.com/settings/developers</a></p>

<p>We will use Github for version control and to delegate auth, therefore we need to register a new application on Github.</p>

<p>Register New Application on Github at <a href="https://github.com/settings/developer">https://github.com/settings/developer</a> :</p>

<p><img src="https://user-images.githubusercontent.com/567298/56375985-22398980-6207-11e9-911d-9595f8f85db9.png" alt="register-application" /></p>

<p>Get your Drone-Server Host Endpoint, and update the fields:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56374721-287a3680-6204-11e9-837f-a7751651c29a.png" alt="image" /></p>

<p>You will receive a Github Client ID, Secret which we will need later, which will look like this:</p>

<pre><code>Client ID:
xx
Client Secret:
yyy
</code></pre>

<p>Generate the shared secret which will be used on the server and agent:</p>

<pre><code>$ openssl rand -hex 16
eb83xxe19a3497f597f53044250df6yy
</code></pre>

<p>Create the Startup Script for Drone Server, which will just be a docker container running in detached mode. Note that you should use your own domain at <code>SERVER_HOST</code> and if you want to issue an certificate automatically keep <code>DRONE_TLS_AUTOCERT</code> to true.</p>

<pre><code>$ cat &gt; start_drone-server.sh &lt;&lt; EOF
#!/usr/bin/env bash

set -ex

GITHUB_CLIENT_ID=xx
GITHUB_CLIENT_SECRET=yyy
SHARED_SECRET=eb83xxe19a3497f597f53044250df6yy
SERVER_HOST=drone.yourdomain.com
SERVER_PROTOCOL=https

docker run \
  --volume=/var/run/docker.sock:/var/run/docker.sock \
  --volume=/var/lib/drone:/data \
  --env=DRONE_GITHUB_SERVER=https://github.com \
  --env=DRONE_GITHUB_CLIENT_ID=${GITHUB_CLIENT_ID} \
  --env=DRONE_GITHUB_CLIENT_SECRET=${GITHUB_CLIENT_SECRET} \
  --env=DRONE_AGENTS_ENABLED=true \
  --env=DRONE_RPC_SECRET=${SHARED_SECRET} \
  --env=DRONE_SERVER_HOST=${SERVER_HOST} \
  --env=DRONE_SERVER_PROTO=${SERVER_PROTOCOL} \
  --env=DRONE_TLS_AUTOCERT=true \
  --env=DRONE_USER_CREATE=username:&lt;your-github-username&gt;,admin:true \
  --publish=80:80 \
  --publish=443:443 \
  --restart=always \
  --detach=true \
  --name=drone \
  drone/drone:1
EOF
</code></pre>

<p>Create the startup script for the drone agent, note that this script needs to be placed on the agent nodes:</p>

<pre><code>$ cat &gt; start_drone-agent.sh &lt;&lt; EOF
#!/usr/bin/env bash

set -ex

SHARED_SECRET=eb83xxe19a3497f597f53044250df6yy
AGENT_SERVER_HOST=https://drone.yourdomain.com
SERVER_PROTOCOL=https

docker run \
  --volume=/var/run/docker.sock:/var/run/docker.sock \
  --env=DRONE_RPC_SERVER=${AGENT_SERVER_HOST} \
  --env=DRONE_RPC_SECRET=${SHARED_SECRET} \
  --env=DRONE_RUNNER_CAPACITY=2 \
  --env=DRONE_RUNNER_NAME=${HOSTNAME} \
  --restart=always \
  --detach=true \
  --name=drone-agent-02 \
  drone/agent:1
EOF
</code></pre>

<p>Logon to the server node and start the drone server:</p>

<pre><code>$ bash start_drone-agent.sh
</code></pre>

<p>Login to the agent nodes and start the agents:</p>

<pre><code>$ bash start_drone-agent.sh
</code></pre>

<p>The server should show that it&rsquo;s listening on port 80 and 443:</p>

<pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND               CREATED             STATUS              PORTS                                      NAMES
8ea70fc7b967        drone/drone:1       "/bin/drone-server"   12 minutes ago      Up 12 minutes       0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   drone
</code></pre>

<h2>Access Drone</h2>

<p>Access your Drone instance on port 80 eg. <a href="http://drone.yourdomain.com">http://drone.yourdomain.com</a> you should be automatically redirected to port 443, which should direct you to a login page, which will look like this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56375632-5eb8b580-6206-11e9-9ae8-92b2cd29abec.png" alt="drone-authorize" /></p>

<p>Login with your github account and allow drone some time to sync your repositories:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56373131-9e7c9e80-6200-11e9-83ce-e486b399468e.png" alt="image" /></p>

<h2>Add drone config to your repository:</h2>

<p>Clone this repository: <a href="https://github.com/ruanbekker/drone-ci-testing">https://github.com/ruanbekker/drone-ci-testing</a> which will contain the <code>.drone.yml</code> config which drone gets its instructions from.</p>

<p>Select a repository to activate, (drone-ci-testing in this case) head over to settings:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56373298-f1565600-6200-11e9-8262-ac3162fed4f2.png" alt="image" /></p>

<p>Adding secret:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56373209-c5d36b80-6200-11e9-90de-68c131480672.png" alt="image" /></p>

<p>Add more secrets:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56373443-3da19600-6201-11e9-85a9-083bfcbd604a.png" alt="image" /></p>

<p>Your build list should be empty:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56373533-6fb2f800-6201-11e9-8fa0-ab05e546c36e.png" alt="image" /></p>

<h2>Trigger a Build</h2>

<p>Edit any of the files in the clone repository and you should see your build running:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56374465-85c1b800-6203-11e9-8542-acd1d5729447.png" alt="image" /></p>

<p>When your build has completed:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56374511-a25df000-6203-11e9-9eb8-d94a777a8b4a.png" alt="image" /></p>

<p>You can also find out where the step ran:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56374667-084a7780-6204-11e9-9c5b-6672f6882411.png" alt="image" /></p>

<p>Run a couple of tests:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56376356-e3f09a00-6207-11e9-8ca0-16e06e7c0379.png" alt="image" /></p>

<p>Get notified via slack:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56376376-eeab2f00-6207-11e9-9af9-194cb5a3023b.png" alt="image" /></p>

<h2>Debugging</h2>

<p>If your build fails, its most likely that you need the <code>slack_webhook</code> secret. You can remove the slack step which shouldhelp you get going with drone.</p>

<h2>More on Drone</h2>

<p>Have a look at <a href="https://github.com/ruanbekker/drone-ci-testing/blob/master/README.md">this document</a> for more examples or have a look at their <a href="https://docs.drone.io/">documentation</a> as well as their extensive list of <a href="http://plugins.drone.io/">plugins</a> and their <a href="https://docs.drone.io/installation/github/multi-machine/">setup documentation</a> to become familiar with their configuration.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Install Elasticsearch With Ansible Tutorial]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/04/06/install-elasticsearch-with-ansible-tutorial/"/>
    <updated>2019-04-06T21:45:09+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/04/06/install-elasticsearch-with-ansible-tutorial</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/55700285-f3cdda00-59ce-11e9-9c00-a05b9d469e23.png" alt="" /></p>

<p>In this tutorial we will install a elasticsearch cluster with ansible (well rather a node)</p>

<p>Our inventory:</p>

<pre><code>$ cat inventory.ini
[newes]
esnewnode

[newes:vars]
ansible_python_interpreter=/usr/bin/python3
</code></pre>

<p>Our playbook to bootstrap our nodes with Python:</p>

<pre><code>$ cat bootstrap-python.yml
---
- hosts: newes
  gather_facts: False

  tasks:
  - name: install python
    raw: test -e /usr/bin/python || ( apt update &amp;&amp; apt install python -y )
</code></pre>

<p>Our playbook to provision users:</p>

<pre><code>$ cat provision-users.yml
---
# Provisions User on Nodes
# Setup Passwordless SSH from Jumpbox
# Install Packages using APT
- name: bootstrap python
  hosts: newes
  roles:
    - bootstrap-python

- name: setup pre-requisites
  hosts: newes
  roles:
    - create-sudo-user
    - install-modules
    - configure-hosts-file

#- name: setup ruan user on the nodes
#  become: yes
#  become_user: ruan
#  hosts: admin
#  roles:
#    - configure-admin

- name: copy public key to nodes
  become: yes
  become_user: ruan
  hosts: newes
  roles:
    - copy-keys

- name: install elasticsearch
  hosts: newes
  roles:
    - elasticsearch
</code></pre>

<p>Our roles that will be included in our playbooks from above:</p>

<pre><code>$ cat roles/create-sudo-user/tasks/main.yml
---
- name: Create Sudo User
  user: name=ruan
        groups=sudo
        shell=/bin/bash
        generate_ssh_key=no
        state=present

- name: Set Passwordless SSH Access for ruan user
  copy: src=sudoers
        dest=/etc/sudoers.d
        mode=0440
</code></pre>

<p>Sudoers file for the create sudo role:</p>

<pre><code>$ cat roles/create-sudo-user/files/sudoers
ruan ALL=(ALL) NOPASSWD:ALL
</code></pre>

<p>The role to install all the apt packages:</p>

<pre><code>$ cat roles/install-modules/tasks/main.yml
---
- name: Install Packages
  apt: name= state=latest update_cache=yes
  with_items:
    - apt-transport-https
    - ntp
    - python
    - tcpdump
    - wget
    - openssl
    - curl
</code></pre>

<p>Role to configure hosts file:</p>

<pre><code>$ cat roles/configure-hosts-file/tasks/main.yml
---
- name: Configure Hosts File
  lineinfile: path=/etc/hosts regexp='.*$' line=" " state=present
  when: hostvars[item].ansible_default_ipv4.address is defined
  with_items: ""
</code></pre>

<p>The role to copy the ssh keys:</p>

<pre><code>$ cat roles/copy-keys/tasks/main.yml
---
- name: Copy Public Key to Other Hosts
  become: true
  become_user: ruan
  copy:
    src: /tmp/id_rsa.pub
    dest: /tmp/id_rsa.pub
    mode: 0644
- name: Append Public key in authorized_keys file
  authorized_key:
    user: ruan
    state: present
    key: ""
</code></pre>

<p>The role to install elasticsearch:</p>

<pre><code>$ cat roles/elasticsearch/tasks/main.yml
---
- name: get apt repo key
  apt_key:
    url: https://artifacts.elastic.co/GPG-KEY-elasticsearch
    state: present

- name: install apt repo
  apt_repository:
    repo: deb https://artifacts.elastic.co/packages/6.x/apt stable main
    state: present
    filename: elastic-6.x.list
    update_cache: yes

- name: install java
  apt:
    name: openjdk-8-jre
    state: present
    update_cache: yes

- name: install elasticsearch
  apt:
    name: elasticsearch
    state: present
    update_cache: yes

- name: reload systemd config
  systemd: daemon_reload=yes

- name: enable service elasticsearch and ensure it is not masked
  systemd:
    name: elasticsearch
    enabled: yes
    masked: no

- name: ensure elasticsearch is running
  systemd: state=started name=elasticsearch
</code></pre>

<h2>Deploy Elasticsearch</h2>

<p>Bootstrap python then deploy elasticsearch:</p>

<pre><code>$ ansible-playbook -i inventory.ini -u root bootstrap-python.yml
$ ansible-playbook -i inventory.ini -u root provision-users.yml
</code></pre>

<p>Test out elasticsearch:</p>

<pre><code>$ curl http://127.0.0.1:9200/
{
  "name" : "Z52AEZ7",
  "cluster_name" : "elasticsearch",
  "cluster_uuid" : "fUiYVjsSQpCbo9QKEiuvaA",
  "version" : {
    "number" : "6.3.0",
    "build_flavor" : "default",
    "build_type" : "deb",
    "build_hash" : "424e937",
    "build_date" : "2018-06-11T23:38:03.357887Z",
    "build_snapshot" : false,
    "lucene_version" : "7.3.1",
    "minimum_wire_compatibility_version" : "5.6.0",
    "minimum_index_compatibility_version" : "5.0.0"
  },
  "tagline" : "You Know, for Search"
}
</code></pre>
]]></content>
  </entry>
  
</feed>
