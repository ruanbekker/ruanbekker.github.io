<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Devops | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2020-02-04T23:02:50+02:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Run Kubernetes (K3s) as a Service Container on Drone CI]]></title>
    <link href="http://blog.ruanbekker.com/blog/2020/02/04/run-kubernetes-k3s-as-a-service-container-on-drone-ci/"/>
    <updated>2020-02-04T22:37:06+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2020/02/04/run-kubernetes-k3s-as-a-service-container-on-drone-ci</id>
    <content type="html"><![CDATA[<p><a href="https://docs.drone.io/pipeline/docker/syntax/services/">Drone services</a> allow you to run a service container and will be available for the duration of your build, which is great if you want a ephemeral service to test your applications against.</p>

<p>Today we will experiment with services on <a href="https://github.com/drone/drone">drone</a>  and will deploy a <a href="https://github.com/rancher/k3s">k3s</a> (a kubernetes distribution built by rancher) cluster as a drone service and interact with our cluster using kubectl.</p>

<p>I will be using multiple pipelines, where we will first deploy our &ldquo;dev cluster&rdquo;, when it&rsquo;s up, we will use kubectl to interact with the cluster, once that is done, we will deploy our &ldquo;staging cluster&rdquo; and do the same.</p>

<p>This is very basic and we are not doing anything special, but this is a starting point and you can do pretty much whatever you want.</p>

<h2>What is Drone</h2>

<p>If you are not aware of Drone, Drone is a container-native continious deliver platform built on Go and you can check them out <a href="https://github.com/drone/drone">here: github.com/drone</a></p>

<h2>Setup Gitea and Drone</h2>

<p>If you don&rsquo;t have the stack setup, have a look at <a href="https://blog.ruanbekker.com/blog/2020/02/04/setup-gitea-and-drone-on-docker-2020-edition/">this post</a> where I go into detail on how to get that setup.</p>

<h2>Create your Git Repo</h2>

<p>Go ahead and create a git repo, you can name it anything, then it should look something like this:</p>

<p><img width="1171" alt="image" src="https://user-images.githubusercontent.com/567298/73783555-90ead200-479c-11ea-8386-12518fb21b22.png"></p>

<p>Create a drone configuration, <code>.drone.yml</code> my pipeline will look like this:</p>

<pre><code>---
kind: pipeline
type: docker
name: dev

platform:
  os: linux
  arch: amd64

steps:
  - name: wait-for-k3s
    image: ruanbekker/build-tools
    commands:
      - sleep 30

  - name: prepare-k3s-kubeconfig
    image: alpine
    volumes:
      - name: k3s-kubeconfig
        path: /k3s-kubeconfig
    detach: false
    commands:
      - sed -i -e "s/127.0.0.1/k3s/g" /k3s-kubeconfig/kubeconfig.yaml

  - name: test-kubernetes
    image: ruanbekker/kubectl
    volumes:
      - name: k3s-kubeconfig
        path: /tmp
    environment:
      KUBECONFIG: /tmp/kubeconfig.yaml
    commands:
      - kubectl get nodes -o wide

services:
  - name: k3s
    image: rancher/k3s:v0.9.1
    privileged: true
    command:
      - server
    environment:
      K3S_KUBECONFIG_OUTPUT: /k3s-kubeconfig/kubeconfig.yaml
      K3S_KUBECONFIG_MODE: 777
    volumes:
      - name: k3s-kubeconfig
        path: /k3s-kubeconfig
    ports:
      - 6443

volumes:
- name: k3s-kubeconfig
  temp: {}

---
kind: pipeline
type: docker
name: staging

platform:
  os: linux
  arch: amd64

steps:
  - name: wait-for-k3s
    image: ruanbekker/build-tools
    commands:
      - sleep 30

  - name: prepare-k3s-kubeconfig
    image: alpine
    volumes:
      - name: k3s-kubeconfig
        path: /k3s-kubeconfig
    detach: false
    commands:
      - sed -i -e "s/127.0.0.1/k3s/g" /k3s-kubeconfig/kubeconfig.yaml

  - name: test-kubernetes
    image: ruanbekker/kubectl
    volumes:
      - name: k3s-kubeconfig
        path: /tmp
    environment:
      KUBECONFIG: /tmp/kubeconfig.yaml
    commands:
      - kubectl get nodes -o wide


services:
  - name: k3s
    image: rancher/k3s:v0.9.1
    privileged: true
    command:
      - server
    environment:
      K3S_KUBECONFIG_OUTPUT: /k3s-kubeconfig/kubeconfig.yaml
      K3S_KUBECONFIG_MODE: 777
    volumes:
      - name: k3s-kubeconfig
        path: /k3s-kubeconfig
    ports:
      - 6443

volumes:
- name: k3s-kubeconfig
  temp: {}

depends_on:
- dev
</code></pre>

<p>In this pipeline you can see that the staging pipeline depends on dev, so dev pipeline will start by creating the k3s service container, once its up I am using a step just to sleep for 30 seconds to allow it to boot.</p>

<p>Then I have defined a volume that will be persistent during the build time, which we will use to dump our kubeconfig file and update the hostname of our kubernetes endpoint. Once that is done our last step will set that file to the environment and use kubectl to interact with kubernetes.</p>

<p>Once our dev pipeline has finished, our staging pipeline will start.</p>

<h2>Activate the Repo in Drone</h2>

<p>Head over to drone on port <code>80</code> and activate the newly created git repo (and make sure that you select &ldquo;Trusted&rdquo;) and you will see the activity feed being empty:</p>

<p><img width="1008" alt="image" src="https://user-images.githubusercontent.com/567298/73784085-80872700-479d-11ea-9005-4cac54ac000d.png"></p>

<p>Commit a dummy file to git and you should see your pipeline being triggered:</p>

<p><img width="1013" alt="image" src="https://user-images.githubusercontent.com/567298/73784286-dd82dd00-479d-11ea-93f4-6363da53c1c1.png"></p>

<p>Once your pipeline has finished and everything succeeded, you should see the output of your nodes in your kubernetes service container:</p>

<p><img width="1068" alt="image" src="https://user-images.githubusercontent.com/567298/73784435-220e7880-479e-11ea-8f9d-a9856632302d.png"></p>

<h2>Thank You</h2>

<p>As I mentioned earlier, we are not doing anything special but service containers allows us to do some awesome things.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Gitea and Drone on Docker 2020 Edition]]></title>
    <link href="http://blog.ruanbekker.com/blog/2020/02/04/setup-gitea-and-drone-on-docker-2020-edition/"/>
    <updated>2020-02-04T21:58:39+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2020/02/04/setup-gitea-and-drone-on-docker-2020-edition</id>
    <content type="html"><![CDATA[<p>This post will show how to setup gitea and drone on a docker host with docker-compose. The drone example in this tutorial will be very basic, but in future posts I will focus more on pipeline examples using drone.</p>

<p>As this post I will use to link back for those who needs to setup the stack first.</p>

<h2>Deploy Gitea and Drone</h2>

<p>Get the docker-compose.yml:</p>

<pre><code>$ wget -O docker-compose.yml https://gist.githubusercontent.com/ruanbekker/27d2cb2e3f4194ee5cfe2bcdc9c4bf52/raw/25590a23e87190a871d70fd57ab461ce303cd286/2020.02.04-gitea-drone_docker-compose.yml
</code></pre>

<p>Verify the environment variables and adjust the defaults if you want to change something, if you want your git clone ssh url to point to a dns name as well as the url for gitea, then change the following to your dns:</p>

<pre><code>  gitea:
    ...
    environment:
      - ROOT_URL=http://gi.myresolvable.dns:3000
      - SSH_DOMAIN=git.myresolvable.dns
</code></pre>

<p>then deploy:</p>

<pre><code>$ docker-compose up -d
</code></pre>

<h2>Access your Stack</h2>

<p>The default port for Gitea in this setup is port <code>3000</code>:</p>

<p><img width="1273" alt="image" src="https://user-images.githubusercontent.com/567298/73778916-9b08d280-4794-11ea-88a6-8aafcd6e2656.png"></p>

<p>Initial configuration will be pre-populated from our environment variables:</p>

<p><img width="859" alt="image" src="https://user-images.githubusercontent.com/567298/73778973-b378ed00-4794-11ea-8615-d8deeee07b32.png"></p>

<p>From the additional settings section, create your admin user (this user is referenced in our docker-compose as well)</p>

<p><img width="871" alt="image" src="https://user-images.githubusercontent.com/567298/73779102-df946e00-4794-11ea-9177-712904e9dbee.png"></p>

<p>Because I am using gitea as my hostname, you will be redirected to <code>http://gitea:3000/user/login</code>, if you don&rsquo;t have a host entry setup for that it will fail, but you can just replace your servers ip in the request url and it will take you to the login screen, and after logging on, you should see this screen:</p>

<p><img width="1269" alt="image" src="https://user-images.githubusercontent.com/567298/73779494-752ffd80-4795-11ea-9c34-ff9eee269b0c.png"></p>

<p>Access drone on port 80, you will be directed to the login screen:</p>

<p><img width="773" alt="image" src="https://user-images.githubusercontent.com/567298/73779560-9395f900-4795-11ea-8f90-e420aa4c383d.png"></p>

<p>Use the same credentials that you have used to sign up with gitea, and after logging on, you should see this:</p>

<p><img width="1280" alt="image" src="https://user-images.githubusercontent.com/567298/73779651-b2948b00-4795-11ea-9939-51531467b600.png"></p>

<p>If ever your login does not work, just delete the drone access token on gitea (gitea:3000/user/settings/applications)</p>

<h2>Create a Git Repository</h2>

<p>On gitea, create a new git repository:</p>

<p><img width="698" alt="image" src="https://user-images.githubusercontent.com/567298/73779800-fdae9e00-4795-11ea-9422-938a24c08eb3.png"></p>

<p>You should now see your git repository:</p>

<p><img width="1005" alt="image" src="https://user-images.githubusercontent.com/567298/73779843-10c16e00-4796-11ea-98c6-2f70519146f0.png"></p>

<p>Create a new file <code>.drone.yml</code> with the following content:</p>

<pre><code>kind: pipeline
name: hello-world
type: docker

steps:
  - name: say-hello
    image: busybox
    commands:
      - echo hello-world
</code></pre>

<p>It should look like this:</p>

<p><img width="1019" alt="image" src="https://user-images.githubusercontent.com/567298/73779989-4fefbf00-4796-11ea-8e65-8441d3440d19.png"></p>

<h2>Configure Drone</h2>

<p>Commit the file in your git repository and head over to drone (which should be available on port <code>80</code>) and select &ldquo;Sync&rdquo;, after a couple of seconds you should see the git repository:</p>

<p><img width="860" alt="image" src="https://user-images.githubusercontent.com/567298/73780087-7f063080-4796-11ea-92ce-3d216c4e4097.png"></p>

<p>Select &ldquo;Activate&rdquo; and &ldquo;Activate Repository&rdquo;, on the next screen select &ldquo;Trusted&rdquo;, verify that the configuration file name is the same as which we created, then select save:</p>

<p><img width="860" alt="image" src="https://user-images.githubusercontent.com/567298/73780208-b543b000-4796-11ea-98f1-0f072eeae0ef.png"></p>

<h2>Trigger the Build</h2>

<p>If you click on &ldquo;Activity Feed&rdquo; you should see a empty feed. Head back to git and commit a dummy file to trigger the build to start. I will create a file name <code>trigger</code> with the value as <code>1</code> for my dummy file.</p>

<p>After committing the file, you will see on drone that the build started:</p>

<p><img width="900" alt="image" src="https://user-images.githubusercontent.com/567298/73780444-297e5380-4797-11ea-94e6-58c01ae11143.png"></p>

<p>When we select the build, you can see we have a clone step and the step that we defined to echo &ldquo;hello-world&rdquo;:</p>

<p><img width="851" alt="image" src="https://user-images.githubusercontent.com/567298/73780516-46b32200-4797-11ea-8a07-0563dea90d83.png"></p>

<h2>Thank You</h2>

<p>This was a basic introduction for gitea and drone, but I will use this post in conjunction with more gitea examples in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Save Output to Local File With Ansible]]></title>
    <link href="http://blog.ruanbekker.com/blog/2020/01/24/save-output-to-local-file-with-ansible/"/>
    <updated>2020-01-24T19:56:01+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2020/01/24/save-output-to-local-file-with-ansible</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/55700285-f3cdda00-59ce-11e9-9c00-a05b9d469e23.png" alt="" /></p>

<p>This playbook demonstrates how you can redirect shell output to a local file</p>

<h2>Inventory</h2>

<p>Our <code>inventory.ini</code> file:</p>

<pre><code>[localhost]
localhost
</code></pre>

<h2>The Script</h2>

<p>Our script: <code>/tmp/foo</code></p>

<pre><code class="bash">#!/usr/bin/env bash
echo "foo"
echo "bar"
</code></pre>

<p>Apply executable permissions:</p>

<pre><code>$ chmod +x /tmp/foo
</code></pre>

<h2>Playbook</h2>

<p>Our playbook: <code>debug.yml</code></p>

<pre><code class="yaml">---
- hosts: localhost
  tasks:
    - shell: /tmp/foo
      register: foo_result
      ignore_errors: True
    - local_action: copy content= dest=file
</code></pre>

<h2>Running</h2>

<p>Running the Ansible Playbook:</p>

<pre><code>$ ansible-playbook -i inventory.ini debug.yml

PLAY [localhost] ********************************************************************************************************************************************************************

TASK [shell] ************************************************************************************************************************************************************************
changed: [localhost]

TASK [copy] *************************************************************************************************************************************************************************
changed: [localhost -&gt; localhost]

PLAY RECAP **************************************************************************************************************************************************************************
localhost                  : ok=2    changed=2    unreachable=0    failed=0
</code></pre>

<p>View the local saved file:</p>

<pre><code>$ cat file
foo
bar
</code></pre>

<h2>Read More</h2>

<p>For more content on <a href="https://blog.ruanbekker.com/blog/categories/ansible/">Ansible</a> check out my <a href="https://blog.ruanbekker.com/blog/categories/ansible/">Ansible</a> category</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Environment Variables With Ansible]]></title>
    <link href="http://blog.ruanbekker.com/blog/2020/01/24/environment-variables-with-ansible/"/>
    <updated>2020-01-24T19:28:16+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2020/01/24/environment-variables-with-ansible</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/55700285-f3cdda00-59ce-11e9-9c00-a05b9d469e23.png" alt="" /></p>

<p>This is a quick post on how to use environment variables in ansible</p>

<h2>Inventory</h2>

<p>Our <code>inventory.ini</code> file looks like this:</p>

<pre><code>[localhost]
localhost
</code></pre>

<h2>Across Tasks</h2>

<p>You can set environment variables across tasks, and let your tasks inherit the variables:</p>

<pre><code class="yaml">- hosts: localhost
  vars:
    var_mysecret: secret123

  tasks:
    - name: echo my env var
      environment:
        MYNAME: ""
      shell: "echo hello $MYNAME &gt; /tmp/bla.txt"
      args:
        creates: /tmp/bla.txt
</code></pre>

<p>When we run the task:</p>

<pre><code class="bash">$ ansible-playbook -i inventory.ini -u ruan task.yml
</code></pre>

<p>Check the output:</p>

<pre><code class="bash">$ cat /tmp/bla.txt
hello secret123
</code></pre>

<h2>Environment Variables Per Task</h2>

<p>You can set environment variables per task:</p>

<pre><code class="yaml">- hosts: dev
  tasks:
    - name: echo my env var
      environment:
        MYNAME: "RUAN"
      shell: "echo hello $MYNAME &gt; /tmp/bla2.txt"
      args:
        creates: /tmp/bla2.txt
</code></pre>

<p>Running the task:</p>

<pre><code>$ ansible-playbook -i inventory.ini -u ruan task.yml
</code></pre>

<p>Checking the output:</p>

<pre><code>$ cat /tmp/bla2.txt
hello RUAN
</code></pre>

<h2>Read More</h2>

<p>Read more on environment variables in ansible in their <a href="https://docs.ansible.com/ansible/latest/plugins/lookup/env.html">documentation</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Concourse CI to Deploy to Docker Swarm]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/05/04/using-concourse-ci-to-deploy-to-docker-swarm/"/>
    <updated>2019-05-04T23:11:17+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/05/04/using-concourse-ci-to-deploy-to-docker-swarm</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/gzkdu9.jpg?nocache=1511644783495" alt="" /></p>

<p>In this tutorial we will use Concourse to Deploy our application to Docker Swarm.</p>

<h2>The Flow</h2>

<ul>
<li>Our application code resides on Github</li>
<li>The pipeline triggers when a commit is pushed to the master branch</li>
<li>The pipeline will automatically deploy to the staging environment</li>
<li>The pipeline requires a manual trigger to deploy to prod</li>
<li>Note: Staging and Prod on the same swarm for demonstration</li>
</ul>


<p>The code for this tutorial is available on my <strong><a href="https://github.com/ruanbekker/concourse-swarm-app-demo">github repository</a></strong></p>

<h2>Application Structure</h2>

<p>The application structure for our code looks like this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57184912-1d412f00-6ec3-11e9-85e9-6517d83e96e8.png" alt="" /></p>

<h2>Pipeline Walktrough</h2>

<p>Our <code>ci/pipeline.yml</code></p>

<pre><code class="yaml">resources:
  - name: main-repo
    type: git
    source:
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      branch: master
      private_key: ((github_private_key))

  - name: main-repo-staging
    type: git
    source:
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      branch: master
      private_key: ((github_private_key))
      paths:
        - config/staging/*

  - name: main-repo-prod
    type: git
    source:
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      branch: master
      private_key: ((github_private_key))
      paths:
        - config/prod/*

  - name: slack-alert
    type: slack-notification
    source:
      url: ((slack_notification_url))

  - name: version-staging
    type: semver
    source:
      driver: git
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      private_key: ((github_private_key))
      file: version-staging
      branch: version-staging

  - name: version-prod
    type: semver
    source:
      driver: git
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      private_key: ((github_private_key))
      file: version-prod
      branch: version-prod

resource_types:
  - name: slack-notification
    type: docker-image
    source:
      repository: cfcommunity/slack-notification-resource
      tag: v1.3.0

jobs:
  - name: bump-staging-version
    plan:
    - get: main-repo-staging
      trigger: true
    - get: version-staging
    - put: version-staging
      params:
        bump: major

  - name: bump-prod-version
    plan:
    - get: main-repo-prod
      trigger: true
    - get: version-prod
    - put: version-prod
      params:
        bump: major

  - name: deploy-staging
    plan:
    - get: main-repo-staging
    - get: main-repo
    - get: version-staging
      passed:
      - bump-staging-version
      trigger: true
    - task: deploy-staging
      params:
        DOCKER_SWARM_HOSTNAME: ((docker_swarm_staging_host))
        DOCKER_SWARM_KEY: ((docker_swarm_key))
        DOCKER_HUB_USER: ((docker_hub_user))
        DOCKER_HUB_PASSWORD: ((docker_hub_password))
        SERVICE_NAME: app-staging
        SWARM: staging
        ENVIRONMENT: staging
        AWS_ACCESS_KEY_ID: ((aws_access_key_id))
        AWS_SECRET_ACCESS_KEY: ((aws_secret_access_key))
        AWS_DEFAULT_REGION: ((aws_region))
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: rbekker87/build-tools
            tag: latest
            username: ((docker_hub_user))
            password: ((docker_hub_password))
        inputs:
        - name: main-repo-staging
        - name: main-repo
        - name: version-staging
        run:
          path: /bin/sh
          args:
            - -c
            - |
              ./main-repo/ci/scripts/deploy.sh
      on_failure:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) FAILED :rage: - TestApp Deploy to staging-swarm failed
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
      on_success:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) SUCCESS :aww_yeah: - TestApp Deploy to staging-swarm succeeded
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME

  - name: deploy-prod
    plan:
    - get: main-repo-prod
    - get: main-repo
    - get: version-prod
      passed:
      - bump-prod-version
    - task: deploy-prod
      params:
        DOCKER_SWARM_HOSTNAME: ((docker_swarm_prod_host))
        DOCKER_SWARM_KEY: ((docker_swarm_key))
        DOCKER_HUB_USER: ((docker_hub_user))
        DOCKER_HUB_PASSWORD: ((docker_hub_password))
        SERVICE_NAME: app-prod
        SWARM: prod
        ENVIRONMENT: production
        AWS_ACCESS_KEY_ID: ((aws_access_key_id))
        AWS_SECRET_ACCESS_KEY: ((aws_secret_access_key))
        AWS_DEFAULT_REGION: ((aws_region))
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: rbekker87/build-tools
            tag: latest
            username: ((docker_hub_user))
            password: ((docker_hub_password))
        inputs:
        - name: main-repo-prod
        - name: main-repo
        - name: version-prod
        run:
          path: /bin/sh
          args:
            - -c
            - |
              ./main-repo/ci/scripts/deploy.sh
      on_failure:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) FAILED :rage: - TestApp Deploy to prod-swarm failed
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
      on_success:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) SUCCESS :aww_yeah: - TestApp Deploy to prod-swarm succeeded
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
</code></pre>

<p>Our <code>ci/credentials.yml</code> which will hold all our secret info, which will remain local:</p>

<pre><code>username: yourdockerusername
password: yourdockerpassword
docker_swarm_prod_host: 10.20.30.40
...
</code></pre>

<p>The first step of our deploy will invoke a shell script that will establish a ssh tunnel to the docker host, mounting the docker socket to a tcp local port, then exporting the docker host port to the tunneled port, <code>ci/scripts/deploy.sh</code>:</p>

<pre><code>#!/usr/bin/env sh

export DOCKER_HOST="localhost:2376"

echo "${DOCKER_SWARM_KEY}" | sed -e 's/\(KEY-----\)\s/\1\n/g; s/\s\(-----END\)/\n\1/g' | sed -e '2s/\s\+/\n/g' &gt; key.pem
chmod 600 key.pem

screen -S \
  sshtunnel -m -d sh -c \
  "ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -i ./key.pem -NL localhost:2376:/var/run/docker.sock root@$DOCKER_SWARM_HOSTNAME"

sleep 5
docker login -u "${DOCKER_HUB_USER}" -p "${DOCKER_HUB_PASSWORD}"
docker stack deploy --prune -c ./main-repo/ci/docker/docker-compose.${ENVIRONMENT}.yml $SERVICE_NAME --with-registry-auth

if [ $? != "0" ]
  then
    echo "deploy failure for: $SERVICE_NAME"
    screen -S sshtunnel -X quit
    exit 1
  else
    set -x
    echo "deploy success for: $SERVICE_NAME"
    screen -S sshtunnel -X quit
fi
</code></pre>

<p>The deploy script references the docker-compose files, first our <code>ci/docker/docker-compose.staging.yml</code>:</p>

<pre><code>version: "3.4"

services:
  web:
    image: ruanbekker/web-center-name
    environment:
      - APP_ENVIRONMENT=Staging
    ports:
      - 81:5000
    networks:
      - web_net
    deploy:
      mode: replicated
      replicas: 2

networks:
  web_net: {}
</code></pre>

<p>Also, our docker-compose for production, <code>ci/docker/docker-compose.production.yml</code>:</p>

<pre><code>version: "3.4"

services:
  web:
    image: ruanbekker/web-center-name
    environment:
      - APP_ENVIRONMENT=Production
    ports:
      - 80:5000
    networks:
      - web_net
    deploy:
      mode: replicated
      replicas: 10

networks:
  web_net: {}
</code></pre>

<h2>Set the Pipeline in Concourse</h2>

<p>Create 2 branches in your github repository for versioning: <code>version-staging</code> and <code>version-prod</code>, then logon to concourse and save the target:</p>

<pre><code>$ fly -t ci login -n main -c http://&lt;concourse-ip&gt;
</code></pre>

<p>Set the pipeline, point the config, local variables definition and name the pipeline:</p>

<pre><code>$ fly -t ci sp -n main -c ci/pipeline.yml -p &lt;pipeline-name&gt; -l ci/&lt;variables&gt;.yml
</code></pre>

<p>You will find that the pipeline will look like below and that it will be in a paused state:</p>

<p><img src="https://user-images.githubusercontent.com/567298/54060759-96dfd800-4206-11e9-9236-e3b86783417c.png" alt="" /></p>

<p>Unpause the pipeline:</p>

<pre><code>$ fly -t ci up -p swarm-demo
</code></pre>

<p>The pipeline should kick-off automatically due to the trigger that is set to true:</p>

<p><img src="https://user-images.githubusercontent.com/567298/54060811-cbec2a80-4206-11e9-8de7-a0b308f20cef.png" alt="" /></p>

<p>Deployed automatically to staging, prod is a manual trigger:</p>

<p><img src="https://user-images.githubusercontent.com/567298/54060991-8e3bd180-4207-11e9-9726-2c01ca10d24a.png" alt="" /></p>

<h2>Testing our Application</h2>

<p>For demonstration purposes we have deployed staging on port 81 and production on port 80.</p>

<p>Testing Staging on <a href="http://">http://</a><swarm-ip>:81/</p>

<p><img src="https://user-images.githubusercontent.com/567298/57185377-73fe3700-6eca-11e9-91d3-953e754cbde9.png" alt="" /></p>

<p>Testing Production on <a href="http://">http://</a><swarm-ip>:80/</p>

<p><img src="https://user-images.githubusercontent.com/567298/57185383-8d06e800-6eca-11e9-8cff-c3a665f9f377.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>
