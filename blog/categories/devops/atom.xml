<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Devops | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2020-01-24T20:00:50+02:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Save Output to Local File With Ansible]]></title>
    <link href="http://blog.ruanbekker.com/blog/2020/01/24/save-output-to-local-file-with-ansible/"/>
    <updated>2020-01-24T19:56:01+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2020/01/24/save-output-to-local-file-with-ansible</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/55700285-f3cdda00-59ce-11e9-9c00-a05b9d469e23.png" alt="" /></p>

<p>This playbook demonstrates how you can redirect shell output to a local file</p>

<h2>Inventory</h2>

<p>Our <code>inventory.ini</code> file:</p>

<pre><code>[localhost]
localhost
</code></pre>

<h2>The Script</h2>

<p>Our script: <code>/tmp/foo</code></p>

<pre><code class="bash">#!/usr/bin/env bash
echo "foo"
echo "bar"
</code></pre>

<p>Apply executable permissions:</p>

<pre><code>$ chmod +x /tmp/foo
</code></pre>

<h2>Playbook</h2>

<p>Our playbook: <code>debug.yml</code></p>

<pre><code class="yaml">---
- hosts: localhost
  tasks:
    - shell: /tmp/foo
      register: foo_result
      ignore_errors: True
    - local_action: copy content= dest=file
</code></pre>

<h2>Running</h2>

<p>Running the Ansible Playbook:</p>

<pre><code>$ ansible-playbook -i inventory.ini debug.yml

PLAY [localhost] ********************************************************************************************************************************************************************

TASK [shell] ************************************************************************************************************************************************************************
changed: [localhost]

TASK [copy] *************************************************************************************************************************************************************************
changed: [localhost -&gt; localhost]

PLAY RECAP **************************************************************************************************************************************************************************
localhost                  : ok=2    changed=2    unreachable=0    failed=0
</code></pre>

<p>View the local saved file:</p>

<pre><code>$ cat file
foo
bar
</code></pre>

<h2>Read More</h2>

<p>For more content on <a href="https://blog.ruanbekker.com/blog/categories/ansible/">Ansible</a> check out my <a href="https://blog.ruanbekker.com/blog/categories/ansible/">Ansible</a> category</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Environment Variables With Ansible]]></title>
    <link href="http://blog.ruanbekker.com/blog/2020/01/24/environment-variables-with-ansible/"/>
    <updated>2020-01-24T19:28:16+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2020/01/24/environment-variables-with-ansible</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/55700285-f3cdda00-59ce-11e9-9c00-a05b9d469e23.png" alt="" /></p>

<p>This is a quick post on how to use environment variables in ansible</p>

<h2>Inventory</h2>

<p>Our <code>inventory.ini</code> file looks like this:</p>

<pre><code>[localhost]
localhost
</code></pre>

<h2>Across Tasks</h2>

<p>You can set environment variables across tasks, and let your tasks inherit the variables:</p>

<pre><code class="yaml">- hosts: localhost
  vars:
    var_mysecret: secret123

  tasks:
    - name: echo my env var
      environment:
        MYNAME: ""
      shell: "echo hello $MYNAME &gt; /tmp/bla.txt"
      args:
        creates: /tmp/bla.txt
</code></pre>

<p>When we run the task:</p>

<pre><code class="bash">$ ansible-playbook -i inventory.ini -u ruan task.yml
</code></pre>

<p>Check the output:</p>

<pre><code class="bash">$ cat /tmp/bla.txt
hello secret123
</code></pre>

<h2>Environment Variables Per Task</h2>

<p>You can set environment variables per task:</p>

<pre><code class="yaml">- hosts: dev
  tasks:
    - name: echo my env var
      environment:
        MYNAME: "RUAN"
      shell: "echo hello $MYNAME &gt; /tmp/bla2.txt"
      args:
        creates: /tmp/bla2.txt
</code></pre>

<p>Running the task:</p>

<pre><code>$ ansible-playbook -i inventory.ini -u ruan task.yml
</code></pre>

<p>Checking the output:</p>

<pre><code>$ cat /tmp/bla2.txt
hello RUAN
</code></pre>

<h2>Read More</h2>

<p>Read more on environment variables in ansible in their <a href="https://docs.ansible.com/ansible/latest/plugins/lookup/env.html">documentation</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Concourse CI to Deploy to Docker Swarm]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/05/04/using-concourse-ci-to-deploy-to-docker-swarm/"/>
    <updated>2019-05-04T23:11:17+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/05/04/using-concourse-ci-to-deploy-to-docker-swarm</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/gzkdu9.jpg?nocache=1511644783495" alt="" /></p>

<p>In this tutorial we will use Concourse to Deploy our application to Docker Swarm.</p>

<h2>The Flow</h2>

<ul>
<li>Our application code resides on Github</li>
<li>The pipeline triggers when a commit is pushed to the master branch</li>
<li>The pipeline will automatically deploy to the staging environment</li>
<li>The pipeline requires a manual trigger to deploy to prod</li>
<li>Note: Staging and Prod on the same swarm for demonstration</li>
</ul>


<p>The code for this tutorial is available on my <strong><a href="https://github.com/ruanbekker/concourse-swarm-app-demo">github repository</a></strong></p>

<h2>Application Structure</h2>

<p>The application structure for our code looks like this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57184912-1d412f00-6ec3-11e9-85e9-6517d83e96e8.png" alt="" /></p>

<h2>Pipeline Walktrough</h2>

<p>Our <code>ci/pipeline.yml</code></p>

<pre><code class="yaml">resources:
  - name: main-repo
    type: git
    source:
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      branch: master
      private_key: ((github_private_key))

  - name: main-repo-staging
    type: git
    source:
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      branch: master
      private_key: ((github_private_key))
      paths:
        - config/staging/*

  - name: main-repo-prod
    type: git
    source:
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      branch: master
      private_key: ((github_private_key))
      paths:
        - config/prod/*

  - name: slack-alert
    type: slack-notification
    source:
      url: ((slack_notification_url))

  - name: version-staging
    type: semver
    source:
      driver: git
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      private_key: ((github_private_key))
      file: version-staging
      branch: version-staging

  - name: version-prod
    type: semver
    source:
      driver: git
      uri: git@github.com:ruanbekker/concourse-swarm-app-demo.git
      private_key: ((github_private_key))
      file: version-prod
      branch: version-prod

resource_types:
  - name: slack-notification
    type: docker-image
    source:
      repository: cfcommunity/slack-notification-resource
      tag: v1.3.0

jobs:
  - name: bump-staging-version
    plan:
    - get: main-repo-staging
      trigger: true
    - get: version-staging
    - put: version-staging
      params:
        bump: major

  - name: bump-prod-version
    plan:
    - get: main-repo-prod
      trigger: true
    - get: version-prod
    - put: version-prod
      params:
        bump: major

  - name: deploy-staging
    plan:
    - get: main-repo-staging
    - get: main-repo
    - get: version-staging
      passed:
      - bump-staging-version
      trigger: true
    - task: deploy-staging
      params:
        DOCKER_SWARM_HOSTNAME: ((docker_swarm_staging_host))
        DOCKER_SWARM_KEY: ((docker_swarm_key))
        DOCKER_HUB_USER: ((docker_hub_user))
        DOCKER_HUB_PASSWORD: ((docker_hub_password))
        SERVICE_NAME: app-staging
        SWARM: staging
        ENVIRONMENT: staging
        AWS_ACCESS_KEY_ID: ((aws_access_key_id))
        AWS_SECRET_ACCESS_KEY: ((aws_secret_access_key))
        AWS_DEFAULT_REGION: ((aws_region))
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: rbekker87/build-tools
            tag: latest
            username: ((docker_hub_user))
            password: ((docker_hub_password))
        inputs:
        - name: main-repo-staging
        - name: main-repo
        - name: version-staging
        run:
          path: /bin/sh
          args:
            - -c
            - |
              ./main-repo/ci/scripts/deploy.sh
      on_failure:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) FAILED :rage: - TestApp Deploy to staging-swarm failed
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
      on_success:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) SUCCESS :aww_yeah: - TestApp Deploy to staging-swarm succeeded
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME

  - name: deploy-prod
    plan:
    - get: main-repo-prod
    - get: main-repo
    - get: version-prod
      passed:
      - bump-prod-version
    - task: deploy-prod
      params:
        DOCKER_SWARM_HOSTNAME: ((docker_swarm_prod_host))
        DOCKER_SWARM_KEY: ((docker_swarm_key))
        DOCKER_HUB_USER: ((docker_hub_user))
        DOCKER_HUB_PASSWORD: ((docker_hub_password))
        SERVICE_NAME: app-prod
        SWARM: prod
        ENVIRONMENT: production
        AWS_ACCESS_KEY_ID: ((aws_access_key_id))
        AWS_SECRET_ACCESS_KEY: ((aws_secret_access_key))
        AWS_DEFAULT_REGION: ((aws_region))
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: rbekker87/build-tools
            tag: latest
            username: ((docker_hub_user))
            password: ((docker_hub_password))
        inputs:
        - name: main-repo-prod
        - name: main-repo
        - name: version-prod
        run:
          path: /bin/sh
          args:
            - -c
            - |
              ./main-repo/ci/scripts/deploy.sh
      on_failure:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) FAILED :rage: - TestApp Deploy to prod-swarm failed
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
      on_success:
        put: slack-alert
        params:
          channel: '#system_events'
          username: 'concourse'
          icon_emoji: ':concourse:'
          silent: true
          text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) SUCCESS :aww_yeah: - TestApp Deploy to prod-swarm succeeded
            http://ci.example.local/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
</code></pre>

<p>Our <code>ci/credentials.yml</code> which will hold all our secret info, which will remain local:</p>

<pre><code>username: yourdockerusername
password: yourdockerpassword
docker_swarm_prod_host: 10.20.30.40
...
</code></pre>

<p>The first step of our deploy will invoke a shell script that will establish a ssh tunnel to the docker host, mounting the docker socket to a tcp local port, then exporting the docker host port to the tunneled port, <code>ci/scripts/deploy.sh</code>:</p>

<pre><code>#!/usr/bin/env sh

export DOCKER_HOST="localhost:2376"

echo "${DOCKER_SWARM_KEY}" | sed -e 's/\(KEY-----\)\s/\1\n/g; s/\s\(-----END\)/\n\1/g' | sed -e '2s/\s\+/\n/g' &gt; key.pem
chmod 600 key.pem

screen -S \
  sshtunnel -m -d sh -c \
  "ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -i ./key.pem -NL localhost:2376:/var/run/docker.sock root@$DOCKER_SWARM_HOSTNAME"

sleep 5
docker login -u "${DOCKER_HUB_USER}" -p "${DOCKER_HUB_PASSWORD}"
docker stack deploy --prune -c ./main-repo/ci/docker/docker-compose.${ENVIRONMENT}.yml $SERVICE_NAME --with-registry-auth

if [ $? != "0" ]
  then
    echo "deploy failure for: $SERVICE_NAME"
    screen -S sshtunnel -X quit
    exit 1
  else
    set -x
    echo "deploy success for: $SERVICE_NAME"
    screen -S sshtunnel -X quit
fi
</code></pre>

<p>The deploy script references the docker-compose files, first our <code>ci/docker/docker-compose.staging.yml</code>:</p>

<pre><code>version: "3.4"

services:
  web:
    image: ruanbekker/web-center-name
    environment:
      - APP_ENVIRONMENT=Staging
    ports:
      - 81:5000
    networks:
      - web_net
    deploy:
      mode: replicated
      replicas: 2

networks:
  web_net: {}
</code></pre>

<p>Also, our docker-compose for production, <code>ci/docker/docker-compose.production.yml</code>:</p>

<pre><code>version: "3.4"

services:
  web:
    image: ruanbekker/web-center-name
    environment:
      - APP_ENVIRONMENT=Production
    ports:
      - 80:5000
    networks:
      - web_net
    deploy:
      mode: replicated
      replicas: 10

networks:
  web_net: {}
</code></pre>

<h2>Set the Pipeline in Concourse</h2>

<p>Create 2 branches in your github repository for versioning: <code>version-staging</code> and <code>version-prod</code>, then logon to concourse and save the target:</p>

<pre><code>$ fly -t ci login -n main -c http://&lt;concourse-ip&gt;
</code></pre>

<p>Set the pipeline, point the config, local variables definition and name the pipeline:</p>

<pre><code>$ fly -t ci sp -n main -c ci/pipeline.yml -p &lt;pipeline-name&gt; -l ci/&lt;variables&gt;.yml
</code></pre>

<p>You will find that the pipeline will look like below and that it will be in a paused state:</p>

<p><img src="https://user-images.githubusercontent.com/567298/54060759-96dfd800-4206-11e9-9236-e3b86783417c.png" alt="" /></p>

<p>Unpause the pipeline:</p>

<pre><code>$ fly -t ci up -p swarm-demo
</code></pre>

<p>The pipeline should kick-off automatically due to the trigger that is set to true:</p>

<p><img src="https://user-images.githubusercontent.com/567298/54060811-cbec2a80-4206-11e9-8de7-a0b308f20cef.png" alt="" /></p>

<p>Deployed automatically to staging, prod is a manual trigger:</p>

<p><img src="https://user-images.githubusercontent.com/567298/54060991-8e3bd180-4207-11e9-9726-2c01ca10d24a.png" alt="" /></p>

<h2>Testing our Application</h2>

<p>For demonstration purposes we have deployed staging on port 81 and production on port 80.</p>

<p>Testing Staging on <a href="http://">http://</a><swarm-ip>:81/</p>

<p><img src="https://user-images.githubusercontent.com/567298/57185377-73fe3700-6eca-11e9-91d3-953e754cbde9.png" alt="" /></p>

<p>Testing Production on <a href="http://">http://</a><swarm-ip>:80/</p>

<p><img src="https://user-images.githubusercontent.com/567298/57185383-8d06e800-6eca-11e9-8cff-c3a665f9f377.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using MongoDB Inside Drone CI Services for Unit Testing]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/05/04/using-mongodb-inside-drone-ci-services-for-unit-testing/"/>
    <updated>2019-05-04T20:52:37+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/05/04/using-mongodb-inside-drone-ci-services-for-unit-testing</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/57184017-4b1f7700-6eb5-11e9-886d-4b811687221a.png" alt="" /></p>

<p>Another nice thing about Drone CI is the &ldquo;Services&rdquo; configuration within your pipeline. At times your unit or integration testing steps might be dependent of a database such as MongoDB, MySQL etc.</p>

<p>Drone allows you to spin up a ephemeral database service such as MongoDB using a Docker container as the fist step within your pipeline, defined in the services section. This step will always run first.</p>

<p>The service container will be reachable via the configured container name as its hostname. Keep note that if you run multiple paralel jobs that the service container will only be reachable from the container where the mongodb container is running.</p>

<h2>What are we doing today</h2>

<p>We will setup a really basic (and a bit useless) pipeline that will spin up a mongodb service container, use a step to write random data to mongodb and a step that reads data from mongodb.</p>

<p>For demonstration purposes, the data is really random but more focused on the service section.</p>

<p>All the source code for this demonstration is available on my <strong><a href="https://github.com/ruanbekker/demo-drone-mongodb-tests">github repository</a></strong></p>

<h2>Our Drone Pipeline</h2>

<p>First we define our service, mongodb. Once the mongodb service is running, we will have our build step, our step that runs the mongodb version against our database, write data into our mongodb database, then read the data from mongodb, then the last step running a shell command with the date.</p>

<p>Our <code>.drone.yml</code> pipeline definition:</p>

<pre><code class="yaml">---
kind: pipeline
name: mongotests

services:
- name: mongo
  image: mongo:4
  command: [ --smallfiles ]
  ports:
  - 27017

steps:
- name: build-step
  image: alpine
  commands:
  - echo "this should be a step that does something"

- name: mongodb-return-version
  image: mongo:4
  commands:
  - date
  - mongo --host mongo --eval "db.version()"

- name: mongodb-test-writes
  image: mongo:4
  commands:
  - date
  - sh scripts/write_mongo.sh

- name: mongodb-test-reads
  image: mongo:4
  commands:
  - date
  - sh scripts/read_mongo.sh

- name: last-step
  image: alpine
  commands:
  - echo "completed at $(date)"
</code></pre>

<p>Our scripts referenced in our steps:</p>

<p>The first will be our script that write random data into mongodb, <code>scripts/write_mongo.sh</code>:</p>

<pre><code class="bash">#!/bin/sh
set -ex
echo "start writing"
mongo mongo:27017/mydb scripts/write.js
echo "done writing"
</code></pre>

<p>We are referencing a <code>scripts/write.js</code> file which is a function that randomizes data and generates a 1000 documents to write to mongodb:</p>

<pre><code class="javascript">var txs = []
for (var x = 0; x &lt; 1000 ; x++) {
 var transaction_types = ["credit card", "cash", "account"];
 var store_names = ["edgards", "cna", "makro", "picknpay", "checkers"];
 var random_transaction_type = Math.floor(Math.random() * (2 - 0 + 1)) + 0;
 var random_store_name = Math.floor(Math.random() * (4 - 0 + 1)) + 0;
 txs.push({
   transaction: 'tx_' + x,
   transaction_price: Math.round(Math.random()*1000),
   transaction_type: transaction_types[random_transaction_type],
   store_name: store_names[random_store_name]
   });
}
db.mycollection.insert(txs)
</code></pre>

<p>Our script that will read data from mongodb, <code>scripts/read_mongo.sh</code>:</p>

<pre><code>#!/bin/sh
set -ex
echo "start reading"
mongo mongo:27017/mydb &lt;&lt;EOF
db.mycollection.find().count();
db.mycollection.find({transaction_price: { \$gt: 990}}).forEach( printjson );
EOF
echo "done reading"
</code></pre>

<p>The <code>README.md</code> to include the build status:</p>

<pre><code>## project-name ![](https://cloud.drone.io/api/badges/&lt;user-name&gt;/&lt;project-name&gt;/status.svg?branch=master)
</code></pre>

<p>Once your source code is set in github, enable the repository on drone and push to github to trigger the build.</p>

<h2>Demo and Screenshots</h2>

<p>After pushing to github to trigger the build, heading over to drone, I can see that mongodb is running and our step has completed that executes the <code>db.version()</code> against mongodb:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183883-317d3000-6eb3-11e9-9aa0-7dd729514033.png" alt="" /></p>

<p>Next our step executes to write the random data into mongodb:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183911-989ae480-6eb3-11e9-942a-a9c1af191b7f.png" alt="" /></p>

<p>After the data has been written to mongodb, our next step will read the number of documents from mongodb, and also run a query for transaction prices more than 990:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183917-bc5e2a80-6eb3-11e9-802d-87e268b2fc43.png" alt="" /></p>

<p>Once that has completed, we will have a shell command returning the time when the last step completed:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183934-fa5b4e80-6eb3-11e9-9eb3-e58248e2286c.png" alt="" /></p>

<h2>Resources</h2>

<ul>
<li><a href="https://cloud.drone.io">Drone Hosted Service</a></li>
<li><a href="https://docs.drone.io/user-guide/pipeline/services/">Drone Services Documentation</a></li>
<li><a href="https://github.com/ruanbekker/demo-drone-mongodb-tests">Github Repository</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Drone CI to Build a Jekyll Site and Deploy to Docker Swarm]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/04/23/using-drone-ci-to-build-a-jekyll-site-and-deploy-to-docker-swarm/"/>
    <updated>2019-04-23T23:57:02+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/04/23/using-drone-ci-to-build-a-jekyll-site-and-deploy-to-docker-swarm</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/56618556-3de7ca00-6623-11e9-995f-c22792f0ab21.png" alt="image" /></p>

<p>CICD Pipelines! &lt;3</p>

<p>In this post I will show you how to setup a cicd pipeline using drone to build a jekyll site and deploy to docker swarm.</p>

<h2>Environment Overview</h2>

<p><strong>Jekyll&rsquo;s Codebase</strong>: Our code will be hosted on Github (I will demonstrate how to set it up from scratch)</p>

<p><strong>Secret Store</strong>: Our secrets such as ssh key, swarm host address etc will be stored in drones secrets manager</p>

<p><strong>Docker Swarm</strong>: Docker Swarm has Traefik as a HTTP Loadbalancer</p>

<p><strong>Drone Server and Agent</strong>: If you dont have drone, you can setup <a href="https://blog.ruanbekker.com/blog/2019/04/18/setup-a-drone-cicd-environment-on-docker-with-letsencrypt/">drone server and agent on docker</a> or have a look at <a href="https://cloud.drone.io">cloud.drone.io</a></p>

<p><strong>Workflow:</strong></p>

<pre><code>* Whenever a push to master is receive on github, the pipeline will be triggered
* The content from our github repository will be cloned to the agent on a container
* Jekyll will build and the output will be transferred to docker swarm using rsync
* The docker-compose.yml will be transferred to the docker swarm host using scp
* A docker stack deploy is ran via ssh
</code></pre>

<h2>Install Jekyll Locally</h2>

<p>Install Jekyll locally, as we will use it to create the initial site. I am using a mac, so I will be using <code>brew</code>. For other operating systems, have a look at <a href="https://jekyllrb.com/docs/installation/">this post</a>.</p>

<p>I will be demonstrating with a weightloss blog as an example.</p>

<p>Install jekyll:</p>

<pre><code>$ brew install jekyll
</code></pre>

<p>Go ahead and create a new site which will host the data for your jekyll site:</p>

<pre><code>$ jekyll new blog-weightloss
</code></pre>

<h2>Create a Github Repository</h2>

<p>First we need to create an empty github repository, in my example it was <code>github.com/ruanbekker/blog-weightloss.git</code>. Once you create the repo change into the directory created by the <code>jekyll new</code> command:</p>

<pre><code>$ cd blog-weightloss
</code></pre>

<p>Now initialize git, set the remote, add the jekyll data and push to github:</p>

<pre><code>$ git init
$ git remote add origin git@github.com:ruanbekker/blog-weightloss.git # &lt;== change to your repository
$ git add .
$ git commit -m "first commit"
$ git push origin master
</code></pre>

<p>You should see your data on your github repository.</p>

<h2>Create Secrets on Drone</h2>

<p>Logon to the Drone UI, sync repositories, activate the new repository and head over to settings where you will find the secrets section.</p>

<p>Add the following secrets:</p>

<pre><code>Secret Name: swarm_host
Secret Value: ip address of your swarm

Secret Name: swarm_key
Secret Value: contents of your private ssh key

Secret Name: swarm_user
Secret Value: the user that is allowed to ssh
</code></pre>

<p>You should see the following:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56619871-5c4fc480-6627-11e9-8820-c9d4ddff698c.png" alt="image" /></p>

<h2>Add the Drone Config</h2>

<p>Drone looks from a <code>.drone.yml</code> file in the root directory for instructions on how to do its tasks. Lets go ahead and declare our pipeline:</p>

<pre><code>$ vim .drone.yml
</code></pre>

<p>And populate the drone config:</p>

<pre><code>pipeline:
  jekyll-build:
    image: jekyll/jekyll:latest
    commands:
      - touch Gemfile.lock
      - chmod a+w Gemfile.lock
      - chown -R jekyll:jekyll /drone
      - gem update --system
      - gem install bundler
      - bundle install
      - bundle exec jekyll build

  transfer-build:
    image: drillster/drone-rsync
    hosts:
      from_secret: swarm_host
    key:
      from_secret: swarm_key
    user:
      from_secret: swarm_user
    source: ./*
    target: ~/my-weightloss-blog.com
    recursive: true
    delete: true
    when:
      branch: [master]
      event: [push]

  transfer-compose:
    image: appleboy/drone-scp
    host:
      from_secret: swarm_host
    username:
      from_secret: swarm_user
    key:
      from_secret: swarm_key
    target: /root/my-weightloss-blog.com
    source:
      - docker-compose.yml
    when:
      branch: [master]
      event: [push]

  deploy-jekyll-to-swarm:
    image: appleboy/drone-ssh
    host:
      from_secret: swarm_host
    username:
      from_secret: swarm_user
    key:
      from_secret: swarm_key
    port: 22
    script:
      - docker stack deploy --prune -c /root/my-weightloss-blog.com/docker-compose.yml apps
    when:
      branch: [master]
      event: [push]
</code></pre>

<h2>Notifications?</h2>

<p>If you want to be notified about your builds, you can add a slack notification step as the last step.</p>

<p>To do that, create a new webhook integration, you can <a href="https://blog.ruanbekker.com/blog/2019/04/18/setup-a-slack-webhook-for-sending-messages-from-applications/">follow this post for a step by step guide</a>. After you have the webhook, go to secrets and create a <code>slack_webhook</code> secret.</p>

<p>Then apply the notification step as shown below:</p>

<pre><code>  notify-via-slack:
    image: plugins/slack
    webhook:
      from_secret: slack_webhook
    channel: system_events
    template: &gt;
      
        [DRONE CI]: ** : /
        ( -  | )

      
        [DRONE CI]: ** : /
        ( -  | )
      
</code></pre>

<p>Based on the status, you should get a notification similar like this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56622206-6e356580-662f-11e9-8d93-286c9c126d24.png" alt="image" /></p>

<h2>Add the Docker Compose</h2>

<p>Next we need to declare our docker compose file which is needed to deploy our jekyll service to the swarm:</p>

<pre><code>$ vim docker-compose.yml
</code></pre>

<p>And populate this info (just change the values for your own environment/settings):</p>

<pre><code class="yaml">version: '3.5'

services:
  myweightlossblog:
    image: ruanbekker/jekyll:contrast
    command: jekyll serve --watch --force_polling --verbose
    networks:
      - appnet
    volumes:
      - /root/my-weightloss-blog.com:/srv/jekyll
    deploy:
      mode: replicated
      replicas: 1
      labels:
        - "traefik.backend.loadbalancer.sticky=false"
        - "traefik.backend.loadbalancer.swarm=true"
        - "traefik.backend=myweightlossblog"
        - "traefik.docker.network=appnet"
        - "traefik.entrypoints=https"
        - "traefik.frontend.passHostHeader=true"
        - "traefik.frontend.rule=Host:www.my-weightloss-blog.com,my-weightloss-blog.com"
        - "traefik.port=4000"
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure
      placement:
        constraints:
          - node.role == manager
networks:
  appnet:
    external: true
</code></pre>

<h2>Push to Github</h2>

<p>Now we need to push our <code>.drone.yml</code> and <code>docker-compose.yml</code> to github. Since the repository is activated on drone, any push to master will trigger the pipeline, so after this push we should go to drone to look at our pipeline running.</p>

<p>Add the untracked files and push to github:</p>

<pre><code>$ git add .drone.yml
$ git add docker-compose.yml
$ git commit -m "add drone and docker config"
$ git push origin master
</code></pre>

<p>As you head over to your drone ui, you should see your pipeline output which will look more or less like this (just look how pretty it is! :D )</p>

<p><img src="https://user-images.githubusercontent.com/567298/56620236-91a8e200-6628-11e9-9278-38e3305fdcd7.png" alt="image" /></p>

<h2>Test Jekyll</h2>

<p>If your deployment has completed you should be able to access your application on the configured domain. A screenshot of my response when accessing Jekyll:</p>

<p><img src="https://user-images.githubusercontent.com/567298/56620280-af764700-6628-11e9-9d4f-c2592e6cf561.png" alt="image" /></p>

<p>Absolutely Amazingness! I really love drone!</p>
]]></content>
  </entry>
  
</feed>
