<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Docker | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2017-09-09T19:02:45-04:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HTTPS Termination Using LetsEncrypt With Traefik on Docker Swarm]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/09/09/https-termination-using-letsencrypt-with-traefik-on-docker-swarm/"/>
    <updated>2017-09-09T18:40:15-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/09/09/https-termination-using-letsencrypt-with-traefik-on-docker-swarm</id>
    <content type="html"><![CDATA[<p>We will setup a HTTPS Termination on Traefik for our Java Web Application using Payara Micro, that will sit behind our Traefik proxy. In this guide, I will be using GitLab&rsquo;s Private Registry for pushing my Images to.</p>

<h2>Traefik Dockerfile:</h2>

<p>Our Traefik Dockerfile:</p>

<pre><code class="docker Traefik Dockerfile">FROM traefik
ADD traefik.toml .
EXPOSE 80
EXPOSE 8080
EXPOSE 443
</code></pre>

<h2>traefik.toml</h2>

<p>Our Traefik config: <code>traefik.toml</code></p>

<pre><code class="toml traefik.toml">defaultEntryPoints = ["http", "https"]

[web]
address = ":8080"

[entryPoints]

[entryPoints.http]
address = ":80"

[entryPoints.https]
address = ":443"

[entryPoints.https.tls]

[acme]
email = "recipient@domain.com"
storage = "acme.json"
entryPoint = "https"
onDemand = false
OnHostRule = true

[docker]
endpoint = "unix:///var/run/docker.sock"
domain = "apps.domain.com"
watch = true
exposedbydefault = false
</code></pre>

<h2>Build the Image:</h2>

<p>Login to GitLab&rsquo;s Registry, build and push the image:</p>

<pre><code class="bash">$ docker login registry.gitlab.com
$ docker build -t registry.gitlab.com/&lt;user&gt;/&lt;repo&gt;/traefik:latest .
$ docker push registry.gitlab.com/&lt;user&gt;/&lt;repo&gt;/traefik:latest
</code></pre>

<h2>Traefik:</h2>

<p>Create the Traefik Proxy Service:</p>

<pre><code class="bash">$ docker service create \
--name traefik \
--constraint 'node.role==manager' \
--publish 80:80 \
--publish 443:443 \
--publish 8080:8080 \
--mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock \
--network appnet \
--with-registry-auth registry.gitlab.com/&lt;user&gt;/&lt;repo&gt;/traefik:latest \
--docker \
--docker.swarmmode \
--docker.domain=apps.domain.com \
--docker.watch \
--logLevel=DEBUG \
--web
</code></pre>

<h2>Java Web Application:</h2>

<p>Our Java Web Applications Dockerfile:</p>

<pre><code class="docker Dockerfile">FROM payara/micro
COPY app.war /opt/payara/deployments/app.war
</code></pre>

<p>Build and Push the Image to our GitLab Registry:</p>

<pre><code class="bash">$ docker build -t registry.gitlab.com/&lt;user&gt;/&lt;repo&gt;/java_web:latest .
$ docker push registry.gitlab.com/&lt;user&gt;/&lt;repo&gt;/java_web:latest
</code></pre>

<p>Create the Java Web Application on Docker Swarm, specifiying our <code>Host</code>, and also a <code>PathPrefix</code>, so that the Traefik Proxy can accept requests for the <code>Hostname</code>, and anything from <code>/app/</code></p>

<pre><code class="bash">$ docker service create \
--name u1t_pop \
--label 'traefik.port=8080' \
--label traefik.frontend.rule="Host:apps.domain.com; PathPrefix: /app/" \
--network appnet \
--with-registry-auth registry.gitlab.com/&lt;user&gt;/&lt;repo&gt;/java_web:latest
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://gist.github.com/nknapp/20c7cd89f1f128b8425dd89cbad0b802">https://gist.github.com/nknapp/20c7cd89f1f128b8425dd89cbad0b802</a></li>
<li><a href="https://niels.nu/blog/2017/traefik-https-letsencrypt.html">https://niels.nu/blog/2017/traefik-https-letsencrypt.html</a></li>
</ul>


<center>
        <script type='text/javascript' src='https://ko-fi.com/widgets/widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Buy Me a Coffee', '#46b798', 'A6423ZIQ');kofiwidget2.draw();</script>
</center>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Run Kibana on Docker Swarm With Traefik]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/09/09/run-kibana-on-docker-swarm-with-traefik/"/>
    <updated>2017-09-09T18:33:12-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/09/09/run-kibana-on-docker-swarm-with-traefik</id>
    <content type="html"><![CDATA[<p>We will create a Kibana Service on Docker Swarm, that will sit behind a Traefik Reverse Proxy.</p>

<h2>Create the Overlay Network:</h2>

<pre><code class="bash">$ docker network create --driver overlay appnet
</code></pre>

<h2>Create the Traefik Service:</h2>

<pre><code class="bash">docker service create \
--name traefik \
--constraint 'node.role==manager' \
--publish 80:80 \
--publish 443:443 \
--publish 8080:8080 \
--mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock \
--network appnet \
traefik:camembert \
--docker --docker.swarmmode  \
--docker.domain=apps.domain.com \
--docker.watch \
--logLevel=DEBUG \
--web
</code></pre>

<h2>Set DNS:</h2>

<p>Set a wildcard <code>*.apps.domain.com</code> to resolve to <code>apps.domain.com</code>, where <code>apps.domain.com</code> resolves to your swarm addresses</p>

<h2>Create Kibana:</h2>

<p>Create a Kibana Service and set the <code>ELASTICSEARCH_URL</code> to your External Elasticsearch Endpoint, take note that it uses port <code>9200</code> by default.</p>

<pre><code class="bash">$ docker service create \
--name kibana \
--label 'traefik.port=5601' \
--network appnet \
--env KIBANA_ELASTICSEARCH_URL=elasticsearch.domain.com \
bitnami/kibana
</code></pre>

<h2>Access Kibana:</h2>

<p>Your Kibana endpoint will be available at: <code>http://kibana.apps.domain.com</code></p>

<h2>Resources:</h2>

<ul>
<li><a href="https://github.com/bitnami/bitnami-docker-kibana">https://github.com/bitnami/bitnami-docker-kibana</a></li>
<li><a href="https://docs.traefik.io/">https://docs.traefik.io/</a></li>
</ul>


<center>
    <script type='text/javascript' src='https://ko-fi.com/widgets/widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Buy Me a Coffee', '#46b798', 'A6423ZIQ');kofiwidget2.draw();</script>
</center>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Run Your Self-Hosted S3 Service With Minio on Docker Swarm]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/09/08/run-your-self-hosted-s3-service-with-minio-on-docker-swarm/"/>
    <updated>2017-09-08T15:29:29-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/09/08/run-your-self-hosted-s3-service-with-minio-on-docker-swarm</id>
    <content type="html"><![CDATA[<p>Minio is a distributed object storage server built for cloud applications, which is similar to Amazon&rsquo;s S3 Service.</p>

<p>Today, we will create the server on docker swarm, as I don&rsquo;t currently have a external data store like GlusterFS / NFS etc, I will host the data on the manager node, and set a constraint for the service so that the service can only run on the manager node.</p>

<h2>Prepare the Data Directory:</h2>

<p>I will only rely on the manager node for my data, so on my manager node:</p>

<pre><code>$ mkdir -p /mnt/data
</code></pre>

<h2>Create the Service:</h2>

<p>If you have a Replicated Gluster Volume or NFS which is mounted throughout your docker swarm, you can create the directory path for it, and the update your <code>--mount</code> source path to your external data store. In my case, I will just point it to my manager node&rsquo;s <code>/mnt/data</code> path as I have setup the service to only run on the one manager node in my swarm:</p>

<pre><code>$ docker service create \
--name minio \
--network appnet \
--replicas 1 \
--publish 9000:9000 \
--constraint 'node.role==manager' \
-e "MINIO_ACCESS_KEY=AKIAASDKJASDL" \
-e "MINIO_SECRET_KEY=AKIAASDKJASDL" \
--mount "type=bind,source=/mnt/data,target=/data" \
minio/minio server /data
</code></pre>

<h2>Install the AWS CLI Tools:</h2>

<p>We will use the awscli tools to interact with our Minio Server:</p>

<pre><code>$ pip install awscli
</code></pre>

<h2>Configure the Client:</h2>

<p>Configure the awscli client with the access details that we passed in our docker service:</p>

<pre><code>$ aws configure --profile minio
AWS Access Key ID []: AKIAASDKJASDL
AWS Secret Access Key []: ASLDKJASDLKJASDLKJ
Default region name []: us-west-1
Default output format []: json
</code></pre>

<h2>Create the Bucket:</h2>

<p>Create a New Bucket, in this case <code>news3bucket</code></p>

<pre><code>aws --profile minio --endpoint-url http://MINIO-IP:9000 s3 mb s3://news3bucket
make_bucket: news3bucket
</code></pre>

<h2>List Buckets:</h2>

<p>List our endpoint, to see the buckets on our server:</p>

<pre><code>$ aws --profile minio --endpoint-url http://MINIO-IP:9000 s3 ls /
2017-09-08 15:01:40 news3bucket
</code></pre>

<h2>Upload an Object to your Bucket:</h2>

<p>We will upload an image <code>awsddb-1.png</code> to our new bucket:</p>

<pre><code>$ aws --profile minio --endpoint-url http://MINIO-IP:9000 s3 cp awsddb-1.png s3://news3bucket/
upload: ./awsddb-1.png to s3://news3bucket/awsddb-1.png
</code></pre>

<h2>List Bucket:</h2>

<p>List your bucket, to see the uploaded object:</p>

<pre><code>$ aws --profile minio --endpoint-url http://MINIO-IP:9000 s3 ls s3://news3bucket
2017-09-08 15:03:11      19851 awsddb-1.png
</code></pre>

<h2>Download Object:</h2>

<p>Download the image from your Bucket, and set the local file to <code>file.png</code>:</p>

<pre><code>$ aws --profile minio --endpoint-url http://MINIO-IP:9000 s3 cp s3://news3bucket/awsddb-1.png file.png
download: s3://news3bucket/awsddb-1.png to ./file.png
</code></pre>

<h2>Web Access:</h2>

<p>You can also access Minio&rsquo;s Web Interface on the port that you have exposed, in my case: <code>http://MINIO-IP:9000/minio/</code></p>

<h2>Resources:</h2>

<ul>
<li><a href="https://www.minio.io/">https://www.minio.io/</a></li>
<li><a href="https://docs.minio.io/docs/minio-docker-quickstart-guide">https://docs.minio.io/docs/minio-docker-quickstart-guide</a></li>
<li><a href="https://github.com/minio/minio/blob/master/README.md">https://github.com/minio/minio/blob/master/README.md</a></li>
<li><a href="https://github.com/arschles/minio-howto/blob/master/aws-cli-with-minio-server.md">https://github.com/arschles/minio-howto/blob/master/aws-cli-with-minio-server.md</a></li>
</ul>


<center>
    <script type='text/javascript' src='https://ko-fi.com/widgets/widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Buy Me a Coffee', '#46b798', 'A6423ZIQ');kofiwidget2.draw();</script> 
</center>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Create a Local Docker Swarm Cluster With Docker in Docker on Your Workstation]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/09/07/how-to-create-a-local-docker-swarm-cluster-with-docker-in-docker-on-your-workstation/"/>
    <updated>2017-09-07T04:03:37-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/09/07/how-to-create-a-local-docker-swarm-cluster-with-docker-in-docker-on-your-workstation</id>
    <content type="html"><![CDATA[<p>Creating a Docker Swarm Cluster, locally on your Workstation using Docker in Docker (DID) for testing Purposes:</p>

<h2>Project Resources:</h2>

<ul>
<li><a href="https://hub.docker.com/_/docker/">Docker in Docker</a></li>
<li><a href="https://docs.traefik.io/">Traefik</a></li>
</ul>


<h2>Create The Nodes:</h2>

<p>Create the Docker containers that will act as our Docker nodes:</p>

<pre><code class="bash">$ docker run --privileged --name docker-node1 -v /Users/ruan/docker/did/vols/node1:/var/lib/docker -d docker:dind --storage-driver=vfs
$ docker run --privileged --name docker-node2 -v /Users/ruan/docker/did/vols/node2:/var/lib/docker -d docker:dind --storage-driver=vfs
$ docker run --privileged --name docker-node3 -v /Users/ruan/docker/did/vols/node3:/var/lib/docker -d docker:dind --storage-driver=vfs
</code></pre>

<h2>Initialize the Swarm:</h2>

<p>Log onto the manager node:</p>

<pre><code class="bash">$ docker exec -it docker-node1 sh
</code></pre>

<p>Initialize the Swarm:</p>

<pre><code class="bash">$ docker swarm init --advertise-addr eth0
Swarm initialized: current node (17ydtkqdwxzwea2riadxj4zbw) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-4goolm8dvwictc7d39aonpcv6ca1pfj31q7irjga17o2srzf6f-b4k3hln6ogvjgmnbs1qxnjvj9 172.17.0.2:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
</code></pre>

<p>Join the Worker Nodes to the Swarm:</p>

<pre><code class="bash">$ docker exec -it docker-node2 sh
/ # docker swarm join --token SWMTKN-1-4mvb68vefr3dogxr6omu3uq04r4gddftdbmfomxo9pefks9siu-3t7ua7k2xigl9rwgp4dwzcxm0 172.17.0.2:2377
This node joined a swarm as a worker.
</code></pre>

<pre><code class="bash">$ docker exec -it docker-node3 sh
/ # docker swarm join --token SWMTKN-1-4mvb68vefr3dogxr6omu3uq04r4gddftdbmfomxo9pefks9siu-3t7ua7k2xigl9rwgp4dwzcxm0 172.17.0.2:2377
This node joined a swarm as a worker.
</code></pre>

<h2>List the Nodes:</h2>

<p>Log onto the Manager node and list the nodes:</p>

<pre><code class="bash">$ docker exec -it docker-node1 sh
/ # docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS
1hnq4b4w87w6trobwye5ap4sh *   5657c28bf618        Ready               Active              Leader
wglbb029g1kczttiaf5r6iavi     b2924bb8e555        Ready               Active
xxr9kdqy49u2tx61w31ife90j     6622a06a1b3c        Ready               Active
</code></pre>

<h2>Traefik:</h2>

<p>Creating a HTTP Reverse Proxy, using Traefik:</p>

<pre><code class="bash">$ docker network create --driver overlay traefik-net
$ docker service create \
--name traefik \
--constraint 'node.role==manager' \
--publish 80:80 \
--publish 8080:8080 \
--mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock \
--network traefik-net \
traefik:camembert --docker --docker.swarmmode --docker.domain=ruanbekker.internal --docker.watch --logLevel=DEBUG --web
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Alpine Nginx PHP-Fpm Image on Docker for PHP Applications]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/08/26/building-a-alpine-nginx-php-fpm-image-on-docker-for-php-applications/"/>
    <updated>2017-08-26T20:41:16-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/08/26/building-a-alpine-nginx-php-fpm-image-on-docker-for-php-applications</id>
    <content type="html"><![CDATA[<p>A Post on Building a Alpine Based Image that will serve PHP Pages, using Nginx and PHP-FPM5.</p>

<p>I have a lot of modules enabled, which might not be neccesary, but in my case I wanted to have a couple of them enabled, for testing.</p>

<h2>One of the Requirements:</h2>

<p>One of the requirements was that I needed SMTP support from the container as I am using <a href="https://startbootstrap.com/template-overviews/freelancer/">Startbootstrap Freelancer Theme</a>, which I configured to relay mail from the contact from to one of my external relay hosts.</p>

<h2>Our Directory Structure:</h2>

<p>Our data that we will be working with will consist of our <code>Dockerfile</code>, our <code>website files</code>, <code>nginx config</code>, and a <code>wrapper script</code> that will control nginx and php-fpm5 processes:</p>

<pre><code class="bash Directory Structure">.
|-- Dockerfile
|-- README.md
|-- html
|   |-- css
|   |-- fonts
|   |-- img
|   |-- index.html
|   |-- js
|   `-- mail
|       `-- contact.php
|-- nginx.conf
|-- start_nginx.sh
|-- start_php-fpm5.sh
`-- wrapper.sh
</code></pre>

<h2>Going into Some Detail:</h2>

<p>First, our <code>Dockerfile</code>, which you will see I started the image from Apline:</p>

<pre><code class="docker Dockerfile">FROM alpine:edge

RUN apk update \
    &amp;&amp; apk add nginx \
    &amp;&amp; adduser -D -u 1000 -g 'www' www \
    &amp;&amp; mkdir /www \
    &amp;&amp; chown -R www:www /var/lib/nginx \
    &amp;&amp; chown -R www:www /www \
    &amp;&amp; rm -rf /etc/nginx/nginx.conf

ENV PHP_FPM_USER="www"
ENV PHP_FPM_GROUP="www"
ENV PHP_FPM_LISTEN_MODE="0660"
ENV PHP_MEMORY_LIMIT="512M"
ENV PHP_MAX_UPLOAD="50M"
ENV PHP_MAX_FILE_UPLOAD="200"
ENV PHP_MAX_POST="100M"
ENV PHP_DISPLAY_ERRORS="On"
ENV PHP_DISPLAY_STARTUP_ERRORS="On"
ENV PHP_ERROR_REPORTING="E_COMPILE_ERROR\|E_RECOVERABLE_ERROR\|E_ERROR\|E_CORE_ERROR"
ENV PHP_CGI_FIX_PATHINFO=0
ENV TIMEZONE="Africa/Johannesburg"

RUN apk add curl \
    ssmtp \
    tzdata \
    php5-fpm \
    php5-mcrypt \
    php5-soap \
    php5-openssl \
    php5-gmp \
    php5-pdo_odbc \
    php5-json \
    php5-dom \
    php5-pdo \
    php5-zip \
    php5-mysql \
    php5-mysqli \
    php5-sqlite3 \
    php5-pdo_pgsql \
    php5-bcmath \
    php5-gd \
    php5-odbc \
    php5-pdo_mysql \
    php5-pdo_sqlite \
    php5-gettext \
    php5-xmlreader \
    php5-xmlrpc \
    php5-bz2 \
    php5-iconv \
    php5-pdo_dblib \
    php5-curl \
    php5-ctype

RUN sed -i "s|;listen.owner\s*=\s*nobody|listen.owner = ${PHP_FPM_USER}|g" /etc/php5/php-fpm.conf \
    &amp;&amp; sed -i "s|;listen.group\s*=\s*nobody|listen.group = ${PHP_FPM_GROUP}|g" /etc/php5/php-fpm.conf \
    &amp;&amp; sed -i "s|;listen.mode\s*=\s*0660|listen.mode = ${PHP_FPM_LISTEN_MODE}|g" /etc/php5/php-fpm.conf \
    &amp;&amp; sed -i "s|user\s*=\s*nobody|user = ${PHP_FPM_USER}|g" /etc/php5/php-fpm.conf \
    &amp;&amp; sed -i "s|group\s*=\s*nobody|group = ${PHP_FPM_GROUP}|g" /etc/php5/php-fpm.conf \
    &amp;&amp; sed -i "s|;log_level\s*=\s*notice|log_level = notice|g" /etc/php5/php-fpm.conf \
    &amp;&amp; sed -i 's/include\ \=\ \/etc\/php5\/fpm.d\/\*.conf/\;include\ \=\ \/etc\/php5\/fpm.d\/\*.conf/g' /etc/php5/php-fpm.conf

RUN sed -i "s|display_errors\s*=\s*Off|display_errors = ${PHP_DISPLAY_ERRORS}|i" /etc/php5/php.ini \
    &amp;&amp; sed -i "s|display_startup_errors\s*=\s*Off|display_startup_errors = ${PHP_DISPLAY_STARTUP_ERRORS}|i" /etc/php5/php.ini \
    &amp;&amp; sed -i "s|error_reporting\s*=\s*E_ALL &amp; ~E_DEPRECATED &amp; ~E_STRICT|error_reporting = ${PHP_ERROR_REPORTING}|i" /etc/php5/php.ini \
    &amp;&amp; sed -i "s|;*memory_limit =.*|memory_limit = ${PHP_MEMORY_LIMIT}|i" /etc/php5/php.ini \
    &amp;&amp; sed -i "s|;*upload_max_filesize =.*|upload_max_filesize = ${PHP_MAX_UPLOAD}|i" /etc/php5/php.ini \
    &amp;&amp; sed -i "s|;*max_file_uploads =.*|max_file_uploads = ${PHP_MAX_FILE_UPLOAD}|i" /etc/php5/php.ini \
    &amp;&amp; sed -i "s|;*post_max_size =.*|post_max_size = ${PHP_MAX_POST}|i" /etc/php5/php.ini \
    &amp;&amp; sed -i "s|;*cgi.fix_pathinfo=.*|cgi.fix_pathinfo= ${PHP_CGI_FIX_PATHINFO}|i" /etc/php5/php.ini
    &amp;&amp; sed -i 's/smtp_port\ =\ 25/smtp_port\ =\ 81/g' /etc/php5/php.ini \
    &amp;&amp; sed -i 's/SMTP\ =\ localhost/SMTP\ =\ mail.bekkersolutions.com/g' /etc/php5/php.ini \
    &amp;&amp; sed -i 's/;sendmail_path\ =/sendmail_path\ =\ \/usr\/sbin\/sendmail\ -t/g' /etc/php5/php.ini 

RUN rm -rf /etc/localtime \
    &amp;&amp; ln -s /usr/share/zoneinfo/${TIMEZONE} /etc/localtime \
    &amp;&amp; echo "${TIMEZONE}" &gt; /etc/timezone \
    &amp;&amp; sed -i "s|;*date.timezone =.*|date.timezone = ${TIMEZONE}|i" /etc/php5/php.ini \ 
    &amp;&amp; echo 'sendmail_path = "/usr/sbin/ssmtp -t "' &gt; /etc/php5/conf.d/mail.ini \
    &amp;&amp; sed -i 's/mailhub=mail/mailhub=mail.domain.com\:81/g' /etc/ssmtp/ssmtp.conf 

COPY nginx.conf /etc/nginx/nginx.conf
COPY index.php /www/index.php
COPY test.html /www/test.html
COPY start_nginx.sh /start_nginx.sh
COPY start_php-fpm5.sh /start_php-fpm5.sh
COPY wrapper.sh /wrapper.sh

RUN chmod +x /start_nginx.sh /start_php-fpm5.sh /wrapper.sh

CMD ["/wrapper.sh"]
</code></pre>

<p>Next, our <code>nginx.conf</code> configuration file:</p>

<pre><code class="nginx nginx.conf">user                            www;
worker_processes                1;

error_log                       /var/log/nginx/error.log warn;
pid                             /var/run/nginx.pid;

events {
    worker_connections          1024;
}

http {
    include                     /etc/nginx/mime.types;
    default_type                application/octet-stream;
    sendfile                    on;
    access_log                  /var/log/nginx/access.log;
    keepalive_timeout           3000;

    server {
        listen                  80;
        root                    /www;
        index                   index.html index.htm index.php;
        server_name             _;
        client_max_body_size    32m;
        error_page              500 502 503 504  /50x.html;

        location = /50x.html {
              root              /var/lib/nginx/html;
        }

        location ~ \.php$ {
              fastcgi_pass      127.0.0.1:9000;
              fastcgi_index     index.php;
              include           fastcgi.conf;
        }
    }
}
</code></pre>

<p>Then our directory, <code>html</code>  that will consist our websites data, for a simple example, I will create a sample <code>index.php</code> page which can be used:</p>

<pre><code class="php html/index.php">&lt;?php
$word = "foo";
echo "The word is: $word\n";
?&gt;
</code></pre>

<p>Then, following our <code>wrapper.sh</code> script that will start our <code>php-fpm5</code>, and <code>nginx</code> processes, and then monitor these processes, if one of the processes have to exit, the wrapper script will return a exit code, which will result the container to exit, if there is anything wrong with the service:</p>

<p>The PHP-FPM script:</p>

<pre><code class="bash start_php-fpm5.sh">#!/bin/sh
/usr/bin/php-fpm5
</code></pre>

<p>The Nginx Script:</p>

<pre><code class="bash start_nginx.sh">#!/bin/sh
/usr/sbin/nginx -c /etc/nginx/nginx.conf
</code></pre>

<p>The Wrapper Script:</p>

<pre><code class="bash wrapper.sh">#!/bin/sh

/start_php-fpm5.sh -D
status=$?
if [ $status -ne 0 ]; then
  echo "php-fpm5 Failed: $status"
  exit $status
  else echo "Starting PHP-FPM: OK"
fi

sleep 2

/start_nginx.sh -D
status=$?
if [ $status -ne 0 ]; then
  echo "Nginx Failed: $status"
  exit $status
  else echo "Starting Nginx: OK"
fi

sleep 2

while /bin/true; do
  ps aux | grep 'php-fpm: master process' | grep -q -v grep
  PHP_FPM_STATUS=$?
  echo "Checking PHP-FPM, Status Code: $PHP_FPM_STATUS"
  sleep 2

  ps aux | grep 'nginx: master process' | grep -q -v grep
  NGINX_STATUS=$?
  echo "Checking NGINX, Status Code: $NGINX_STATUS"
  sleep 2

  if [ $PHP_FPM_STATUS -ne 0 ];
    then
      echo "$(date +%F_%T) FATAL: PHP-FPM Raised a Status Code of $PHP_FPM_STATUS and exited"
      exit -1

   elif [ $NGINX_STATUS -ne 0 ];
     then
       echo "$(date +%F_%T) FATAL: NGINX Raised a Status Code of $NGINX_STATUS and exited"
       exit -1

   else
     sleep 2
        echo "$(date +%F_%T) - HealtCheck: NGINX and PHP-FPM: OK"
  fi
  sleep 60
done
</code></pre>

<h2>Building the Image:</h2>

<p>I am primarily using docker swarm, so I am building the image, and pushing to a private registry:</p>

<pre><code class="bash Build and Push the Image">$ docker build -t registry.gitlab.com/&lt;user&gt;/&lt;repo&gt;/alpine:php5 .
$ docker push registry.gitlab.com/&lt;user&gt;/&lt;repo&gt;/alpine:php5
</code></pre>

<p>Create the PHP Service:</p>

<pre><code class="bash Create a Docker Service">$ docker service create \
--name php-app \
--network appnet \
--replicas 3 \
--with-registry-auth registry.gitlab.com/&lt;user&gt;/&lt;repo&gt;/alpine:php5
</code></pre>

<p>For a Container from the Image on the Host:</p>

<pre><code class="bash Run a Container from the Image">$ docker run -itd --name php-app -p 80:80 registry.gitlab.com/&lt;user&gt;/&lt;repo&gt;/alpine:php5
</code></pre>

<p>Test the Web App:</p>

<pre><code class="bash Make a GET Request">$ curl -XGET http://127.0.0.1:80/
The word is: foo
</code></pre>
]]></content>
  </entry>
  
</feed>
