<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dynamodb | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/dynamodb/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2019-09-15T13:08:23+02:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using OpenFaas With Amazon DynamoDB]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/07/07/using-openfaas-with-amazon-dynamodb/"/>
    <updated>2019-07-07T01:11:23+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/07/07/using-openfaas-with-amazon-dynamodb</id>
    <content type="html"><![CDATA[<p><img width="1105" alt="image" src="https://user-images.githubusercontent.com/567298/60761941-f4205480-a053-11e9-9ad5-9e45948c9833.png"></p>

<p><a href="https://saythanks.io/to/ruanbekker"><img src="https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg" alt="Say Thanks!" /></a> <a href="https://linux-hackers-slack.herokuapp.com/"><img src="https://linux-hackers-slack.herokuapp.com/badge.svg" alt="Slack Status" /></a> <a href="https://linux-hackers.slack.com/"><img src="https://img.shields.io/badge/chat-on_slack-orange.svg" alt="Chat on Slack" /></a> <img src="https://img.shields.io/github/followers/ruanbekker.svg?label=Follow&amp;style=social" alt="GitHub followers" /> <img src="https://img.shields.io/twitter/follow/ruanbekker.svg?style=social" alt="Twitter Follow" /></p>

<h1>Using OpenFaaS with Amazon DynamoDB</h1>

<p>You can use your OpenFaaS functions to store and retrieve data to and from a persistent layer that sits outside the OpenFaaS framework. The database that we will use in this tutorial is Amazon&rsquo;s DynamoDB.</p>

<p>If you are not familiar with the service, Amazon&rsquo;s DynamoDB is a fully managed NoSQL database service that provides fast and predictable performance with seamless scalability.</p>

<p>At the end of this tutorial you will be able to invoke your functions to read and write items to DynamoDB with a dedicated IAM User that is only allowed to access DynamoDB, and secrets managed by your OpenFaaS framework.</p>

<h2>What we will be doing in this Tutorial</h2>

<p>In this tutorial we will cover a couple of things, and a summary on the to do list is:</p>

<ul>
<li>Create a OpenFaaS IAM User, DynamoDB IAM Policy, associate the Policy to the User using the AWS CLI</li>
<li>Create a AWS Access Key, and save the Access Key and Secret key to file</li>
<li>Create OpenFaaS Secrets of the Access Key and Secret Key, remove the files from disk</li>
<li>Create 3 OpenFaaS Functions: write, lookup and get</li>
<li>Invoke the functions, read and write from DynamoDB</li>
</ul>


<p>Our 3 functions will do very basic operations for this demonstration, but I believe this is a good starting point.</p>

<p>All the examples of this blog post is available in <a href="https://github.com/ruanbekker/blog-assets/tree/master/openfaas-dynamodb">this github repository</a></p>

<h2>The Use-Case Scenario</h2>

<p>In this scenario we want to store user information into DynamoDB, we will use a hash that we will calculate using the users ID Number + Lastname. So when we have thousands or millions of items, we dont need to search through the entire table, but since we can re-calculate the sha hash, we can do a single GetItem operation to find the entry about the user in question.</p>

<ul>
<li>Lookup Function:</li>
</ul>


<p>The lookup function will calculate the hash by passing the users ID Number and Lastname, this will return a hash which will be teh primary key attribute of our table design. This hash value is required to do a GetItem on the user in question.</p>

<ul>
<li>Get Function:</li>
</ul>


<p>The Get function will interface with DynamoDB, it reads the AWS access key and secret key from the secrets path to authenticate with AWS and utilizes environment variables for the region and table name. This will do a GetItem on the DynamoDB Table and retrieve the Item. If the item is not found, it will return it in the response.</p>

<ul>
<li>Write Function:</li>
</ul>


<p>The write function will also interface with DynamoDB, the ID, Name and Payload will be included in the request body on our POST Request.</p>

<h2>Note on Secrets and Environment Variables</h2>

<p>I am treating my environment variables and secrets different from each other. The secrets such as my AWS access keys are stored on the cluster and the application reads them and stores the values in memory.</p>

<p>The environment variables such as non-secret information, such as my dynamodb table name and aws region, is defined in my environment variables.</p>

<p>This <a href="http://movingfast.io/articles/environment-variables-considered-harmful/">post</a> and this <a href="https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/">post</a> goes a bit more into detail on why you should not use environment variables for secret data, which I found from <a href="https://github.com/openfaas/faas-netes/issues/153#issuecomment-370924478">this link</a></p>

<p>Enough info, let&rsquo;s get to the fun stuff</p>

<h2>Pre-Requirements:</h2>

<p>You need a AWS Account (or you can use dynamodb-local), OpenFaaS and faas-cli. Documentation available below:
- <a href="https://docs.openfaas.com/contributing/get-started/">https://docs.openfaas.com/contributing/get-started/</a></p>

<h2>Provision a DynamoDB Table</h2>

<p>I have a admin IAM account configured on my default profile, using the aws-cli tools generate the cli-skeleton that is required to provision a dynamodb table:</p>

<pre><code class="bash">$ aws dynamodb create-table --generate-cli-skeleton &gt; ddb.json
</code></pre>

<p>My table name will be <code>lookup-table</code> with the primary key <code>hash_value</code> and provisoned my throughput to 1 Read and Write Capacity Unit. Which will enable us 4KB/s for reads and 1KB/s for writes.</p>

<p>For demonstration purposes, I am sharing my altered <code>ddb.json</code> file:</p>

<pre><code class="json">{
    "AttributeDefinitions": [
        {
            "AttributeName": "hash_value",
            "AttributeType": "S"
        }
    ],
    "TableName": "lookup_table",
    "KeySchema": [
        {
            "AttributeName": "hash_value",
            "KeyType": "HASH"
        }
    ],
    "ProvisionedThroughput": {
        "ReadCapacityUnits": 1,
        "WriteCapacityUnits": 1
    },
    "Tags": [
        {
            "Key": "Name",
            "Value": "lookup-table"
        }
    ]
}
</code></pre>

<p>Now that we have the file saved, create the dynamodb table:</p>

<pre><code class="bash">$ aws dynamodb create-table --cli-input-json file://ddb.json
</code></pre>

<p>List the tables:</p>

<pre><code class="bash">$ aws dynamodb list-tables
{
    "TableNames": [
        "lookup_table"
    ]
}
</code></pre>

<p>Check if the table is provisioned:</p>

<pre><code class="bash">$ aws dynamodb describe-table --table-name lookup_table | jq -r '.Table.TableStatus'
ACTIVE
</code></pre>

<p>Getting the ARN string, as we will need it when we create our IAM Policy:</p>

<pre><code class="bash">$ aws dynamodb describe-table --table-name lookup_table | jq -r '.Table.TableArn'
arn:aws:dynamodb:eu-west-1:x-x:table/lookup_table
</code></pre>

<h2>Create the OpenFaaS IAM User</h2>

<p>Create the IAM Policy document which defines the access that we want to grant. You can see that we are only allowing Put and GetItem on the provisioned DynamoDB resource:</p>

<pre><code class="bash">$ cat dynamodb-iam-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "OpenFaasFunctionAceessForDynamoDB",
            "Effect": "Allow",
            "Action": [
                "dynamodb:PutItem",
                "dynamodb:GetItem"
            ],
            "Resource": "arn:aws:dynamodb:eu-west-1:x-accountid-x:table/lookup_table"
        }
    ]
}
</code></pre>

<p>Create the IAM Policy and provide the policy document for the given policy name:</p>

<pre><code class="bash">$ aws iam create-policy --policy-name openfaas-dynamodb-access --policy-document file://dynamodb-iam-policy.json
{
    "Policy": {
        "PolicyName": "openfaas-dynamodb-access",
        "PolicyId": "ANPATPRT2G4SL4K63SUWQ",
        "Arn": "arn:aws:iam::x-accountid-x:policy/openfaas-dynamodb-access",
        "Path": "/",
        "DefaultVersionId": "v1",
        "AttachmentCount": 0,
        "PermissionsBoundaryUsageCount": 0,
        "IsAttachable": true,
        "CreateDate": "2019-07-06T11:54:26Z",
        "UpdateDate": "2019-07-06T11:54:26Z"
    }
}
</code></pre>

<p>Create the IAM User that will be used to authenticate requests against DynamoDB:</p>

<pre><code class="bash">$ aws iam create-user --user-name openfaas-user
{
    "User": {
        "Path": "/",
        "UserName": "openfaas-user",
        "UserId": "AIDATPRT2G4SIRYTNHLZK",
        "Arn": "arn:aws:iam::x-accountid-x:user/openfaas-user",
        "CreateDate": "2019-07-06T11:56:53Z"
    }
}
</code></pre>

<p>Create the Access Key, which will be our API keys for our application to authenticate requests. Save the AccessKeyId and SecretAccessKey temporarily to 2 seperate files, which we will delete after we create our secrets to our cluster:</p>

<pre><code class="bash">$ aws iam create-access-key --user-name openfaas-user
{
    "AccessKey": {
        "UserName": "openfaas-user",
        "AccessKeyId": "AKIAT..redacted.x",
        "Status": "Active",
        "SecretAccessKey": "b..redacted.x",
        "CreateDate": "2019-07-06T11:57:37Z"
    }
}
</code></pre>

<p>Associate the IAM Policy to the IAM User:</p>

<pre><code class="bash">$ aws iam attach-user-policy --user-name openfaas-user --policy-arn arn:aws:iam::x-x:policy/openfaas-dynamodb-access
</code></pre>

<p>To test if the access keys work, save them to a new profile using the aws-cli tools:</p>

<pre><code class="bash">$ aws configure --profile openfaas
AWS Access Key ID [None]: AKIAT..
AWS Secret Access Key [None]: b..x
Default region name [None]: eu-west-1
Default output format [None]: json
</code></pre>

<p>Write an Item to DynamoDB:</p>

<pre><code class="bash">$ aws --profile openfaas dynamodb put-item \
--table-name lookup_table \
--item '{"hash_value": {"S": "aGVsbG8td29ybGQK"}, "message": {"S": "hello-world"}}'
</code></pre>

<p>Read the Item from DynamoDB:</p>

<pre><code class="bash">$ aws --profile openfaas dynamodb get-item \
--table-name lookup_table \
--key '{"hash_value": {"S": "aGVsbG8td29ybGQK"}}'
{
    "Item": {
        "hash_value": {
            "S": "aGVsbG8td29ybGQK"
        },
        "message": {
            "S": "hello-world"
        }
    }
}
</code></pre>

<p>We can now confirm our permissions are in place to continue.</p>

<h3>Create OpenFaaS Secrets</h3>

<p>The AccessKeyId and SecretKey has been saved to disk, and we will use those files to create secrets from:</p>

<pre><code class="bash">$ faas-cli secret create openfaas-aws-access-key --from-file=openfaas_aws_access_key.txt
Creating secret: openfaas-aws-access-key
Created: 201 Created
</code></pre>

<pre><code class="bash">$ faas-cli secret create openfaas-aws-secret-key --from-file=openfaas_aws_secret_key.txt
Creating secret: openfaas-aws-secret-key
Created: 201 Created
</code></pre>

<p>Now that the secrets are securely stored in our cluster, we can delete the temporary files:</p>

<pre><code>$ rm -f ./openfaas_aws_*_key.txt
</code></pre>

<h2>Login to OpenFaaS</h2>

<p>Login to OpenFaasS using faas-cli:</p>

<pre><code class="bash">$ faas-cli login \
--gateway https://openfaas.domain.com \
--username ${OPENFAAS_USER} \
--password ${OPENFAAS_PASSWORD}
</code></pre>

<p>Export the OPENFAAS_URL:</p>

<pre><code class="bash">$ export OPENFAAS_URL=https://openfaas.domain.com
</code></pre>

<h2>One Stack File for All 3 Functions:</h2>

<p>We will create our first function to generate the yaml definition, then we will rename our generated filename to <code>stack.yml</code> then the next 2 functions, we will use the append flag to append the functions yaml to our <code>stack.yml</code> file, so that we can simply use <code>faas-cli up</code></p>

<h2>Create the Lookup Function:</h2>

<p>Create a Python3 Function, and prefix it with your dockerhub user:</p>

<pre><code class="bash">$ faas-cli new \
--lang python3 fn-dynamodb-lookup \
--prefix=ruanbekker \
--gateway https://openfaas.domain.com

Function created in folder: fn-foo
Stack file written: fn-dynamodb-lookup.yml
</code></pre>

<p>As we will be using one stack file, rename the generated stack file:</p>

<pre><code class="bash">$ mv fn-dynamodb-lookup.yml stack.yml
</code></pre>

<p>Open the stack file and set the environment variables:</p>

<pre><code class="bash">$ cat stack.yml
provider:
  name: openfaas
  gateway: https://openfaas.domain.com
functions:
  fn-dynamodb-lookup:
    lang: python3
    handler: ./fn-dynamodb-lookup
    image: ruanbekker/fn-dynamodb-lookup:latest
    environment:
      dynamodb_region: eu-west-1
      dynamodb_table: lookup_table
</code></pre>

<p>The python code for our function:</p>

<pre><code class="bash">$ cat fn-dynamodb-lookup/handler.py
</code></pre>

<pre><code class="python">import json
import hashlib

def calc_sha(id_number, lastname):
    string = json.dumps({"id": id_number, "lastname": lastname}, sort_keys=True)
    hash_value = hashlib.sha1(string.encode("utf-8")).hexdigest()
    return hash_value

def handle(req):
    event = json.loads(req)
    hash_value = calc_sha(event['id'], event['lastname'])
    return hash_value
</code></pre>

<h2>Create the Write Function:</h2>

<p>Create a Python3 Function, and prefix it with your dockerhub user, and use the append flag to update our stack file:</p>

<pre><code class="bash">$ faas-cli new \
--lang python3 fn-dynamodb-write \
--prefix=ruanbekker \
--gateway https://openfaas.domain.com
--append stack.yml

Function created in folder: fn-dynamodb-write
Stack file updated: stack.yml
</code></pre>

<p>Open the stack file and set the environment variables and include the secrets that was created:</p>

<pre><code class="bash">$ cat stack.yml
provider:
  name: openfaas
  gateway: https://openfaas.domain.com
functions:
  fn-dynamodb-lookup:
  # ...
  fn-dynamodb-write:
    lang: python3
    handler: ./fn-dynamodb-write
    image: ruanbekker/fn-dynamodb-write:latest
    environment:
      dynamodb_region: eu-west-1
      dynamodb_table: lookup_table
    secrets:
      - openfaas-aws-access-key
      - openfaas-aws-secret-key
</code></pre>

<p>Our function relies on a external dependency which we need to install to interact with aws:</p>

<pre><code class="bash">$ cat fn-dynamodb-write/requirements.txt
boto3
</code></pre>

<p>Our python code for our function:</p>

<pre><code class="bash">$ cat fn-dynamodb-write/handler.py
</code></pre>

<pre><code class="python">import boto3
import os
import json
import hashlib
import datetime

aws_key = open('/var/openfaas/secrets/openfaas-aws-access-key', 'r').read()
aws_secret = open('/var/openfaas/secrets/openfaas-aws-secret-key', 'r').read()
dynamodb_region = os.environ['dynamodb_region']
dynamodb_table  = os.environ['dynamodb_table']

client = boto3.Session(region_name=dynamodb_region).resource('dynamodb', aws_access_key_id=aws_key, aws_secret_access_key=aws_secret)
table = client.Table(dynamodb_table)

def calc_sha(id_number, lastname):
    string = json.dumps({"id": id_number, "lastname": lastname}, sort_keys=True)
    hash_value = hashlib.sha1(string.encode("utf-8")).hexdigest()
    return hash_value

def create_timestamp():
    response = datetime.datetime.now().strftime("%Y-%m-%dT%H:%M")
    return response

def handle(req):
    event = json.loads(req)
    unique_id = calc_sha(event['id'], event['lastname'])
    response = table.put_item(
        Item={
            'hash_value': unique_id,
            'timestamp': create_timestamp(),
            'payload': event['payload']
        }
    )
    return response
</code></pre>

<h2>Create the Get Function:</h2>

<p>Create a Python3 Function, and prefix it with your dockerhub user, and use the append flag to specify the stack file:</p>

<pre><code class="bash">$ faas-cli new \
--lang python3 fn-dynamodb-get \
--prefix=ruanbekker \
--gateway https://openfaas.domain.com
--append stack.yml

Function created in folder: fn-dynamodb-get
Stack file updated: stack.yml
</code></pre>

<p>Open the stack file and set the environment variables and include the secrets that was created:</p>

<pre><code class="bash">$ cat stack.yml
provider:
  name: openfaas
  gateway: https://openfaas.domain.com
functions:
  fn-dynamodb-lookup:
  # .. 
  fn-dynamodb-write:
  # ..
  fn-dynamodb-get:
    lang: python3
    handler: ./fn-dynamodb-get
    image: ruanbekker/fn-dynamodb-get:latest
    environment:
      dynamodb_region: eu-west-1
      dynamodb_table: lookup_table
    secrets:
      - openfaas-aws-access-key
      - openfaas-aws-secret-key
</code></pre>

<p>Include the external dependency for aws:</p>

<pre><code class="bash">$ cat fn-dynamodb-get/requirements.txt
boto3
</code></pre>

<p>Our python code for our function:</p>

<pre><code class="bash">$ cat fn-dynamodb-get/handler.py
</code></pre>

<pre><code class="python">import boto3
import os
import json

aws_key = open('/var/openfaas/secrets/openfaas-aws-access-key', 'r').read()
aws_secret = open('/var/openfaas/secrets/openfaas-aws-secret-key', 'r').read()
dynamodb_region = os.environ['dynamodb_region']
dynamodb_table  = os.environ['dynamodb_table']

client = boto3.Session(region_name=dynamodb_region).resource('dynamodb', aws_access_key_id=aws_key, aws_secret_access_key=aws_secret)
table = client.Table(dynamodb_table)

def handle(req):
    event = json.loads(req)
    response = table.get_item(
        Key={
            'hash_value': event['hash_value']
        }
    )

    if 'Item' not in response:
        item_data = 'Item not found'
    else:
        item_data = response['Item']

    return item_data
</code></pre>

<h2>Build, Push and Deploy:</h2>

<p>It&rsquo;s time to deploy our functions and since we have all our stack info in one file, we can use <code>faas-cli up</code> which will build, push and deploy our functions.</p>

<p>By default it expects the filename to be <code>stack.yml</code> therefore we don&rsquo;t need to specify the filename, but if you had a different filename, you can overwrite the default behaviour with <code>-f</code>:</p>

<pre><code class="bash">$ faas-cli up

Deploying: fn-dynamodb-lookup.
Deployed. 202 Accepted.
URL: https://openfaas.domain.com/function/fn-dynamodb-lookup

Deploying: fn-dynamodb-write.
Deployed. 202 Accepted.
URL: https://openfaas.domain.com/function/fn-dynamodb-write

Deploying: fn-dynamodb-get.
Deployed. 202 Accepted.
URL: https://openfaas.domain.com/function/fn-dynamodb-get
</code></pre>

<h2>Time for our Functions to interact with DynamoDB:</h2>

<p>Write an Item to DynamoDB:</p>

<pre><code class="bash">$ curl -XPOST https://openfaas.domain.com/function/fn-dynamodb-write -d '{"id": 8700000000001, "lastname": "smith", "payload": {"name": "james", "role": "reader"}}'
{'ResponseMetadata': {'RequestId': 'CNHEFHMSL4KGRDE0HRVQ69D5H7VV4KQNSO5AEMVJF66Q9ASUAAJG', 'HTTPStatusCode': 200, 'HTTPHeaders': {'server': 'Server', 'date': 'Sat, 06 Jul 2019 20:47:00 GMT', 'content-type': 'application/x-amz-json-1.0', 'content-length': '2', 'connection': 'keep-alive', 'x-amzn-requestid': 'CNHEFHMSL4KGRDE0HRVQ69D5H7VV4KQNSO5AEMVJF66Q9ASUAAJG', 'x-amz-crc32': '2745614147'}, 'RetryAttempts': 0}}
</code></pre>

<p>Write another Item to DynamoDB:</p>

<pre><code class="bash">$ curl -XPOST https://openfaas.doamin.com/function/fn-dynamodb-write -d '{"id": 8700000000002, "lastname": "adams", "payload": {"name": "samantha", "role": "admin"}}'
{'ResponseMetadata': {'RequestId': 'KRQL838BVGC9LIUSCOUB7MOEQ7VV4KQNSO5AEMVJF66Q9ASUAAJG', 'HTTPStatusCode': 200, 'HTTPHeaders': {'server': 'Server', 'date': 'Sat, 06 Jul 2019 20:48:09 GMT', 'content-type': 'application/x-amz-json-1.0', 'content-length': '2', 'connection': 'keep-alive', 'x-amzn-requestid': 'KRQL838BVGC9LIUSCOUB7MOEQ7VV4KQNSO5AEMVJF66Q9ASUAAJG', 'x-amz-crc32': '2745614147'}, 'RetryAttempts': 0}}
</code></pre>

<p>Now recalculate the hash by passing the ID Number and Lastname to get the hash value for the primary key:</p>

<pre><code class="bash">$ curl -XPOST https://openfaas.domain.com/function/fn-dynamodb-lookup -d '{"id": 8700000000002, "lastname": "adams"}'
bd0a248aff2b50b288ba504bd7142ef11b164901
</code></pre>

<p>Now that we have the hash value, do a GetItem by using the hash value in the request body:</p>

<pre><code class="bash">$ curl -XPOST https://openfaas.domain.com/function/fn-dynamodb-get -d '{"hash_value": "bd0a248aff2b50b288ba504bd7142ef11b164901"}'
{'payload': {'name': 'samantha', 'role': 'admin'}, 'hash_value': 'bd0a248aff2b50b288ba504bd7142ef11b164901', 'timestamp': '2019-07-06T20:48'}
</code></pre>

<p>Note that the lookup function calculates a hash based on the input that you provide it, for example calculating a hash with userdata that does not exist in our table:</p>

<pre><code class="bash">$ curl -XPOST https://openfaas.domain.com/function/fn-dynamodb-lookup -d '{"id": 8700000000003, "lastname": "williams"}'
c68dc272873140f4ae93bb3a3317772a6bdd9aa1
</code></pre>

<p>Using that hash value in our request body to read from dynamodb, will show us that the item has not been found:</p>

<pre><code class="bash">$ curl -XPOST https://openfaas.domain.com/function/fn-dynamodb-get -d '{"hash_value": "c68dc272873140f4ae93bb3a3317772a6bdd9aa1"}'
Item not found
</code></pre>

<p>You might want to change this behavior but this is just for the demonstration of this post.</p>

<p>When you head over to DynamoDB&rsquo;s console you will see this in your table:</p>

<p><img width="873" alt="image" src="https://user-images.githubusercontent.com/567298/60761025-9e8e7c80-a040-11e9-83a3-ad5b474a28ff.png"></p>

<h2>Thanks</h2>

<p>This was a basic example using OpenFaaS with Amazon DynamoDB with Python and secrets managed with OpenFaas. I really like the way OpenFaaS let&rsquo;s you work with secrets, it works great and don&rsquo;t need an additional resource to manage your sensitive data.</p>

<p>Although this was basic usage with OpenFaaS and DynamoDB, the sky is the limit what you can do with it.</p>

<h2>Resources:</h2>

<ul>
<li><a href="https://aws.amazon.com/blogs/database/choosing-the-right-dynamodb-partition-key/">DynamoDB: Choosing the right Partition Key</a></li>
<li><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-uniform-load.html">Designing Partition Keys to Distribute Your Workload Evenly</a></li>
<li><a href="https://docs.openfaas.com/contributing/get-started/">OpenFaaS: Getting Started</a></li>
<li><a href="https://docs.openfaas.com/reference/secrets/">OpenFaaS: Secrets</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Multiprocessing Tutorial]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/02/05/python-multiprocessing-tutorial/"/>
    <updated>2019-02-05T17:05:49+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/02/05/python-multiprocessing-tutorial</id>
    <content type="html"><![CDATA[<p>I stumbled apon a great <a href="https://tutorialedge.net/python/python-multiprocessing-tutorial/">python multiprocessing tutorial</a>, when I was looking into spawning multiple processes in parallel on a Lambda function.</p>

<p>In this example im getting latencies between regions using tcpping, but instead of running them one at a time, I was looking into spawning them in parralel:</p>

<p>(code made static for demonstration)</p>

<pre><code class="python">import boto3
import os
import json
import multiprocessing as mp
from decimal import Decimal

region_maps = {
    'eu-west-1': {
        'dynamodb': 'dynamodb.eu-west-1.amazonaws.com'
    }, 
    'us-east-1': {
        'dynamodb': 'dynamodb.us-east-1.amazonaws.com'
    }, 
    'us-west-1': {
        'dynamodb': 'dynamodb.us-west-1.amazonaws.com'
    }, 
    'us-west-2': {
        'dynamodb': 'dynamodb.us-west-2.amazonaws.com'
    }
}

def get_results(target_region, target_service, target_endpoint):
    static_results = {
        "address": target_endpoint,
        "attempts": 5,
        "avg": 481.80199999999996,
        "max": 816.25,
        "min": 312.46,
        "port": 443,
        "region": "eu-west-1_{}_{}".format(target_service, target_region),
        "regionTo": target_region,
        "results": [
            {"seq": 1,"time": "816.25"},
            {"seq": 2,"time": "331.50"},
            {"seq": 3,"time": "597.22"},
            {"seq": 4,"time": "312.46"},
            {"seq": 5,"time": "351.58"}
        ],
        "timestamp": "2019-02-05T17:10:32"
    }
    return static_results

def dynamodb_write(data):
    ddb = boto3.Session(profile_name='test', region_name='eu-west-1').resource('dynamodb').Table('mydynamotable')
    ddb_parsed = json.loads(json.dumps(data), parse_float=Decimal)
    response = ddb.put_item(Item=ddb_parsed)
    return response

def spawn_work(region):
    target_region = region
    target_service = 'dynamodb'
    target_endpoint = region_maps[target_region][target_service]
    data = get_results(region, target_service, target_endpoint)
    print("pid: {}, data: {}".format(os.getpid(), data))
    response = dynamodb_write(data)

if __name__ == "__main__":
    pool = mp.Pool(mp.cpu_count())
    result = pool.map(spawn_work, ['eu-west-1', 'us-east-1', 'us-west-1', 'us-west-2'])
</code></pre>

<p>When running it locally, I can see that each job ran in its own pid:</p>

<pre><code class="bash">$ python foo.py
pid: 31224, data: {'attempts': 5, 'min': 312.46, 'timestamp': '2019-02-05T17:10:32', 'address': 'dynamodb.eu-west-1.amazonaws.com', 'max': 816.25, 'region': 'eu-west-1_dynamodb_eu-west-1', 'avg': 481.80199999999996, 'port': 443, 'regionTo': 'eu-west-1', 'results': [{'seq': 1, 'time': '816.25'}, {'seq': 2, 'time': '331.50'}, {'seq': 3, 'time': '597.22'}, {'seq': 4, 'time': '312.46'}, {'seq': 5, 'time': '351.58'}]}

pid: 31225, data: {'attempts': 5, 'min': 312.46, 'timestamp': '2019-02-05T17:10:32', 'address': 'dynamodb.us-east-1.amazonaws.com', 'max': 816.25, 'region': 'eu-west-1_dynamodb_us-east-1', 'avg': 481.80199999999996, 'port': 443, 'regionTo': 'us-east-1', 'results': [{'seq': 1, 'time': '816.25'}, {'seq': 2, 'time': '331.50'}, {'seq': 3, 'time': '597.22'}, {'seq': 4, 'time': '312.46'}, {'seq': 5, 'time': '351.58'}]}

pid: 31226, data: {'attempts': 5, 'min': 312.46, 'timestamp': '2019-02-05T17:10:32', 'address': 'dynamodb.us-west-1.amazonaws.com', 'max': 816.25, 'region': 'eu-west-1_dynamodb_us-west-1', 'avg': 481.80199999999996, 'port': 443, 'regionTo': 'us-west-1', 'results': [{'seq': 1, 'time': '816.25'}, {'seq': 2, 'time': '331.50'}, {'seq': 3, 'time': '597.22'}, {'seq': 4, 'time': '312.46'}, {'seq': 5, 'time': '351.58'}]}

pid: 31227, data: {'attempts': 5, 'min': 312.46, 'timestamp': '2019-02-05T17:10:32', 'address': 'dynamodb.us-west-2.amazonaws.com', 'max': 816.25, 'region': 'eu-west-1_dynamodb_us-west-2', 'avg': 481.80199999999996, 'port': 443, 'regionTo': 'us-west-2', 'results': [{'seq': 1, 'time': '816.25'}, {'seq': 2, 'time': '331.50'}, {'seq': 3, 'time': '597.22'}, {'seq': 4, 'time': '312.46'}, {'seq': 5, 'time': '351.58'}]}
</code></pre>

<p>Quite useful! Have a look at the link shared for more examples.</p>

<h2>Thank You</h2>

<p>Please feel free to show support by, <strong>sharing</strong> this post, making a <strong>donation</strong>, <strong>subscribing</strong> or <strong>reach out to me</strong> if you want me to demo and write up on any specific tech topic.</p>

<center>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick" />
<input type="hidden" name="hosted_button_id" value="W7CBGYTCWGANQ" />
<input type="image" src="https://user-images.githubusercontent.com/567298/49853901-461c3700-fdf1-11e8-9d80-8a424a3173af.png" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
<img alt="" border="0" src="https://www.paypal.com/en_ZA/i/scr/pixel.gif" width="1" height="1" />
</form>
</center>


<p><br></p>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Convert Float to Decimal Data Types for Boto3 DynamoDB Using Python]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/02/05/convert-float-to-decimal-data-types-for-boto3-dynamodb-using-python/"/>
    <updated>2019-02-05T16:45:40+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/02/05/convert-float-to-decimal-data-types-for-boto3-dynamodb-using-python</id>
    <content type="html"><![CDATA[<p>A quick post on a workaround when you need to convert float to decimal types.</p>

<p><br></p>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>


<p>One thing I really don&rsquo;t like about the AWS SDK for Python, specifically aimed towards DynamoDB is that Float types are not supported and that you should use Decimal types instead.</p>

<p>For example, my payload below:</p>

<pre><code class="python">&gt;&gt;&gt; data
{'attempts': 5, 'min': 180.87, 'timestamp': '2019-02-05T15:48:27', 'address': 'dynamodb.us-east-1.amazonaws.com', 'max': 747.17, 'region': 'eu-west-1_dynamodb', 'avg': 311.32599999999996, 'port': 443, 'regionTo': 'us-east-1', 'results': [{'seq': 1, 'time': '747.17'}, {'seq': 2, 'time': '215.60'}, {'seq': 3, 'time': '230.67'}, {'seq': 4, 'time': '180.87'}, {'seq': 5, 'time': '182.32'}]}
</code></pre>

<p>Trying to write that as an Item to my DynamoDB table and you will be faced with the exception below:</p>

<pre><code class="python">&gt;&gt;&gt; ddb.put_item(Item=data)
TypeError: Float types are not supported. Use Decimal types instead.
</code></pre>

<p>One way around this is to use <code>parse_float</code> in <code>json.loads()</code>:</p>

<pre><code>&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; import json
&gt;&gt;&gt; ddb_data = json.loads(json.dumps(data), parse_float=Decimal)
&gt;&gt;&gt; ddb_data
{u'max': Decimal('747.17'), u'min': Decimal('180.87'), u'timestamp': u'2019-02-05T15:48:27', u'region': u'eu-west-1_dynamodb', u'regionTo': u'us-east-1', u'results': [{u'seq': 1, u'time': u'747.17'}, {u'seq': 2, u'time': u'215.60'}, {u'seq': 3, u'time': u'230.67'}, {u'seq': 4, u'time': u'180.87'}, {u'seq': 5, u'time': u'182.32'}], u'attempts': 5, u'address': u'dynamodb.us-east-1.amazonaws.com', u'avg': Decimal('311.32599999999996'), u'port': 443}
</code></pre>

<h2>Thank You</h2>

<p>Please feel free to show support by, <strong>sharing</strong> this post, making a <strong>donation</strong>, <strong>subscribing</strong> or <strong>reach out to me</strong> if you want me to demo and write up on any specific tech topic.</p>

<center>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick" />
<input type="hidden" name="hosted_button_id" value="W7CBGYTCWGANQ" />
<input type="image" src="https://user-images.githubusercontent.com/567298/49853901-461c3700-fdf1-11e8-9d80-8a424a3173af.png" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
<img alt="" border="0" src="https://www.paypal.com/en_ZA/i/scr/pixel.gif" width="1" height="1" />
</form>
</center>


<p><br></p>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Setup a Serverless URL Shortener With API Gateway Lambda and DynamoDB on AWS]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/11/30/how-to-setup-a-serverless-url-shortener-with-api-gateway-lambda-and-dynamodb-on-aws/"/>
    <updated>2018-11-30T09:51:24+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/11/30/how-to-setup-a-serverless-url-shortener-with-api-gateway-lambda-and-dynamodb-on-aws</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/aws-logo.png" alt="" /></p>

<p>Today we will set a Serverless URL Shortener using API Gateway, Lambda with Python and DynamoDB.</p>

<h2>Overview</h2>

<p>The service that we will be creating, will shorten URLs via our API which will create an entry on DynamoDB. When a GET method is performed on the shortened URL, a GetItem is executed on DynamoDB to get the Long URL and a 301 Redirect is performed to redirect the client to intended destination URL.</p>

<p>Note, I am using a domain name which is quite long, but its only for demonstration, if you can get hold of any short domains like <code>t.co</code> etc, that will make your Shortened URLs really short in character count.</p>

<p>Update: URL Shortener UI <a href="https://blog.ruanbekker.com/blog/2018/12/18/creating-a-ui-in-python-flask-and-bootstrap-for-our-serverless-url-shortener/">available in this post</a></p>

<h2>The Setup</h2>

<p>Code has been published to my <strong><a href="https://github.com/ruanbekker/aws-serverless-url-shortener">Github Repository</a></strong></p>

<p>The following services will be used to create a URL Shortener:</p>

<ul>
<li>AWS API Gateway: ( <code>/create</code>: to create a shortened url and <code>/t/{id}</code> to redirect to long url)</li>
<li>AWS IAM: (Role and Policy for Permissions to call DynamoDB from Lambda)</li>
<li>AWS Lambda: (Application Logic)</li>
<li>AWS DynamoDB: (Persistent Store to save our Data)</li>
<li>AWS ACM: (Optional: Certificate for your Domain)</li>
<li>AWS Route53: (Optional: DNS for the domain that you want to associate to your API)</li>
</ul>


<p>The flow will be like the following:</p>

<ul>
<li>POST Request gets made to the <code>/create</code> request path with the <code>long_url</code> data in the payload</li>
<li>This data is then used by the Lambda function to create a short url and create a entry in DynamoDB</li>
<li>In DynamoDB the entry is created with the short id as the hash key and the long url as one of the attributes</li>
<li>The response to the client will be the short url</li>
<li>When a GET method is performed on the id eg <code>/t/{short_id}</code>, a lookup gets done on the DynamoDB table, retrieves the long url from the table</li>
<li>A 301 redirect gets performed on API Gateway and the client gets redirected to the intended url</li>
</ul>


<h2>Creating the URL Shortener</h2>

<p>After completing this tutorial you will have your own Serverless URL Shortener using API Gateway, Lambda and DynamoDB.</p>

<h2>IAM Permissions</h2>

<p>On AWS IAM, create a IAM Policy, in my case the policy name is <code>lambda-dynamodb-url-shortener</code> and note that I masked out my account number:</p>

<pre><code class="json">{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "dynamodb:PutItem",
                "dynamodb:DeleteItem",
                "dynamodb:GetItem",
                "dynamodb:Query",
                "dynamodb:UpdateItem"
            ],
            "Resource": "arn:aws:dynamodb:eu-west-1:xxxxxxxxxxxx:table/url-shortener-table"
        }
    ]
}
</code></pre>

<p>Head over to <a href="https://console.aws.amazon.com/iam/home?region=eu-west-1#/roles">IAM Roles</a>, select Create Role, Select Lambda as the Trusted Entitiy from the AWS Service section, go ahead with the permissions and select your IAM Policy that was created, in my case <code>lambda-dynamodb-url-shortener</code> and <code>AWSLambdaBasicExecution</code> role. Give your Role a name, in my case <code>lambda-dynamodb-url-shortener-role</code>.</p>

<h2>DynamoDB Table</h2>

<p>Next, head over to <a href="https://eu-west-1.console.aws.amazon.com/dynamodb/home?region=eu-west-1#create-table:">DynamoDB</a> create a table, in my case the table name: <code>url-shortener-table</code> and the primary key <code>short_id</code> set to string:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-02.png" alt="" /></p>

<h2>Lambda Functions</h2>

<p>Once the table is created, head over to <a href="https://eu-west-1.console.aws.amazon.com/lambda/home?region=eu-west-1#/create?firstrun=true">Lambda</a> and create a Lambda function, in my case using Python 3.6 and provide a name, where I used: <code>url-shortener-create</code> and select the IAM role from the previous role that we created, this function will be the lambda function that will create the shortened urls:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-03-lambda.png" alt="" /></p>

<p>The code for your lambda function which will take care of creating the short urls and save them to dynamodb, take note on the region and table name to ensure that it matches your setup:</p>

<pre><code class="python">import os
import json
import boto3
from string import ascii_letters, digits
from random import choice, randint
from time import strftime, time
from urllib import parse

app_url = os.getenv('APP_URL')
min_char = int(os.getenv('MIN_CHAR'))
max_char = int(os.getenv('MAX_CHAR'))
string_format = ascii_letters + digits

ddb = boto3.resource('dynamodb', region_name = 'eu-west-1').Table('url-shortener-table')

def generate_timestamp():
    response = strftime("%Y-%m-%dT%H:%M:%S")
    return response

def expiry_date():
    response = int(time()) + int(604800)
    return response

def check_id(short_id):
    if 'Item' in ddb.get_item(Key={'short_id': short_id}):
        response = generate_id()
    else:
        return short_id

def generate_id():
    short_id = "".join(choice(string_format) for x in range(randint(min_char, max_char)))
    print(short_id)
    response = check_id(short_id)
    return response

def lambda_handler(event, context):
    analytics = {}
    print(event)
    short_id = generate_id()
    short_url = app_url + short_id
    long_url = json.loads(event.get('body')).get('long_url')
    timestamp = generate_timestamp()
    ttl_value = expiry_date()

    analytics['user_agent'] = event.get('headers').get('User-Agent')
    analytics['source_ip'] = event.get('headers').get('X-Forwarded-For')
    analytics['xray_trace_id'] = event.get('headers').get('X-Amzn-Trace-Id')

    if len(parse.urlsplit(long_url).query) &gt; 0:
        url_params = dict(parse.parse_qsl(parse.urlsplit(long_url).query))
        for k in url_params:
            analytics[k] = url_params[k]

    response = ddb.put_item(
        Item={
            'short_id': short_id,
            'created_at': timestamp,
            'ttl': int(ttl_value),
            'short_url': short_url,
            'long_url': long_url,
            'analytics': analytics,
            'hits': int(0)
        }
    )

    return {
        "statusCode": 200,
        "body": short_url
    }
</code></pre>

<p>Set a couple of environment variables that will be used in our function, min and max chars from the screenshot below is the amount of characters that will be used in a random manner to make the short id unique. The app_url will be your domain name, as this will be returned to the client with the short id eg. <code>https://tiny.myserverlessapp.net/t/3f8Hf38n398t</code> :</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-04-lambda.png" alt="" /></p>

<p>While you are on Lambda, create the function that will retrieve the long url, in my case <code>url-shortener-retrieve</code>:</p>

<pre><code class="python">import os
import json
import boto3

ddb = boto3.resource('dynamodb', region_name = 'eu-west-1').Table('url-shortener-table')

def lambda_handler(event, context):
    short_id = event.get('short_id')

    try:
        item = ddb.get_item(Key={'short_id': short_id})
        long_url = item.get('Item').get('long_url')
        # increase the hit number on the db entry of the url (analytics?)
        ddb.update_item(
            Key={'short_id': short_id},
            UpdateExpression='set hits = hits + :val',
            ExpressionAttributeValues={':val': 1}
        )

    except:
        return {
            'statusCode': 301,
            'location': 'https://objects.ruanbekker.com/assets/images/404-blue.jpg'
        }

    return {
        "statusCode": 301,
        "location": long_url
    }
</code></pre>

<h2>API Gateway</h2>

<p>Head over to <a href="https://console.aws.amazon.com/apigateway/home?region=us-east-1#/apis">API Gateway</a> and create your API, in my case <code>url-shortener-api</code></p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-05-api-gateway.png" alt="" /></p>

<p>Head over to Resources:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-06-api-gateway.png" alt="" /></p>

<p>and create a new resource called <code>/create</code>:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-07-api-gateway.png" alt="" /></p>

<p>Once the resource is created, create a post method on the <code>create</code> resource and select Lambda as the integration type and lambda proxy integration as seen below:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-09-api-gateway.png" alt="" /></p>

<p>Once you save it, it will ask to give api gateway permission to invoike your lambda function wich you can accept by hitting ok as below:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-10-iam-permission.png" alt="" /></p>

<p>When you look at the POST method on your create resource, it should look like this:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-12-api-gateway.png" alt="" /></p>

<p>Select the root resource <code>/</code> and from Actions create a new resource <code>/t</code>:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-13-api-gateway.png" alt="" /></p>

<p>Select the <code>/t</code> resource and create a new resource named <code>shortid</code> and provide <code>{shortid}</code> in the resource path as this will be the data that will be proxied through to our lambda function:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-14-api-gateway.png" alt="" /></p>

<p>Create a GET method on the <code>/t/{shortid}</code> resource and select <code>url-shortener-retrieve</code> lambda function as the function from the lambda integration selection as seen below:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-17-api-gateway.png" alt="" /></p>

<p>Again, grant api gateway permission to invoke your function:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-18-iam-permission.png" alt="" /></p>

<p>When you select the GET method, it should look like this:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-19-api-gateway.png" alt="" /></p>

<p>Select the Integration Request and head over to Mapping Templates:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-20-api-gateway.png" alt="" /></p>

<p>from the Request body passtrhough, add a mapping template <code>application/json</code> and provide the following mapping template:</p>

<pre><code>{
    "short_id": "$input.params('shortid')"
}
</code></pre>

<p>On the Method Response:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-21-api-gateway.png" alt="" /></p>

<p>Delete the 200 HTTP Status Response and create a new response by &ldquo;Add Response&rdquo;, add <code>301</code> HTTP Status, add <code>Location</code> Header to the response.</p>

<p>Navigate to the Integration Response from the <code>/{shortid}</code> GET method:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-21-api-gateway.png" alt="" /></p>

<p>delete the 200 HTTP Response, add &ldquo;integration response&rdquo;, set method response status to 301 and add header mapping for location to integration.response.body.location as below:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-23-api-gateway.png" alt="" /></p>

<p>make sure to select the integration response to - so that the method response reflects to 301:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-24-api-gateway.png" alt="" /></p>

<p>Navigate to Actions and select &ldquo;Deploy API&rdquo;, select your stage, in my case <code>test</code> and deploy:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-25-api-gateway.png" alt="" /></p>

<p>Go to stages, select your stage, select the post request to reveal the API URL:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-26-api-gateway.png" alt="" /></p>

<p>Time to test out the URL Shortener:</p>

<pre><code class="bash">curl -XPOST -H "Content-Type: application/json" https://xxxxxx.execute-api.eu-west-1.amazonaws.com/test/create -d '{"long_url": "https://www.google.com/search?q=helloworld"}'
https://tiny.myserverlessapp.net/t/pcnWoCGCr2ad1x
</code></pre>

<h2>ACM Certificates</h2>

<p>At this moment we dont have our domain connected with our API Gateway, and we would also want a certificate on our application, which we can use ACM to request a certificate that can be associated to our domain. So in order to do that, first request a certificate on <a href="https://eu-west-1.console.aws.amazon.com/acm/home?region=eu-west-1#/privatewizard/">ACM</a>. Select Request a certificate, create a wildcard entry: <code>*.yourdomain.com</code>, select DNS Validation (If you host with Route53, they allow you the option to create the record).</p>

<p>Head back to API Gateway to associate the Domain and ACM Certificate to our API:</p>

<p>From the &ldquo;Custom Domain Names&rdquo; section, create a custom domain name, once you selected regional, it will ask for the target domain name, which will be the resolved to your API Endpoint that was created, and from the &ldquo;Base Path Mappings&rdquo; section, select <code>/</code> as the path to your API stage, in my case <code>url-shortener-api:test</code>:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-28-api-gateway.png" alt="" /></p>

<h2>Route 53</h2>

<p>Last part is to create a Route53 entry for tiny.yourdomain.com to resolve to the CNAME value of the target domain name that was provided in the custom domain names section:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-29-route53.png" alt="" /></p>

<h2>Demo the URL Shortener Service:</h2>

<p>Once everything is setup we can test, by creating a Shortened URL:</p>

<pre><code class="bash">$ curl -XPOST -H "Content-Type: application/json" https://tiny.myserverlessapp.net/create -d '{"long_url": "https://www.google.com/search?q=helloworld"}'
https://tiny.myserverlessapp.net/t/p7ISNcxTByXhN
</code></pre>

<p>Testing out the Short URL to redirect to the Destination URL:</p>

<pre><code class="bash">$ curl -ivL https://tiny.myserverlessapp.net/t/p7ISNcxTByXhN
*   Trying 34.226.10.0...
* TCP_NODELAY set
* Connected to tiny.myserverlessapp.net (34.226.10.0) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate: *.myserverlessapp.net
* Server certificate: Amazon
* Server certificate: Amazon Root CA 1
* Server certificate: Starfield Services Root Certificate Authority - G2
&gt; GET /t/p7ISNcxTByXhN HTTP/1.1
&gt; Host: tiny.myserverlessapp.net
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 301 Moved Permanently
HTTP/1.1 301 Moved Permanently
&lt; Date: Tue, 29 Nov 2018 00:05:02 GMT
Date: Tue, 29 Nov 2018 00:05:02 GMT
&lt; Content-Type: application/json
Content-Type: application/json
&lt; Content-Length: 77
Content-Length: 77
&lt; Connection: keep-alive
Connection: keep-alive
&lt; x-amzn-RequestId: f79048c8-cb56-41e8-b21d-b45fac47453a
x-amzn-RequestId: f79048c8-cb56-41e8-b21d-b45fac47453a
&lt; x-amz-apigw-id: OeKPHH7_DoEFdjg=
x-amz-apigw-id: OeKPHH7_DoEFdjg=
&lt; Location: https://www.google.com/search?q=helloworld
Location: https://www.google.com/search?q=helloworld
</code></pre>

<p>At this moment our API is open to the world, which is probably not the best as everyone will be able to Shorten URL&rsquo;s. You can check out <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-setup-api-key-with-console.html">Set Up API Keys Using the API Gateway Console</a> documentation on how to secure your application by utilizing a api key which can be included in your request headers when Shortening URLs.</p>

<p>For a bit of housekeeping, you can implement TTL on DynamoDB so that old items expire, which can help you to refrain your dynamodb table from growing into large amounts of storage, you can have a look at a post on <a href="https://blog.ruanbekker.com/blog/2017/11/22/delete-old-items-with-amazons-dynamodb-ttl-feature/">Delete Old Items with Amazons DynamoDB TTL Feature</a> to implement that.</p>

<h2>Thank You</h2>

<p>Please feel free to show support by, <strong>sharing</strong> this post, making a <strong>donation</strong>, <strong>subscribing</strong> or <strong>reach out to me</strong> if you want me to demo and write up on any specific tech topic.</p>

<center>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick" />
<input type="hidden" name="hosted_button_id" value="W7CBGYTCWGANQ" />
<input type="image" src="https://user-images.githubusercontent.com/567298/49853901-461c3700-fdf1-11e8-9d80-8a424a3173af.png" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
</form>
</center>


<p><br></p>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Query 24 Hours Worth of Data Using BatchGet on Amazon DynamoDB Using Scan and Filter Without a GSI]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/10/30/query-24-hours-worth-of-data-using-batchget-on-amazon-dynamodb-using-scan-and-filter-without-a-gsi/"/>
    <updated>2018-10-30T20:53:43+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/10/30/query-24-hours-worth-of-data-using-batchget-on-amazon-dynamodb-using-scan-and-filter-without-a-gsi</id>
    <content type="html"><![CDATA[<p>I&rsquo;m testing how to query data in DynamoDB which will always be the retrieval of yesterdays data, without using a Global Secondary Index.</p>

<p>This is done just to see what other ways you can use to query data based on a specific timeframe.</p>

<script id="mNCC" language="javascript">
    medianet_width = "728";
    medianet_height = "90";
    medianet_crid = "218284798";
    medianet_versionId = "3111299"; 
  </script>


<script src="//contextual.media.net/nmedianet.js?cid=8CUD78FSV"></script>


<h2>Use-Case:</h2>

<p>Data from DynamoDB needs to be batch processed (daily for the last 24-hours), into a external datasource. Data will be written into DynamoDB, the HK (uuid) and RK (timestamp) will be duplicated to the daily table. But only uuid and timestamp will be duplicated to the daily table, and only data for that day will be written into that datestamp formatted table name.</p>

<p>Let&rsquo;s say data for 2018-10-30 needs to be written into our external data source, we will do a scan on table <code>tbl-test_20181030</code>, then from our response we will have a list of HashKeys (uuid) which we will use to do a BatchGet Item on our base table: <code>tbl-test_base</code>, which essentially grabs all the data for that day.</p>

<p>If deeper filtering needs to be done on that day, the FilterExpression can be used to do a deeper filtering which leads to grabbing only the filtered down data from the base table.</p>

<p><em>Note:</em> The base table might have millions of items, so a Scan operation on the Base table would be really expensive, as it reads all the items in the table.</p>

<p>Once the data has been processed, the daily or metadata table can be removed.</p>

<h2>DynamoDB Table Design</h2>

<p>The base table: <code>tbl-test_base</code> will have:</p>

<ul>
<li>HashKey: uuid (string)</li>
<li>RangeKey: timestamp (number)</li>
<li>Attributes: city, stream, transaction_date, name, metric_uri</li>
<li>Item will look like:</li>
</ul>


<pre><code class="python">{
  u'uuid': u'fb4ddeb9-3b5e-47b3-bbab-1aa1d8e8f47b', 
  u'timestamp': 1540891276, 
  u'city': u'sydney', 
  u'stream': u'NONE', 
  u'transaction_date': u'2018-10-30 11:21:16', 
  u'metric_uri': u'some-dummy-metric-uri', 
  u'name': u'frank'
}
</code></pre>

<p>he Daily Table: <code>tbl-test_20181030</code> will look like:</p>

<ul>
<li>HashKey: <code>uuid</code></li>
<li>Attributes: <code>timestamp</code></li>
<li>Item will look like:</li>
</ul>


<pre><code class="python">{
  u'uuid': u'fb4ddeb9-3b5e-47b3-bbab-1aa1d8e8f47b', 
  u'timestamp': 1540891276
}
</code></pre>

<h2>Demonstration using Python</h2>

<p>Creating the Metadata table:</p>

<pre><code class="python">import boto3, time, uuid, random

session = boto3.Session(region_name='eu-west-1', profile_name='dev')
resource = session.resource('dynamodb')
client = session.client('dynamodb')

def create_table():
    table_name = "tbl-test_{0}".format(time.strftime("%Y%m%d"))
    response = resource.create_table(
        TableName=table_name,
        KeySchema=[{
            'AttributeName': 'uuid',
            'KeyType': 'HASH'
        }],
        AttributeDefinitions=[{
            'AttributeName': 'uuid',
            'AttributeType': 'S'
        }],
        ProvisionedThroughput={
            'ReadCapacityUnits': 1,
            'WriteCapacityUnits': 1
        }
    )

    resource.Table(table_name).wait_until_exists()

    arn = client.describe_table(TableName=table_name)['Table']['TableArn']
    client.tag_resource(
        ResourceArn=arn,
        Tags=[
            {'Key': 'Name','Value': 'dynamo_table'},
            {'Key': 'Environment','Value': 'Dev'},
            {'Key': 'CreatedBy','Value': 'Ruan'}
        ]
    )

    return resource.Table(table_name).table_status

print(create_table())
</code></pre>

<p>Write 400 Items to DynamoDB:</p>

<pre><code class="python">import boto3, time, uuid, random

session = boto3.Session(region_name='eu-west-1', profile_name='dev')
resource = session.resource('dynamodb')
client = session.client('dynamodb')

base_table = 'tbl-test_base'
meta_table = 'tbl-test_{0}'.format(time.strftime("%Y%m%d"))

people = ['james', 'john', 'frank', 'paul', 'nathan', 'kevin']
cities = ['ireland', 'cape town', 'pretoria', 'paris', 'amsterdam', 'auckland', 'sydney']

def write_dynamo(uuid, timestamp):
    resource.Table(base_table).put_item(
        Item={
            'uuid': uuid, 
            'timestamp': timestamp, 
            'metric_uri': 'some-dummy-metric-uri', 
            'transaction_date': time.strftime("%Y-%m-%d %H:%M:%S"), 
            'name': random.choice(people), 
            'stream': 'NONE', 
            'city': random.choice(cities)
        }
    )

    resource.Table(meta_table).put_item(
        Item={
            'uuid': uuid, 
            'timestamp': timestamp
        }
    )

    return 'Written'

for x in xrange(400):
    time.sleep(1)
    write_dynamo(str(uuid.uuid4()), int(time.time()))
    print(x)
</code></pre>

<p>Getting Data for 20181030 but also filter data greater than the timestamp attribute, greater than <code>1540841144</code> in epoch time (which will give us about 254 items).</p>

<p>The BatchGet Item supports up to 100 items per call, we will limit the scans on 100 items per call, then paginate using the ExlusiveStartKey with the value of our LastEvaluatedKey that we will get from our response:</p>

<pre><code class="python">import boto3,time
from boto3.dynamodb.conditions import Key

base_table = 'tbl-test_base'
meta_table = 'tbl-test_20181030'

session = boto3.Session(region_name='eu-west-1', profile_name='dev')
resource = session.resource('dynamodb')
table = resource.Table(meta_table)
filtering_expression = Key('timestamp').gt(1540841144)

response = table.scan(FilterExpression=filtering_expression, Limit=100)

finished=False
while finished != True:
    if 'LastEvaluatedKey' in response.keys():
        print("Getting {} Items".format(response['Count']))
        items = resource.batch_get_item(RequestItems={base_table: {'Keys': response['Items']}})
        print(items['Responses'][base_table])
        time.sleep(2)
        response = table.scan(FilterExpression=filtering_expression, Limit=100, ExclusiveStartKey=response['LastEvaluatedKey'])
    else:
        print("Getting {} Items".format(response['Count']))
        items = resource.batch_get_item(RequestItems={base_table: {'Keys': response['Items']}})
        print(items['Responses'][base_table])
        finished=True
</code></pre>

<p>Running it:</p>

<pre><code class="bash">$ python dynamodb-batch-get.py
Getting 100 Items
[{u'city': u'pretoria', u'uuid': u'e8bc0d1c-2b57-4de2-b0e1-35ef1fe0edf1', u'stream': u'NONE', u'timestamp': Decimal('1540846990'), u'transaction_date': u'2018-10-29 23:03:10', u'metric_uri': u'some-dummy-metric-uri', u'name': u'frank'}, {u'city': u'amsterdam', u'uuid':
...
Getting 100 Items
[{u'city': u'sydney', u'uuid': u'5bc51ce9-2809-46c9-a3f2-ff8180086d92', u'stream': u'NONE', u'timestamp': Decimal('1540848599'), u'transaction_date': u'2018-10-29 23:29:59', u'metric_uri': u'some-dummy-metric-uri', u'name': u'frank'}
...
Getting 54 Items
[{u'city': u'cape town', u'uuid': u'5e069f34-0e97-4a49-9ca9-da2213edb689'...
</code></pre>

<p>Verifying that each call only scans 100 at a time:</p>

<pre><code class="python">&gt;&gt;&gt; response = table.scan(FilterExpression=filtering_expression, Limit=100)
&gt;&gt;&gt; response.keys()
[u'Count', u'Items', u'LastEvaluatedKey', u'ScannedCount', 'ResponseMetadata']
&gt;&gt;&gt; response.get('LastEvaluatedKey')
{u'uuid': u'e8c52a55-ca9e-4718-83d2-1b44a90f43e6'}
&gt;&gt;&gt; response.get('Count')
100
&gt;&gt;&gt; response.get('ScannedCount')
100
</code></pre>

<h2>Other Thoughts:</h2>

<p>Querying data is a lot easier using a Global Secondary Index where you could similarly have the metric_uri as the HashKey and transaction_date as the RangeKey:</p>

<pre><code class="python">&gt;&gt;&gt; response = table.query(
    IndexName='metric_uri-transaction_date-index', 
    KeyConditionExpression=Key('metric_uri').eq('some-dummy-metric-uri') &amp; Key('transaction_date').begins_with('2018-10-30')
)
&gt;&gt;&gt; response['Count']
400
</code></pre>

<p>Also note that depending on how you setup your GSI, in most cases its a exact duplicate in storage from your base table, so could potentially be double the costs.</p>
]]></content>
  </entry>
  
</feed>
