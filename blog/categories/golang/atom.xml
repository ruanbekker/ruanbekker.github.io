<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Golang | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2019-04-03T08:33:23-04:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Build Small Golang Docker Containers]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/04/03/build-small-golang-docker-containers/"/>
    <updated>2019-04-03T08:24:08-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/04/03/build-small-golang-docker-containers</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/55478306-aabb0600-561b-11e9-9cc6-730fadb4beeb.png" alt="" /></p>

<p>In this tutorial I will show you how to build really small docker containers for golang applications. And I mean the difference between 310MB down to 2MB</p>

<h2>But Alpine..</h2>

<p>So we thinking lets go with alpine right? Yeah sure lets build a small, app running on go with alpine.</p>

<p>Our application code:</p>

<pre><code class="golang app.go">package main

import (
  "fmt"
  "math/rand"
  "time"
)

func main() {
  lekkewords := []string{
    "dog", "cat", "fish", "giraffe",
    "moo", "spider", "lion", "apple",
    "tree", "moon", "snake", "mountain lion",
    "trooper", "burger", "nasa", "yes",
  }

  rand.Seed(time.Now().UnixNano())
  var zelength int = len(lekkewords)
  var indexnum int = rand.Intn(zelength-1)
  word := lekkewords[indexnum]

  fmt.Println("Number of words:", zelength)
  fmt.Println("Selected index number:", indexnum)
  fmt.Println("Selected word is:", word)
}
</code></pre>

<p>Our Dockerfile:</p>

<pre><code class="docker Dockerfile">FROM golang:alpine

WORKDIR $GOPATH/src/mylekkepackage/mylekkeapp/
COPY app.go .
RUN go build -o /go/app

CMD ["/go/app"]
</code></pre>

<p>Let&rsquo;s package our app to an image:</p>

<pre><code>❯ docker build -t mygolangapp:using-alpine .
</code></pre>

<p>Inspect the size of our image, as you can see it being <strong>310MB</strong></p>

<pre><code>❯ docker images "mygolangapp:*"
REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE
mygolangapp         using-alpine        eea1d7bde218        About a minute ago   310MB
</code></pre>

<p>Just make sure it actually works:</p>

<pre><code>❯ docker run mygolangapp:using-alpine
Number of words: 16
Selected index number: 11
Selected word is: mountain lion
</code></pre>

<p>But for something just returning random selected text, 310MB is a bit crazy.</p>

<h2>Multi Stage Builds</h2>

<p>As Go binaries are self-contained, we can make use of docker&rsquo;s multi stage builds, where we can build our application on alpine and use the binary on a scratch image:</p>

<p>Our multi stage Dockerfile:</p>

<pre><code class="docker Dockerfile.mult">FROM golang:alpine AS builder

WORKDIR $GOPATH/src/mylekkepackage/mylekkeapp/
COPY app.go .
RUN go build -o /go/app

FROM scratch

COPY --from=builder /go/app /go/app

CMD ["/go/app"]
</code></pre>

<p>Build it:</p>

<pre><code>❯ docker build -t mygolangapp:using-multistage -f Dockerfile.multi .
</code></pre>

<p>Notice that the image is only <strong>2.01MB</strong>, say w000t!</p>

<pre><code>❯ docker images "mygolangapp:*"
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mygolangapp         using-multistage    31474c61ba5b        15 seconds ago      2.01MB
mygolangapp         using-alpine        eea1d7bde218        2 minutes ago       310MB
</code></pre>

<p>Run the app:</p>

<pre><code>❯ docker run mygolangapp:using-multistage
Number of words: 16
Selected index number: 5
Selected word is: spider
</code></pre>

<h2>Resources</h2>

<p>Source code for this demonstration can be found at <a href="https://github.com/ruanbekker/golang-build-small-images">github.com/ruanbekker/golang-build-small-images</a></p>

<p><img src="https://user-images.githubusercontent.com/567298/55478904-236e9200-561d-11e9-9382-f31b25a9ae03.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a Golang Environment on Ubuntu]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/11/22/setup-a-golang-environment-on-ubuntu/"/>
    <updated>2018-11-22T17:09:29-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/11/22/setup-a-golang-environment-on-ubuntu</id>
    <content type="html"><![CDATA[<p>In this post I will demonstrate how to setup a golang environment on Ubuntu.</p>

<h2>Get the sources:</h2>

<p>Get the latest stable release golang tarball from <a href="https://golang.org/dl/">https://golang.org/dl/</a> and download to the directory path of choice, and extract the archive:</p>

<pre><code class="bash">$ cd /tmp
$ wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz
$ tar -xf go1.11.2.linux-amd64.tar.gz
</code></pre>

<p>Once the archive is extracted, set root permissions and move it to the path where your other executable binaries reside:</p>

<pre><code class="bash">$ sudo chown -R root:root ./go
$ sudo mv go /usr/local/
</code></pre>

<p>Cleanup the downloaded archive:</p>

<pre><code class="bash">$ rm -rf go1.*.tar.gz
</code></pre>

<h2>Path Variables:</h2>

<p>Adjust your path variables in your <code>~/.profile</code> and append the following:</p>

<p><code>bash ~/.profile
export GOPATH=$HOME/go
export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin
</code></p>

<p>Source your profile, or open a new tab:</p>

<pre><code class="bash">$ source ~/.profile
</code></pre>

<p>Test if you can return the version:</p>

<pre><code class="bash">$ go version
go version go1.11.2 linux/amd64
</code></pre>

<h2>Create a Golang Application</h2>

<p>Create a simple golang app that prints a string to stdout:</p>

<pre><code class="bash">$ cd ~/
$ mkdir -p go/src/hello
$ cd go/src/hello
$ vim app.go
</code></pre>

<p>Add the following golang code:</p>

<pre><code class="go">package main

import "fmt"

func main() {
    fmt.Printf("Hello!\n")
}
</code></pre>

<p>Build the binary:</p>

<pre><code class="bash">$ go build
</code></pre>

<p>Run it:</p>

<pre><code class="bash">$ ./app
Hello!
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang: Building a Basic Web Server in Go]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/11/21/golang-building-a-basic-web-server-in-go/"/>
    <updated>2018-11-21T00:57:54-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/11/21/golang-building-a-basic-web-server-in-go</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/golang-web-server.png" alt="" /></p>

<p>Continuing with our <a href="https://blog.ruanbekker.com/blog/categories/golang-tutorial/">#golang-tutorial</a> blog series, in this post we will setup a Basic HTTP Server in Go.</p>

<h2>Our Web Server:</h2>

<p>Our Web Server will respond on 2 Request Paths:</p>

<pre><code>- / -&gt; returns "Hello, Wolrd!"
- /cheers -&gt; returns "Goodbye!"
</code></pre>

<h2>Application Code:</h2>

<p>If you have not setup your golang environment, you can do so by visiting <a href="https://medium.com/@AkyunaAkish/setting-up-a-golang-development-environment-mac-os-x-d58e5a7ea24f">@AkyunaAkish&rsquo;s Post on Setting up a Golang Development Enviornment on MacOSX</a>.</p>

<p>Create the <code>server.go</code> or any filename of your choice. Note: I created 2 ways of returning the content of http response for demonstration</p>

<pre><code class="go">package main

import (
    "io"
        "log"
    "net/http"
)

func hello(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/plain; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("Hello, World!" + "\n")
    log.Println("hello function handler was executed")
}

func goodbye(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/plain; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    io.WriteString(w, "Cheers!" + "\n")
    log.Println("goodbye function handler was executed")
}

func main() {
    http.HandleFunc("/", hello)
    http.HandleFunc("/cheers", goodbye)
    http.ListenAndServe(":8000", nil)
}
</code></pre>

<p>Explanation of what we are doing:</p>

<ul>
<li>Programs runs in the package <code>main</code></li>
<li>We are importing 3 packages: <code>io</code>, <code>log</code> and <code>net/http</code></li>
<li>HandleFunc registers the handler function for the given pattern in the DefaultServeMux, in this case the HandleFunc registers <code>/</code> to the <code>hello</code> handler function and <code>/cheers</code> to the goodbye handler function.</li>
<li>In our 2 handler functions, we have two arguments:

<ul>
<li>The first one is <code>http.ResponseWriter</code> and its corresponding response stream, which is actually an interface type.</li>
<li>The second is <code>*http.Request</code> and its corresponding HTTP request. <code>io.WriteString</code> is a helper function to let you write a string into a given writable stream, this is named the <code>io.Writer</code> interface in Golang.</li>
</ul>
</li>
<li>ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux</li>
<li>The logging is not a requirement, but used it for debugging/verbosity</li>
</ul>


<h2>Running our Server:</h2>

<p>Run the http server:</p>

<pre><code class="bash">$ go run server.go
</code></pre>

<h2>Client Side Requests:</h2>

<p>Run client side http requests to your golang web server:</p>

<pre><code class="bash">$ curl -i http://localhost:8000/
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Date: Wed, 21 Nov 2018 21:33:42 GMT
Content-Length: 14

Hello, World!
</code></pre>

<p>And another request to <code>/cheers</code>:</p>

<pre><code class="bash">$ curl -i http://localhost:8000/cheers
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Date: Wed, 21 Nov 2018 21:29:46 GMT
Content-Length: 8

Cheers!
</code></pre>

<h2>Server Side Output:</h2>

<p>As we used the log package, the logging gets returned to stdout:</p>

<pre><code class="bash">$ go run server.go
2018/11/21 23:29:36 hello function handler was executed
2018/11/21 23:29:46 goodbye function handler was executed
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://golang.org/doc/code.html">https://golang.org/doc/code.html</a></li>
<li><a href="https://gowalker.org/net/http#HandleFunc">https://gowalker.org/net/http#HandleFunc</a></li>
<li><a href="https://stackoverflow.com/questions/37863374/whats-the-difference-between-responsewriter-write-and-io-writestring">https://stackoverflow.com/questions/37863374/whats-the-difference-between-responsewriter-write-and-io-writestring</a></li>
<li><a href="https://www.alexedwards.net/blog/golang-response-snippets">https://www.alexedwards.net/blog/golang-response-snippets</a></li>
</ul>


<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World Programs in Different Languages]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/06/09/hello-world-programs-in-different-languages/"/>
    <updated>2018-06-09T21:11:00-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/06/09/hello-world-programs-in-different-languages</id>
    <content type="html"><![CDATA[<p>This post will demonstrate running hello world programs in different languages and also providing return time statistics</p>

<h2>C++</h2>

<p>Code</p>

<pre><code class="c">#include &lt;iostream&gt;
using namespace std;

int main()
{
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>Compile:</p>

<pre><code class="bash">$ c++ hello_cpp.cpp -o hello_cpp
</code></pre>

<p>Run:</p>

<pre><code class="bash">$ time ./hello_cpp
Hello, World!

real    0m0.005s
user    0m0.001s
sys   0m0.001s
</code></pre>

<h2>Golang:</h2>

<p>Code</p>

<pre><code class="go">package main

import "fmt"

func main() {
  fmt.Println("Hello, World!")
}
</code></pre>

<p>Compile:</p>

<pre><code class="bash">$ go build hello_golang.go
</code></pre>

<p>Run:</p>

<pre><code class="bash">time ./hello_golang
Hello, World!

real    0m0.006s
user    0m0.001s
sys   0m0.003s
</code></pre>

<h2>Python</h2>

<p>Code:</p>

<pre><code class="python">#!/usr/bin/env python
print("Hello, World!")
</code></pre>

<p>Make it executable:</p>

<pre><code class="bash">$ chmod +x ./hello_python.py
</code></pre>

<p>Run:</p>

<pre><code class="bash">$ time ./hello_python.py
Hello, World!

real    0m0.033s
user    0m0.015s
sys   0m0.010s
</code></pre>

<h2>Ruby</h2>

<p>Code:</p>

<pre><code class="ruby">#!/usr/bin/env ruby
puts "Hello, World!"
</code></pre>

<p>Make it executable:</p>

<pre><code class="bash">$ chmod +x ./hello_ruby.rb
</code></pre>

<p>Run:</p>

<pre><code class="bash">$ time ./hello_ruby.rb
Hello, World!

real    0m0.136s
user    0m0.080s
sys   0m0.024s
</code></pre>

<h2>Java</h2>

<p>Code:</p>

<pre><code class="java">public class hello_java {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
</code></pre>

<p>Compile:</p>

<pre><code class="bash">$ javac hello_java.java
</code></pre>

<p>Run:</p>

<pre><code class="bash">$ time java hello_java
Hello, World!

real    0m0.114s
user    0m0.086s
sys   0m0.023s
</code></pre>

<h2>Resource:</h2>

<ul>
<li><a href="https://www.lifewire.com/command-return-time-command-4054237">https://www.lifewire.com/command-return-time-command-4054237</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang: Reading From Files and Writing to Disk With Arguments]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/03/02/golang-reading-from-files-and-writing-to-disk-with-arguments/"/>
    <updated>2018-03-02T07:11:13-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/03/02/golang-reading-from-files-and-writing-to-disk-with-arguments</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/VJmUZz.jpg" alt="" /></p>

<p>From our <a href="https://goo.gl/ih43uv">Previous Post</a> we wrote a basic golang app that reads the contents of a file and writes it back to disk, but in a static way as we defined the source and destination filenames in the code.</p>

<p>Today we will use arguments to specify what the source and destination filenames should be instead of hardcoding it.</p>

<h2>Our Golang Application:</h2>

<p>We will be using if statements to determine if the number of arguments provided is as expected, if not, then a usage string should be returned to stdout. Then we will loop through the list of arguments to determine what the values for our source and destination file should be.</p>

<p>Once it completes, it prints out the coice of filenames that was used:</p>

<pre><code class="go app.go">package main

import (
    "io/ioutil"
    "os"
    "fmt"
)

var (
    input_filename string
    output_filename string
)

func main() {

    if len(os.Args) &lt; 5 {
        fmt.Printf("Usage: (-i/--input) 'input_filename' (-o/--output) 'output_filename' \n")
        os.Exit(0)
    }

    for i, arg := range os.Args {
        if arg == "-i" || arg == "--input" {
            input_filename = os.Args[i+1]
            }
        if arg == "-o" || arg == "--output" {
            output_filename = os.Args[i+1]
            }
        }

    input_file_content, error := ioutil.ReadFile(input_filename)

    if error != nil {
        panic(error)
    }

    fmt.Println("File used for reading:", input_filename)

    ioutil.WriteFile(output_filename, input_file_content, 0644)
    fmt.Println("File used for writing:", output_filename)
}
</code></pre>

<p>Build your application:</p>

<pre><code class="bash">$ go build app.go
</code></pre>

<p>Run your application with no additional arguments to determine the expected behaviour:</p>

<pre><code class="bash">$ ./app
Usage: (-i/--input) 'input_filename' (-o/--output) 'output_file-to-write'
</code></pre>

<p>It works as expected, now create a source file, then run the application:</p>

<pre><code class="bash">$ echo $RANDOM &gt; myfile.txt
</code></pre>

<p>Run the application, and in this run, we will set the destination file as newfile.txt:</p>

<pre><code class="bash">$ ./app -i myfile.txt -o newfile.txt
File used for reading: myfile.txt
File used for writing: newfile.txt
</code></pre>

<p>Checking out the new file:</p>

<pre><code>$ cat newfile.txt
8568
</code></pre>
]]></content>
  </entry>
  
</feed>
