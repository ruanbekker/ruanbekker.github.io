<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Golang | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2018-11-21T17:38:31-05:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang: Building a Basic Web Server in Go]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/11/21/golang-building-a-basic-web-server-in-go/"/>
    <updated>2018-11-21T00:57:54-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/11/21/golang-building-a-basic-web-server-in-go</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/golang-web-server.png" alt="" /></p>

<p>Continuing with our <a href="https://blog.ruanbekker.com/blog/categories/golang-tutorial/">#golang-tutorial</a> blog series, in this post we will setup a Basic HTTP Server in Go.</p>

<h2>Our Web Server</h2>

<p>Our Web Server will respond on 2 Request Paths:</p>

<pre><code>- / -&gt; returns "Hello, Wolrd!"
- /cheers -&gt; returns "Goodbye!"
</code></pre>

<h2>Application Code</h2>

<p>If you have not setup your golang environment, you can do so by visiting <a href="https://medium.com/@AkyunaAkish/setting-up-a-golang-development-environment-mac-os-x-d58e5a7ea24f">@AkyunaAkish&rsquo;s Post on Setting up a Golang Development Enviornment on MacOSX</a>.</p>

<p>Create the <code>server.go</code> or any filename of your choice:</p>

<pre><code class="golang">package main

import (
    "io"
        "log"
    "net/http"
)

func hello(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/plain; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    io.WriteString(w, "Hello, World!" + "\n")
    log.Println("hello function handler was executed")
}

func goodbye(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/plain; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    io.WriteString(w, "Cheers!" + "\n")
    log.Println("goodbye function handler was executed")
}

func main() {
    http.HandleFunc("/", hello)
    http.HandleFunc("/cheers", goodbye)
    http.ListenAndServe(":8000", nil)
}
</code></pre>

<p>Explanation of what we are doing:</p>

<ul>
<li>Programs runs in the package <code>main</code></li>
<li>We are importing 3 packages: <code>io</code>, <code>log</code> and <code>net/http</code></li>
<li>HandleFunc registers the handler function for the given pattern in the DefaultServeMux, in this case the HandleFunc registers <code>/</code> to the <code>hello</code> handler function and <code>/cheers</code> to the goodbye handler function.</li>
<li>In our 2 handler functions, we have two arguments:

<ul>
<li>The first one is <code>http.ResponseWriter</code> and its corresponding response stream, which is actually an interface type.</li>
<li>The second is <code>*http.Request</code> and its corresponding HTTP request. <code>io.WriteString</code> is a helper function to let you write a string into a given writable stream, this is named the <code>io.Writer</code> interface in Golang.</li>
</ul>
</li>
<li>ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux</li>
<li>The logging is not a requirement, but used it for debugging/verbosity</li>
</ul>


<h2>Running our Server:</h2>

<p>Run the http server:</p>

<pre><code class="bash">$ go run server.go
</code></pre>

<h2>Client Side Requests:</h2>

<p>Run client side http requests to your golang web server:</p>

<pre><code class="bash">$ curl -i http://localhost:8000/
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Date: Wed, 21 Nov 2018 21:33:42 GMT
Content-Length: 14

Hello, World!
</code></pre>

<p>And another request to <code>/cheers</code>:</p>

<pre><code class="bash">$ curl -i http://localhost:8000/cheers
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Date: Wed, 21 Nov 2018 21:29:46 GMT
Content-Length: 8

Cheers!
</code></pre>

<h2>Server Side Output:</h2>

<p>As we used the log package, the logging gets returned to stdout:</p>

<pre><code class="bash">$ go run server.go
2018/11/21 23:29:36 hello function handler was executed
2018/11/21 23:29:46 goodbye function handler was executed
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://golang.org/doc/code.html">https://golang.org/doc/code.html</a></li>
<li><a href="https://gowalker.org/net/http#HandleFunc">https://gowalker.org/net/http#HandleFunc</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World Programs in Different Languages]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/06/09/hello-world-programs-in-different-languages/"/>
    <updated>2018-06-09T21:11:00-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/06/09/hello-world-programs-in-different-languages</id>
    <content type="html"><![CDATA[<p>This post will demonstrate running hello world programs in different languages and also providing return time statistics</p>

<h2>C++</h2>

<p>Code</p>

<pre><code class="c">#include &lt;iostream&gt;
using namespace std;

int main()
{
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>Compile:</p>

<pre><code class="bash">$ c++ hello_cpp.cpp -o hello_cpp
</code></pre>

<p>Run:</p>

<pre><code class="bash">$ time ./hello_cpp
Hello, World!

real    0m0.005s
user    0m0.001s
sys   0m0.001s
</code></pre>

<h2>Golang:</h2>

<p>Code</p>

<pre><code class="go">package main

import "fmt"

func main() {
  fmt.Println("Hello, World!")
}
</code></pre>

<p>Compile:</p>

<pre><code class="bash">$ go build hello_golang.go
</code></pre>

<p>Run:</p>

<pre><code class="bash">time ./hello_golang
Hello, World!

real    0m0.006s
user    0m0.001s
sys   0m0.003s
</code></pre>

<h2>Python</h2>

<p>Code:</p>

<pre><code class="python">#!/usr/bin/env python
print("Hello, World!")
</code></pre>

<p>Make it executable:</p>

<pre><code class="bash">$ chmod +x ./hello_python.py
</code></pre>

<p>Run:</p>

<pre><code class="bash">$ time ./hello_python.py
Hello, World!

real    0m0.033s
user    0m0.015s
sys   0m0.010s
</code></pre>

<h2>Ruby</h2>

<p>Code:</p>

<pre><code class="ruby">#!/usr/bin/env ruby
puts "Hello, World!"
</code></pre>

<p>Make it executable:</p>

<pre><code class="bash">$ chmod +x ./hello_ruby.rb
</code></pre>

<p>Run:</p>

<pre><code class="bash">$ time ./hello_ruby.rb
Hello, World!

real    0m0.136s
user    0m0.080s
sys   0m0.024s
</code></pre>

<h2>Java</h2>

<p>Code:</p>

<pre><code class="java">public class hello_java {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
</code></pre>

<p>Compile:</p>

<pre><code class="bash">$ javac hello_java.java
</code></pre>

<p>Run:</p>

<pre><code class="bash">$ time java hello_java
Hello, World!

real    0m0.114s
user    0m0.086s
sys   0m0.023s
</code></pre>

<h2>Resource:</h2>

<ul>
<li><a href="https://www.lifewire.com/command-return-time-command-4054237">https://www.lifewire.com/command-return-time-command-4054237</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang: Reading From Files and Writing to Disk With Arguments]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/03/02/golang-reading-from-files-and-writing-to-disk-with-arguments/"/>
    <updated>2018-03-02T07:11:13-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/03/02/golang-reading-from-files-and-writing-to-disk-with-arguments</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/VJmUZz.jpg" alt="" /></p>

<p>From our <a href="https://goo.gl/ih43uv">Previous Post</a> we wrote a basic golang app that reads the contents of a file and writes it back to disk, but in a static way as we defined the source and destination filenames in the code.</p>

<p>Today we will use arguments to specify what the source and destination filenames should be instead of hardcoding it.</p>

<h2>Our Golang Application:</h2>

<p>We will be using if statements to determine if the number of arguments provided is as expected, if not, then a usage string should be returned to stdout. Then we will loop through the list of arguments to determine what the values for our source and destination file should be.</p>

<p>Once it completes, it prints out the coice of filenames that was used:</p>

<pre><code class="go app.go">package main

import (
    "io/ioutil"
    "os"
    "fmt"
)

var (
    input_filename string
    output_filename string
)

func main() {

    if len(os.Args) &lt; 5 {
        fmt.Printf("Usage: (-i/--input) 'input_filename' (-o/--output) 'output_filename' \n")
        os.Exit(0)
    }

    for i, arg := range os.Args {
        if arg == "-i" || arg == "--input" {
            input_filename = os.Args[i+1]
            }
        if arg == "-o" || arg == "--output" {
            output_filename = os.Args[i+1]
            }
        }

    input_file_content, error := ioutil.ReadFile(input_filename)

    if error != nil {
        panic(error)
    }

    fmt.Println("File used for reading:", input_filename)

    ioutil.WriteFile(output_filename, input_file_content, 0644)
    fmt.Println("File used for writing:", output_filename)
}
</code></pre>

<p>Build your application:</p>

<pre><code class="bash">$ go build app.go
</code></pre>

<p>Run your application with no additional arguments to determine the expected behaviour:</p>

<pre><code class="bash">$ ./app
Usage: (-i/--input) 'input_filename' (-o/--output) 'output_file-to-write'
</code></pre>

<p>It works as expected, now create a source file, then run the application:</p>

<pre><code class="bash">$ echo $RANDOM &gt; myfile.txt
</code></pre>

<p>Run the application, and in this run, we will set the destination file as newfile.txt:</p>

<pre><code class="bash">$ ./app -i myfile.txt -o newfile.txt
File used for reading: myfile.txt
File used for writing: newfile.txt
</code></pre>

<p>Checking out the new file:</p>

<pre><code>$ cat newfile.txt
8568
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang: Reading From Files and Writing to Disk With Golang]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/03/02/golang-reading-from-files-and-writing-to-disk-with-golang/"/>
    <updated>2018-03-02T06:44:59-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/03/02/golang-reading-from-files-and-writing-to-disk-with-golang</id>
    <content type="html"><![CDATA[<p><img src="![](https://i.snag.gy/VJmUZz.jpg" alt="" />)</p>

<p>Today we will create a very basic application to read content from a file, and write the content from the file back to disk, but to another filename.</p>

<p>Basically, doing a copy of the file to another filename.</p>

<h2>Golang Environment: Golang Docker Image</h2>

<p>Dropping into a Golang Environment using Docker:</p>

<pre><code class="bash">$ docker run -it golang:alpine sh
</code></pre>

<h2>Our Golang Application</h2>

<p>After we are in our container, lets write our app:</p>

<pre><code class="go app.go">package main

import (
    "io/ioutil"
)

func main() {

    content, error := ioutil.ReadFile("source-data.txt")
    if error != nil {
        panic(error)
    }

    error = ioutil.WriteFile("destination-data.txt", content, 0644)
    if error != nil {
        panic(error)
    }
}
</code></pre>

<p>Building our application to a binary:</p>

<pre><code class="bash">$ go build app.go
</code></pre>

<p>Creating our <code>source-data.txt</code> :</p>

<pre><code class="bash">$ echo "foo" &gt; source-data.txt
</code></pre>

<h2>Running the Golang App:</h2>

<p>When we run this app, it will read the content of <code>source-data.txt</code> and write it to <code>destination-data.txt</code>:</p>

<pre><code class="bash">$ ./app.go
</code></pre>

<p>We can see that the file has been written to disk:</p>

<pre><code class="bash">$ ls | grep data
destination-data.txt
source-data.txt
</code></pre>

<p>Making sure the data is the same, we can do a <code>md5sum hash</code> function on them:</p>

<pre><code class="bash">$ md5sum source-data.txt
d3b07384d113edec49eaa6238ad5ff00  source-data.txt

$ md5sum destination-data.txt
d3b07384d113edec49eaa6238ad5ff00  destination-data.txt
</code></pre>

<h2>Next:</h2>

<p>This was a very static way of doing it, as you need to hardcode the filenames. In the <a href="https://goo.gl/t8fasN">next post</a> I will show how to use arguments to make it more dynamic.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Basic Concourse Pipeline With Bash and Golang Jobs]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/11/24/basic-concourse-pipeline-with-bash-and-golang-jobs/"/>
    <updated>2017-11-24T18:38:15-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/11/24/basic-concourse-pipeline-with-bash-and-golang-jobs</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/gzkdu9.jpg?nocache=1511644783495" alt="" /></p>

<p>From one of my previous posts, we went through the steps to setup a <a href="http://blog.ruanbekker.com/blog/2017/11/07/setup-a-concourse-ci-server-on-ubuntu-16/">Concourse CI Server on Ubuntu</a> .</p>

<h2>What are we doing today?</h2>

<p>Today we will setup a basic pipeline that executes 2 jobs, one using a alpine container that runs a couple of shell commands, and the other job will be using a Golang container to build and execute a golang app. I will also be experimenting with auto trigger, that will trigger the pipeline to run its jobs every 60 seconds.</p>

<p>Our Pipeline will look like the following:</p>

<p><img src="https://i.snag.gy/D0oO4M.jpg" alt="" /></p>

<h2>Our Pipeline Definition:</h2>

<pre><code class="yml bash-and-golang.yml">resources:
- name: container-resource
  type: time
  source:
    interval: 60m

jobs:
- name: my-alpine-job
  plan:
  - get: container-resource
    trigger: true
  - task: vanilla-alpine-tasks
    params:
      OWNER: ruan
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: alpine
          tag: edge
      run:
        path: /bin/sh
        args:
        - -c
        - |
          apk update &gt; /dev/null
          apk upgrade &gt; /dev/null
          apk add curl &gt; /dev/null
          echo "Public IP is: `curl -s http://ip.ruanbekker.com`"
          echo "Hostname is: $HOSTNAME"
          echo "Owner is: $OWNER"
          echo foo &gt; /tmp/word.txt
          export MAGIC_WORD=`cat /tmp/word.txt`
          echo "Magic word is $MAGIC_WORD"
          cat &gt; app.sh &lt;&lt; EOF
          #!/usr/bin/env sh
          echo "Hello, World!"
          EOF
          chmod +x app.sh
          echo "Shell Script Executing:"
          ./app.sh

- name: my-golang-job
  plan:
  - get: container-resource
    trigger: true
  - task: golang-tasks
    params:
      OWNER: james
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: golang
          tag: '1.6'
      run:
        path: /bin/sh
        args:
        - -c
        - |
          echo "User: `whoami`"
          echo "Go Version: `go version`"
          echo "Hostname is: $HOSTNAME"
          echo "Owner is: $OWNER"
          echo bar &gt; /tmp/word.txt
          export MAGIC_WORD=`cat /tmp/word.txt`
          echo "Magic word is $MAGIC_WORD"
          cat &gt; app.go &lt;&lt; EOF
          package main

          import "fmt"

          func main() {
            fmt.Println("Hello, World!")
          }
          EOF
          go build app.go
          echo "Go App Executing:"
          ./app
</code></pre>

<h2>Login to Concourse:</h2>

<p>Logon to concourse and set your target:</p>

<pre><code class="bash">$ fly -t ci login --concourse-url=http://10.20.30.40:8080
logging in to team 'main'

username: admin
password:

target saved
</code></pre>

<p>List your targets:</p>

<pre><code class="bash">$ fly targets
name      url                       team  expiry
ci        http://10.20.30.40:8080   main  Sat, 25 Nov 2017 23:30:55 UTC
</code></pre>

<h2>Apply Configuration</h2>

<p>Apply your Configuration:</p>

<pre><code class="bash">$ fly -t ci set-pipeline -p bash-and-golang -c bash-and-golang.yml

apply configuration? [yN]: y
pipeline created!
you can view your pipeline here: http://10.20.30.40:8080/teams/main/pipelines/bash-and-golang

the pipeline is currently paused. to unpause, either:
  - run the unpause-pipeline command
  - click play next to the pipeline in the web ui
</code></pre>

<h2>Unpause</h2>

<p>Unpause your Pipeline:</p>

<pre><code class="bash">$ fly -t ci unpause-pipeline -p bash-and-golang
unpaused 'bash-and-golang'
</code></pre>

<h2>Trigger</h2>

<p>Trigger your first job, which will be the Alpine job:</p>

<pre><code class="bash">$ fly -t ci trigger-job --job bash-and-golang/my-alpine-job
started bash-and-golang/my-alpine-job #2
</code></pre>

<p><img src="https://i.snag.gy/x7ksQO.jpg?nocache=1511567544851" alt="" /></p>

<p>Trigger your second job, which will be the Golang job:</p>

<pre><code class="bash">$ fly -t ci trigger-job --job bash-and-golang/my-golang-job
started bash-and-golang/my-golang-job #2
</code></pre>

<p><img src="https://i.snag.gy/07nDiZ.jpg" alt="" /></p>

<p>Remember, we can also monitor the output from the shell:</p>

<pre><code class="bash">$ fly -t ci trigger-job --job bash-and-golang/my-golang-job --watch
started bash-and-golang/my-golang-job #3

initializing
running /bin/sh -c echo "User: `whoami`"
echo "Go Version: `go version`"
echo "Hostname is: $HOSTNAME"
echo "Owner is: $OWNER"
echo bar &gt; /tmp/word.txt
export MAGIC_WORD=`cat /tmp/word.txt`
echo "Magic word is $MAGIC_WORD"
cat &gt; app.go &lt;&lt; EOF
package main

import "fmt"

func main() {
  fmt.Println("Hello, World!")
}
EOF
go build app.go
echo "Go App Executing:"
./app

User: root
Go Version: go version go1.6.4 linux/amd64
Hostname is:
Owner is: james
Magic word is bar
Go App Executing:
Hello, World!
succeeded
</code></pre>

<p>And you can also debug the job by dropping yourself into the container by using hijack:</p>

<pre><code>$ fly -t ci hijack --job bash-and-golang/my-golang-job
</code></pre>
]]></content>
  </entry>
  
</feed>
