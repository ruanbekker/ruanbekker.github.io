<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Grafana | Ruan Bekker's Blog]]></title>
  <link href="https://blog.ruanbekker.com/blog/categories/grafana/atom.xml" rel="self"/>
  <link href="https://blog.ruanbekker.com/"/>
  <updated>2023-07-15T17:32:39-04:00</updated>
  <id>https://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Logging With Docker Promtail and Grafana Loki]]></title>
    <link href="https://blog.ruanbekker.com/blog/2022/11/18/logging-with-docker-promtail-and-grafana-loki/"/>
    <updated>2022-11-18T00:42:49-05:00</updated>
    <id>https://blog.ruanbekker.com/blog/2022/11/18/logging-with-docker-promtail-and-grafana-loki</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/202631247-4ee94f01-b34a-471f-b428-6aba80b31e8c.png" alt="grafana-loki-promtail" /></p>

<p>In this post we will use Grafana Promtail to collect all our logs and ship it to Grafana Loki.</p>

<h2>About</h2>

<p>We will be using Docker Compose and mount the docker socket to Grafana Promtail so that it is aware of all the docker events and configure it that only containers with docker labels <code>logging=promtail</code> needs to be enabled for logging, which will then scrape those logs and send it to Grafana Loki where we will visualize it in Grafana.</p>

<h2>Promtail</h2>

<p>In our promtail configuration <code>config/promtail.yaml</code>:</p>

<pre><code class="yaml"># https://grafana.com/docs/loki/latest/clients/promtail/configuration/
# https://docs.docker.com/engine/api/v1.41/#operation/ContainerList
server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /tmp/positions.yaml

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: flog_scrape 
    docker_sd_configs:
      - host: unix:///var/run/docker.sock
        refresh_interval: 5s
        filters:
          - name: label
            values: ["logging=promtail"] 
    relabel_configs:
      - source_labels: ['__meta_docker_container_name']
        regex: '/(.*)'
        target_label: 'container'
      - source_labels: ['__meta_docker_container_log_stream']
        target_label: 'logstream'
      - source_labels: ['__meta_docker_container_label_logging_jobname']
        target_label: 'job'
</code></pre>

<p>You can see we are using the <code>docker_sd_configs</code> provider and filter only docker containers with the docker labels <code>logging=promtail</code> and once we have those logs we relabel our labels to have the container name and we also use docker labels like <code>log_stream</code> and <code>logging_jobname</code> to add labels to our logs.</p>

<h2>Grafana Config</h2>

<p>We would like to auto configure our datasources for Grafana and in <code>config/grafana-datasources.yml</code> we have:</p>

<pre><code class="yaml">apiVersion: 1

datasources:
  - name: Loki
    type: loki
    access: proxy
    url: http://loki:3100
    version: 1
    editable: false
    isDefault: true
</code></pre>

<h2>Docker Compose</h2>

<p>Then lastly we have our <code>docker-compose.yml</code> that wire up all our containers:</p>

<pre><code class="yaml">version: '3.8'

services:
  nginx-app:
    container_name: nginx-app
    image: nginx
    labels:
      logging: "promtail"
      logging_jobname: "containerlogs"
    ports:
      - 8080:80
    networks:
      - app

  grafana:
    image: grafana/grafana:latest
    ports:
      - 3000:3000
    volumes:
      - ./config/grafana-datasources.yml:/etc/grafana/provisioning/datasources/datasources.yaml
    environment:
      - GF_AUTH_ANONYMOUS_ENABLED=true
      - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin
      - GF_AUTH_DISABLE_LOGIN_FORM=true
    networks:
      - app

  loki:
    image: grafana/loki:latest
    ports:
      - 3100:3100
    command: -config.file=/etc/loki/local-config.yaml
    networks:
      - app

  promtail:
    image:  grafana/promtail:latest
    container_name: promtail
    volumes:
      - ./config/promtail.yaml:/etc/promtail/docker-config.yaml
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock
    command: -config.file=/etc/promtail/docker-config.yaml
    depends_on:
      - loki
    networks:
      - app

networks:
  app:
    name: app
</code></pre>

<p>As you can see with our nginx container we define our labels:</p>

<pre><code class="yaml">  nginx-app:
    container_name: nginx-app
    image: nginx
    labels:
      logging: "promtail"
      logging_jobname: "containerlogs"
</code></pre>

<p>Which uses <code>logging: "promtail"</code> to let promtail know this log container&rsquo;s log to be scraped and <code>logging_jobname: "containerlogs"</code> which will assign containerlogs to the job label.</p>

<h2>Start the stack</h2>

<p>If you are following along all this configuration is available in my github repository <a href="https://github.com/ruanbekker/docker-promtail-loki">https://github.com/ruanbekker/docker-promtail-loki</a> .</p>

<p>Once you have everything in place you can start it with:</p>

<pre><code class="bash">docker-compose up -d
</code></pre>

<p>Access nginx on <a href="http://localhost:8080">http://localhost:8080</a></p>

<p><img width="1113" alt="image" src="https://user-images.githubusercontent.com/567298/202505252-3cbc2d03-d1d2-48e6-bea7-5db54233b9a2.png"></p>

<p>Then navigate to grafana on <a href="http://localhost:3000">http://localhost:3000</a> and select explore on the left and select the container:</p>

<p><img width="560" alt="image" src="https://user-images.githubusercontent.com/567298/202504989-e05a08a2-eb2f-41a1-85f4-9a11a8affd7c.png"></p>

<p>And you will see the logs:</p>

<p><img width="1425" alt="image" src="https://user-images.githubusercontent.com/567298/202505099-c47b76cc-3090-4eb9-8459-db659d0aac18.png"></p>

<h2>Thank You</h2>

<p>Thanks for reading, feel free to check out my <a href="https://ruan.dev/">website</a>, feel free to subscribe to my <a href="http://digests.ruanbekker.com/?via=ruanbekker-blog">newsletter</a> or follow me at <a href="https://twitter.com/ruanbekker">@ruanbekker</a> on Twitter.</p>

<ul>
<li>Linktree: <a href="https://go.ruan.dev/links">https://go.ruan.dev/links</a></li>
<li>Patreon: <a href="https://go.ruan.dev/patreon">https://go.ruan.dev/patreon</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generate Grafana Loki Log Links From Metric Label Values]]></title>
    <link href="https://blog.ruanbekker.com/blog/2021/03/10/generate-grafana-loki-log-links-from-metric-label-values/"/>
    <updated>2021-03-10T00:34:04-05:00</updated>
    <id>https://blog.ruanbekker.com/blog/2021/03/10/generate-grafana-loki-log-links-from-metric-label-values</id>
    <content type="html"><![CDATA[<p>In this tutorial we will generate Loki Log links from selected dropdown template variables in a Grafana Dashboard.</p>

<h2>Context</h2>

<p>To give more context, we have a Grafana Dashboard with all our services, and when you select that service you see all the metrics of that service, now if you want to see the logs of that service, the selected label values will be parsed to a log link which you can click and it will take you to the Loki Explorer and parse the label values to the log link, so your logql will already be generated for you.</p>

<p>In order to achieve this, our metrics and logs need to share the same labels and label values (environment, container_name) etc.</p>

<h2>Dashboard Variables</h2>

<p>First we have our environment variable:</p>

<p><img src="https://user-images.githubusercontent.com/567298/109668240-a6862300-7b79-11eb-85ce-d381edfbe78e.png" alt="image" /></p>

<p>And here we have our service variable:</p>

<p><img src="https://user-images.githubusercontent.com/567298/109668438-dc2b0c00-7b79-11eb-9b17-629e9b1716a9.png" alt="image" /></p>

<p>Then for our container_name we have:</p>

<p><img src="https://user-images.githubusercontent.com/567298/109668632-05e43300-7b7a-11eb-97a0-8ff81f0c929c.png" alt="image" /></p>

<p>Notice the <code>/^(.*?)-[0-9]/</code> thats just to strip the end, if we remove it it will be:</p>

<p><img src="https://user-images.githubusercontent.com/567298/109668778-27451f00-7b7a-11eb-976f-a7d0b473cd1b.png" alt="image" /></p>

<h2>Grafana Dashboard</h2>

<p>Now when we select the environment, service, we get presented with a Loki LogURL:</p>

<p><img src="https://user-images.githubusercontent.com/567298/109668970-552a6380-7b7a-11eb-8c72-b284cf0f5eec.png" alt="image" /></p>

<p>If we look at our dashboard links, under the dashboard settings:</p>

<p><img src="https://user-images.githubusercontent.com/567298/109669065-6b382400-7b7a-11eb-8a29-34b492fef327.png" alt="image" /></p>

<p>The Logs Uri is:</p>

<pre><code>https://grafana.mydomain.com/explore?orgId=1&amp;left=%5B%22now-1h%22,%22now%22,%22Loki%22,%7B%22expr%22:%22%7Bcontainer_name%3D~%5C%22.*$container_name.*%5C%22%7D%22%7D,%7B%22mode%22:%22Logs%22%7D,%7B%22ui%22:%5Btrue,true,true,%22none%22%5D%7D%5D
</code></pre>

<p>Now when we select our label values from the dropdown for our service and we follow the link we will get:</p>

<p><img src="https://user-images.githubusercontent.com/567298/109669297-a33f6700-7b7a-11eb-8205-f021467af751.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visualize Weather Data With Grafana and the DHT22 Sensor]]></title>
    <link href="https://blog.ruanbekker.com/blog/2021/03/10/visualize-weather-data-with-grafana-and-the-dht22-sensor/"/>
    <updated>2021-03-10T00:06:31-05:00</updated>
    <id>https://blog.ruanbekker.com/blog/2021/03/10/visualize-weather-data-with-grafana-and-the-dht22-sensor</id>
    <content type="html"><![CDATA[<p>In this tutorial, we will connect the <a href="https://learn.adafruit.com/dht">DHT22</a> sensor to the Raspberry Pi Zero via the GPIO pins to measure temperature and humidity and visualize it with Grafana.</p>

<p><em>Note</em>: This post was originally posted on my <a href="https://blog.pistack.co.za/monitor-temperature-with-the-dht22-sensor-on-the-raspberry-pi/">RaspberryPi Blog</a></p>

<p>Then we will write a Python exporter for prometheus to expose our metrics so that we can visualize it in Grafana.</p>

<h2>The Endgoal</h2>

<p><img src="https://user-images.githubusercontent.com/30043398/104296987-fd9d3f00-54ca-11eb-8623-f3fd4a63e3cc.png" alt="image" /></p>

<h2>The Hardware</h2>

<p>This is how the sensor looks like (I got it from <a href="https://www.communica.co.za/products/bmt-temp-humd-snsr-dht22-on-pcb">Communica</a>)</p>

<p><img src="https://user-images.githubusercontent.com/567298/103872941-ba605c00-50d7-11eb-9f60-531995a185e6.png" alt="image" /></p>

<h2>Connecting the Sensor</h2>

<p>You can use the following graphic to connect your sensor to your raspberry pi:</p>

<p><img src="https://user-images.githubusercontent.com/567298/103873892-27c0bc80-50d9-11eb-9c41-3f3b2ff5aee2.png" alt="image" /></p>

<h2>Installing Software</h2>

<p>To install the required software, we will be using pip:</p>

<pre><code>$ pip3 install Adafruit_DHT --user
</code></pre>

<p>Once we installed the software we can configure it</p>

<h2>Interact with the Sensor</h2>

<p>Enter your python interpreter:</p>

<pre><code>$ python3
&gt;&gt;&gt;
</code></pre>

<p>Then import the library, and get the current temperature and humidity:</p>

<pre><code>&gt;&gt;&gt; import Adafruit_DHT as dht
&gt;&gt;&gt; humidity, temperature = dht.read_retry(dht.DHT22, 4)
&gt;&gt;&gt; humidity = format(humidity, ".2f") + "%"
&gt;&gt;&gt; humidity
'47.20%'
&gt;&gt;&gt; temperature = format(temperature, ".2f") + "C"
&gt;&gt;&gt; temperature
'29.10C'
</code></pre>

<p>Let&rsquo;s create a python script for it:</p>

<pre><code>$ cat temps.py
#!/usr/bin/env python3

import Adafruit_DHT as dht_sensor
import time

def get_temperature_readings():
    humidity, temperature = dht_sensor.read_retry(dht_sensor.DHT22, 4)
    humidity = format(humidity, ".2f") + "%"
    temperature = format(temperature, ".2f") + "C"
    return {"temperature": temperature, "humidity": humidity}

while True:
    print(get_temperature_readings())
    time.sleep(30)
</code></pre>

<p>And run it:</p>

<pre><code>$ python3 temps.py
{'temperature': '28.00C', 'humidity': '47.40%'}
{'temperature': '28.00C', 'humidity': '47.30%'}
{'temperature': '28.00C', 'humidity': '47.70%'}
{'temperature': '28.00C', 'humidity': '47.40%'}
{'temperature': '28.00C', 'humidity': '47.60%'}
</code></pre>

<h2>Visualize with Grafana</h2>

<p>Let&rsquo;s visualize our data with Grafana. For this, we need to write an exporter so that Prometheus can scrape the data.</p>

<p>Let&rsquo;s create a python flask application with the prometheus client library for python to expose the metrics to prometheus with a <code>/metrics</code> endpoint.</p>

<p>Note: I have used <a href="https://openweathermap.org/api">OpenWeatherMap</a>&rsquo;s API to get the outside temperature for my location.</p>

<pre><code>$ cat flask_temps.py
#!/usr/bin/env python3

import Adafruit_DHT as dht_sensor
import time
from flask import Flask, Response
from prometheus_client import Counter, Gauge, start_http_server, generate_latest
import requests

params = {"lat": "-xx.xxxxx", "lon": "xx.xxxx", "units": "metric", "appid": "your-api-key"}
baseurl = "https://api.openweathermap.org/data/2.5/weather"
content_type = str('text/plain; version=0.0.4; charset=utf-8')

def get_temperature_readings():
    humidity, temperature = dht_sensor.read_retry(dht_sensor.DHT22, 4)
    humidity = format(humidity, ".2f")
    temperature = format(temperature, ".2f")
    outside_temp = get_outside_weather()
    if all(v is not None for v in [humidity, temperature, outside_temp]):
        response = {"temperature": temperature, "humidity": humidity, "outside_temp": outside_temp}
        return response
    else:
        time.sleep(0.2)
        humidity, temperature = dht_sensor.read_retry(dht_sensor.DHT22, 4)
        humidity = format(humidity, ".2f")
        temperature = format(temperature, ".2f")
        outside_temp = get_outside_weather()
        response = {"temperature": temperature, "humidity": humidity, "outside_temp": outside_temp}
        return response

def get_outside_weather():
    response = requests.get(baseurl, params=params)
    temp = response.json()['main']['temp']
    return temp

app = Flask(__name__)

current_humidity = Gauge(
        'current_humidity',
        'the current humidity percentage, this is a gauge as the value can increase or decrease',
        ['room']
)

current_temperature = Gauge(
        'current_temperature',
        'the current temperature in celsius, this is a gauge as the value can increase or decrease',
        ['room']
)

current_temperature_outside = Gauge(
        'current_temperature_outside',
        'the current outside temperature in celsius, this is a gauge as the value can increase or decrease',
        ['location']
)

@app.route('/metrics')
def metrics():
    metrics = get_temperature_readings()
    current_humidity.labels('study').set(metrics['humidity'])
    current_temperature.labels('study').set(metrics['temperature'])
    current_temperature_outside.labels('za_ct').set(metrics['outside_temp'])
    return Response(generate_latest(), mimetype=content_type)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
</code></pre>

<p>Then install the flask and prometheus_client package:</p>

<pre><code>$ python3 -m pip install flask prometheus_client --user
</code></pre>

<p>When you run the program, you should be able to retrieve metrics from the exporter by making a request on port 5000 on the <code>/metrics</code> request path:</p>

<pre><code>$ curl http://localhost:5000/metrics
# HELP python_gc_objects_collected_total Objects collected during gc
# TYPE python_gc_objects_collected_total counter
python_gc_objects_collected_total{generation="0"} 646.0
python_gc_objects_collected_total{generation="1"} 129.0
python_gc_objects_collected_total{generation="2"} 0.0
# HELP python_gc_objects_uncollectable_total Uncollectable object found during GC
# TYPE python_gc_objects_uncollectable_total counter
python_gc_objects_uncollectable_total{generation="0"} 0.0
python_gc_objects_uncollectable_total{generation="1"} 0.0
python_gc_objects_uncollectable_total{generation="2"} 0.0
# HELP python_gc_collections_total Number of times this generation was collected
# TYPE python_gc_collections_total counter
python_gc_collections_total{generation="0"} 104.0
python_gc_collections_total{generation="1"} 9.0
python_gc_collections_total{generation="2"} 0.0
# HELP python_info Python platform information
# TYPE python_info gauge
python_info{implementation="CPython",major="3",minor="7",patchlevel="3",version="3.7.3"} 1.0
# HELP process_virtual_memory_bytes Virtual memory size in bytes.
# TYPE process_virtual_memory_bytes gauge
process_virtual_memory_bytes 4.4761088e+07
# HELP process_resident_memory_bytes Resident memory size in bytes.
# TYPE process_resident_memory_bytes gauge
process_resident_memory_bytes 2.7267072e+07
# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.
# TYPE process_start_time_seconds gauge
process_start_time_seconds 1.61044381853e+09
# HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.
# TYPE process_cpu_seconds_total counter
process_cpu_seconds_total 5.86
# HELP process_open_fds Number of open file descriptors.
# TYPE process_open_fds gauge
process_open_fds 6.0
# HELP process_max_fds Maximum number of open file descriptors.
# TYPE process_max_fds gauge
process_max_fds 1024.0
# HELP current_humidity the current humidity percentage, this is a gauge as the value can increase or decrease
# TYPE current_humidity gauge
current_humidity{room="study"} 47.0
# HELP current_temperature the current temperature in celsius, this is a gauge as the value can increase or decrease
# TYPE current_temperature gauge
current_temperature{room="study"} 25.7
# HELP current_temperature_outside the current outside temperature in celsius, this is a gauge as the value can increase or decrease
# TYPE current_temperature_outside gauge
current_temperature_outside{location="za_ct"} 27.97
</code></pre>

<p>Now to configure our prometheus scrape config to scrape our endpoint:</p>

<pre><code>$ cat /etc/prometheus/prometheus.yml
...
scrape_configs:
  - job_name: 'temperature-exporter'
    scrape_interval: 15s
    static_configs:
    - targets: ['192.168.0.5:5000']
      labels:
        instance: 'pi-zero'
        room: 'study'
</code></pre>

<p>Then restart prometheus and head over to Grafana.</p>

<p>We will be adding a new panel with a graph visualization, and from our prometheus datasource, we will be referencing the 2 metrics (different from the screenshot):</p>

<pre><code>current_humidity{room="study"} 47.0
current_temperature{room="study"} 25.7
current_temperature_outside{location="za_ct"} 27.97
</code></pre>

<p>As can be seen below:</p>

<p><img src="https://user-images.githubusercontent.com/567298/103987136-a169b080-5194-11eb-8a61-6d36f45caf5c.png" alt="image" /></p>

<p>After a bit of customization, you can get something more or less like this:</p>

<p><img src="https://user-images.githubusercontent.com/30043398/104296987-fd9d3f00-54ca-11eb-8623-f3fd4a63e3cc.png" alt="image" /></p>

<h2>Thank You</h2>

<p>Thanks for reading, if you like my content feel free to visit my website <strong><a href="https://ruan.dev">ruan.dev</a></strong> or follow me on Twitter <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Setup Alerting With Loki]]></title>
    <link href="https://blog.ruanbekker.com/blog/2020/11/06/how-to-setup-alerting-with-loki/"/>
    <updated>2020-11-06T15:13:53+00:00</updated>
    <id>https://blog.ruanbekker.com/blog/2020/11/06/how-to-setup-alerting-with-loki</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/98380823-bd948880-2051-11eb-8ab4-c8d5f5d3e612.png" alt="image" /></p>

<p>Recently Grafana Labs announced <strong><a href="https://grafana.com/blog/2020/10/28/loki-2.0-released-transform-logs-as-youre-querying-them-and-set-up-alerts-within-loki/">Loki v2</a></strong> and its awesome! Definitely check out their blog post on more details.</p>

<p>Loki has a index option called <strong>boltdb-shipper</strong>, which allows you to run Loki with only a object store and you <strong>no longer need a dedicated index store</strong> such as DynamoDB. You can extract labels from log lines at query time, which is CRAZY! And I really like how they&rsquo;ve implemented it, you can parse, filter and format like mad. I really like that.</p>

<p>And then generating alerts from any query, which we will go into today. Definitely check out <a href="https://grafana.com/blog/2020/10/28/loki-2.0-released-transform-logs-as-youre-querying-them-and-set-up-alerts-within-loki/">this blogpost</a> and <a href="https://grafana.com/blog/2020/11/04/video-top-three-features-of-the-new-loki-2.0/">this video</a> for more details on the features of Loki v2.</p>

<h2>What will we be doing today</h2>

<p>In this tutorial we will setup a alert using the Loki local ruler to alert us when we have <strong>high number of log events coming in</strong>. For example, let&rsquo;s say someone has debug logging enabled in their application and we want to send a alert to slack when it breaches the threshold.</p>

<p>I will simulate this with a <code>http-client</code> container which runs <code>curl</code> in a while loop to fire a bunch of http requests against the nginx container which logs to Loki, so we can see how the alerting works, and in this scenario we will alert to Slack.</p>

<p>And after that we will stop our http-client container to see how the alarm resolves when the log rate comes down again.</p>

<p>All the components are available in the <code>docker-compose.yml</code> on my <a href="https://github.com/ruanbekker/loki-alerts-docker">github repository</a></p>

<h2>Components</h2>

<p>Let&rsquo;s break it down and start with the loki config:</p>

<pre><code>...
ruler:
  storage:
    type: local
    local:
      directory: /etc/loki/rules
  rule_path: /tmp/loki/rules-temp
  alertmanager_url: http://alertmanager:9093
  ring:
    kvstore:
      store: inmemory
  enable_api: true
  enable_alertmanager_v2: true
</code></pre>

<p>In the section of the loki config, I will be making use of the local ruler and map my alert rules under <code>/etc/loki/rules/</code> and we are also defining our alertmanager instance where these alerts should be shipped to.</p>

<p>In my rule definition <code>/etc/loki/rules/demo/rules.yml</code>:</p>

<pre><code>groups:
  - name: rate-alerting
    rules:
      - alert: HighLogRate
        expr: |
          sum by (compose_service)
            (rate({job="dockerlogs"}[1m]))
            &gt; 60
        for: 1m
        labels:
            severity: warning
            team: devops
            category: logs
        annotations:
            title: "High LogRate Alert"
            description: "something is logging a lot"
            impact: "impact"
            action: "action"
            dashboard: "https://grafana.com/service-dashboard"
            runbook: "https://wiki.com"
            logurl: "https://grafana.com/log-explorer"
</code></pre>

<p>In my expression, I am using LogQL to return per second rate of all my docker logs within the last minute per compose service for my dockerlogs job and we are specifying that it should alert when the threshold is above 60.</p>

<p>As you can see I have a couple of <strong>labels and annotations</strong>, which becomes <strong>very useful</strong> when you have dashboard links, runbooks etc and you would like to map that to your alert. I am doing the mapping in my <code>alertmanager.yml</code> config:</p>

<pre><code>route:
...
  receiver: 'default-catchall-slack'
  routes:
  - match:
      severity: warning
    receiver: warning-devops-slack
    routes:
    - match_re:
        team: .*(devops).*
      receiver: warning-devops-slack

receivers:
...
- name: 'warning-devops-slack'
  slack_configs:
    - send_resolved: true
      channel: '__SLACK_CHANNEL__'
      title: '{{ if eq .Status "firing" }}:fire:{{ else }}:white_check_mark:{{ end }} [{{ .Status | toUpper }}] {{ .CommonAnnotations.title }} '
      text: &gt;-
        {{ range .Alerts }}
          *Description:* {{ .Annotations.description }}
          *Severity:* `{{ .Labels.severity }}`
          *Graph:* {{ if eq .Labels.category "logs" }}&lt;{{ .Annotations.logurl }}|:chart_with_upwards_trend:&gt;{{ else }}&lt;{{ .GeneratorURL }}|:chart_with_upwards_trend:&gt;{{ end }} *Dashboard:* &lt;{{ .Annotations.dashboard }}|:bar_chart:&gt; *Runbook:* &lt;{{ .Annotations.runbook }}|:spiral_note_pad:&gt;
          *Details:*
          {{ range .Labels.SortedPairs }} - *{{ .Name }}:* `{{ .Value }}`
          {{ end }}
           - *Impact*: {{ .Annotations.impact }}
           - *Receiver*: warning-{{ .Labels.team }}-slack
        {{ end }}
</code></pre>

<p>As you can see, when my alert matches nothing it will go to my catchall receiver, but when my label contains <code>devops</code> and the route the alert to my <code>warning-devops-slack</code> receiver, and then we will be parsing our labels and annotations to include the values in our alarm on slack.</p>

<h2>Demo</h2>

<p>Enough with the background details, and it&rsquo;s time to get into the action.</p>

<p>All the code for this demonstration will be available in my github repository: <strong><a href="https://github.com/ruanbekker/loki-alerts-docker">github.com/ruanbekker/loki-alerts-docker</a></strong></p>

<p>The docker-compose will have a container of <strong>grafana</strong>, <strong>alertmanager</strong>, <strong>loki</strong>, <strong>nginx</strong> and a <strong>http-client</strong>.</p>

<p>The http-client is curl in a while loop that will just make a bunch of http requests against the nginx container, which will be logging to loki.</p>

<h2>Get the source</h2>

<p>Get the code from my github repository:</p>

<pre><code>$ git clone https://github.com/ruanbekker/loki-alerts-docker
$ cd loki-alerts-docker
</code></pre>

<p>You will need to replace the slack webhook url and the slack channel where you want your alerts to be sent to. This will take the environment variables and replace the values in <code>config/alertmanager.yml</code> (always check out the script first, before executing it)</p>

<pre><code>$ SLACK_WEBHOOK_URL="https://hooks.slack.com/services/xx/xx/xx" SLACK_CHANNEL="#notifications" ./parse_configs.sh
</code></pre>

<p>You can double check by running <code>cat config/alertmanager.yml</code>, once you are done, boot the stack:</p>

<pre><code>$ docker-compose up -d
</code></pre>

<p>Open up grafana:</p>

<pre><code>$ open http://grafana.localdns.xyz:3000
</code></pre>

<p>Use the initial user and password combination <code>admin/admin</code> and then reset your password:</p>

<p><img src="https://user-images.githubusercontent.com/567298/98379039-7efdce80-204f-11eb-9c8a-3ed12a63cb14.png" alt="image" /></p>

<p>Browse for your labels on the log explorer section, in my example it will be <code>{job="dockerlogs"}</code>:</p>

<p><img src="https://user-images.githubusercontent.com/567298/98379172-ace31300-204f-11eb-8e6c-3cf073afe771.png" alt="image" /></p>

<p>When we select our job=&ldquo;dockerlogs&rdquo; label, we will see our logs:</p>

<p><img src="https://user-images.githubusercontent.com/567298/98379288-c71cf100-204f-11eb-911c-043a983bae6d.png" alt="image" /></p>

<p>As I explained earlier the query that we will be running in our ruler, can be checked what the rate currently is:</p>

<pre><code>sum by (compose_project, compose_service) (rate({job="dockerlogs"}[1m]))
</code></pre>

<p>Which will look like this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/98379765-54604580-2050-11eb-9c90-5e0adf2bb586.png" alt="image" /></p>

<p>In the configured expression in our ruler config, we have set to alarm once the value goes above 60, we can validate this by running:</p>

<pre><code>sum by (compose_project, compose_service) (rate({job="dockerlogs"}[1m])) &gt; 60
</code></pre>

<p>And we can verify that this is the case, and by now it should be alarming:</p>

<p><img src="https://user-images.githubusercontent.com/567298/98379900-84a7e400-2050-11eb-87d0-ae52617d195e.png" alt="image" /></p>

<p>Head over to alertmanager:</p>

<pre><code>$ open http://alertmanager.localdns.xyz:9093
</code></pre>

<p>We can see alertmanager is showing the alarm:</p>

<p><img src="https://user-images.githubusercontent.com/567298/98380013-af923800-2050-11eb-8585-f7489bf722cb.png" alt="image" /></p>

<p>When we head over to slack, we can see our notification:</p>

<p><img src="https://user-images.githubusercontent.com/567298/98380158-de101300-2050-11eb-8d73-20828124fab5.png" alt="image" /></p>

<p>So let&rsquo;s stop our http client:</p>

<pre><code>$ docker-compose stop http-client
Stopping http-client ... done
</code></pre>

<p>Then we can see the logging stopped:</p>

<p><img src="https://user-images.githubusercontent.com/567298/98380907-e0bf3800-2051-11eb-99c3-b3b9ac22bba5.png" alt="image" /></p>

<p>And in slack, we should see that the alarm recovered and we should see the notification:</p>

<p><img src="https://user-images.githubusercontent.com/567298/98381360-722eaa00-2052-11eb-8bb4-07cdc8ffa7ee.png" alt="image" /></p>

<p>Then you can terminate your stack:</p>

<pre><code>$ docker-compose down
</code></pre>

<p>Pretty epic stuff right? I really love how cost effective Loki is as logging use to be so expensive to run and especially maintain, Grafana Labs are really doing some epic work and my hat goes off to them.</p>

<h2>Thanks</h2>

<p>I hope you found this useful, feel free to reach out to me on Twitter <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong> or visit me on my website <strong><a href="https://ruan.dev">ruan.dev</a></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Loki Behind Nginx Reverse Proxy]]></title>
    <link href="https://blog.ruanbekker.com/blog/2020/10/29/running-loki-behind-nginx-reverse-proxy/"/>
    <updated>2020-10-29T08:29:13+00:00</updated>
    <id>https://blog.ruanbekker.com/blog/2020/10/29/running-loki-behind-nginx-reverse-proxy</id>
    <content type="html"><![CDATA[<p>In this tutorial I will demonstrate how to run <strong>Loki v2.0.0</strong> behind a <strong>Nginx Reverse Proxy</strong> with basic http authentication enabled on Nginx and what to do to configure Nginx for <strong>websockets</strong>, which is required when you want to use <strong>tail in logcli</strong> via Nginx.</p>

<h2>Assumptions</h2>

<p>My environment consists of a AWS Application LoadBalancer with a Host entry and a Target Group associated to port 80 of my Nginx/Loki EC2 instance.</p>

<p>Health checks to my EC2 instance are being performed to <code>instance:80/ready</code></p>

<p>I have a S3 bucket and a DynamoDB table already running in my account which Loki will use. But <strong>NOTE</strong> that boltdb-shipper is now production ready since <a href="https://github.com/grafana/loki/blob/v2.0.0/CHANGELOG.md#20">v2.0.0</a>, which is awesome, because now you only require a object store such as S3, so you don&rsquo;t need DynamoDB.</p>

<p>More information on this topic can be found under their <a href="https://github.com/grafana/loki/blob/v2.0.0/CHANGELOG.md#20">changelog</a></p>

<h2>What can you expect from this blogpost</h2>

<p>We will go through the following topics:</p>

<ul>
<li>Install Loki v2.0.0 and Nginx</li>
<li>Configure HTTP Basic Authentication to Loki&rsquo;s API Endpoints</li>
<li>Bypass HTTP Basic Authentication to the <code>/ready</code> endpoint for our Load Balancer to perform healthchecks</li>
<li>Enable Nginx to upgrade websocket connections so that we can use <code>logcli --tail</code></li>
<li>Test out access to Loki via our Nginx Reverse Proxy</li>
<li>Install and use LogCLI</li>
</ul>


<h2>Install Software</h2>

<p>First we will install <code>nginx</code> and <code>apache2-utils</code>. In my use-case I will be using Ubuntu 20 as my operating system:</p>

<pre><code>$ sudo apt update &amp;&amp; sudo apt install nginx apache2-utils -y
</code></pre>

<p>Next we will install Loki v2.0.0, if you are upgrading from a previous version of Loki, I would recommend checking out the <a href="https://github.com/grafana/loki/releases/tag/v2.0.0">upgrade guide</a> mentioned on their releases page.</p>

<p>Download the package:</p>

<pre><code>$ curl -O -L "https://github.com/grafana/loki/releases/download/v2.0.0/loki-linux-amd64.zip"
</code></pre>

<p>Unzip the archive:</p>

<pre><code>$ unzip loki-linux-amd64.zip
</code></pre>

<p>Move the binary to your $PATH:</p>

<pre><code>$ sudo mv loki-linux-amd64 /usr/local/bin/loki
</code></pre>

<p>And ensure that the binary is executable:</p>

<pre><code>$ sudo chmod a+x /usr/local/bin/loki
</code></pre>

<h2>Configuration</h2>

<p>Create the user that will be responsible for running loki:</p>

<pre><code>$ useradd --no-create-home --shell /bin/false loki
</code></pre>

<p>Create the directory where we will place the loki configuration:</p>

<pre><code>$ mkdir /etc/loki
</code></pre>

<p>Create the loki configuration file:</p>

<pre><code>$ cat /etc/loki/loki-config.yml
auth_enabled: false

server:
  http_listen_port: 3100
  http_listen_address: 127.0.0.1
  http_server_read_timeout: 1000s
  http_server_write_timeout: 1000s
  http_server_idle_timeout: 1000s
  log_level: info

ingester:
  lifecycler:
    address: 127.0.0.1
    ring:
      kvstore:
        store: inmemory
      replication_factor: 1
    final_sleep: 0s
  chunk_encoding: snappy
  chunk_idle_period: 1h
  chunk_target_size: 1048576
  chunk_retain_period: 30s
  max_transfer_retries: 0

# https://grafana.com/docs/loki/latest/configuration/#schema_config
schema_config:
  configs:
    - from: 2020-05-15
      store: aws
      object_store: s3
      schema: v11
      index:
        prefix: loki-logging-index

storage_config:
  aws:
    http_config:
      idle_conn_timeout: 90s
      response_header_timeout: 0s
    s3: s3://myak:mysk@eu-west-1/loki-logs-datastore

    dynamodb:
      dynamodb_url: dynamodb://myak:mysk@eu-west-1

limits_config:
  enforce_metric_name: false
  reject_old_samples: true
  reject_old_samples_max_age: 168h
  ingestion_rate_mb: 30
  ingestion_burst_size_mb: 60

# https://grafana.com/docs/loki/latest/operations/storage/retention/
# To avoid querying of data beyond the retention period, max_look_back_period config in chunk_store_config
# must be set to a value less than or equal to what is set in table_manager.retention_period
chunk_store_config:
  max_look_back_period: 720h

# https://grafana.com/docs/loki/latest/operations/storage/retention/
table_manager:
  retention_deletes_enabled: true
  retention_period: 720h
  chunk_tables_provisioning:
    inactive_read_throughput: 10
    inactive_write_throughput: 10
    provisioned_read_throughput: 50
    provisioned_write_throughput: 20
  index_tables_provisioning:
    inactive_read_throughput: 10
    inactive_write_throughput: 10
    provisioned_read_throughput: 50
    provisioned_write_throughput: 20
</code></pre>

<p>Apply permissions so that the loki user has access to it&rsquo;s configuration:</p>

<pre><code>$ chown -R loki:loki /etc/loki
</code></pre>

<p>Create a systemd unit file:</p>

<pre><code>$ cat /etc/systemd/system/loki.service
[Unit]
Description=Loki
Wants=network-online.target
After=network-online.target

[Service]
User=loki
Group=loki
Type=simple
Restart=on-failure
ExecStart=/usr/local/bin/loki -config.file /etc/loki/loki-config.yml

[Install]
WantedBy=multi-user.target
</code></pre>

<p>Create the main nginx config:</p>

<pre><code>$ cat /etc/nginx/nginx.conf
user www-data;
worker_processes auto;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;
worker_rlimit_nofile 100000;

events {
        worker_connections 4000;
        use epoll;
        multi_accept on;
}

http {

    # basic settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
        open_file_cache_valid 30s;
        open_file_cache_min_uses 2;
        open_file_cache_errors on;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

        # ssl settings
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;

    # websockets config
    map $http_upgrade $connection_upgrade {
            default upgrade;
            '' close;
        }

    # logging settings
    access_log off;
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # gzip settings
    gzip on;
        gzip_min_length 10240;
        gzip_comp_level 1;
        gzip_vary on;
        gzip_disable msie6;
        gzip_proxied expired no-cache no-store private auth;
        gzip_types
        text/css
        text/javascript
        text/xml
        text/plain
        text/x-component
        application/javascript
        application/x-javascript
        application/json
    application/xml
        application/rss+xml
    application/atom+xml
        font/truetype
        font/opentype
        application/vnd.ms-fontobject
        image/svg+xml;
        reset_timedout_connection on;
        client_body_timeout 10;
        send_timeout 2;
        keepalive_requests 100000;

        # virtual host configs
    include /etc/nginx/conf.d/loki.conf;
}
</code></pre>

<p>Create the virtual host config:</p>

<pre><code>$ cat /etc/nginx/conf.d/loki.conf
upstream loki {
  server 127.0.0.1:3100;
  keepalive 15;
}

server {
  listen 80;
  server_name loki.localdns.xyz;

  auth_basic "loki auth";
  auth_basic_user_file /etc/nginx/passwords;

  location / {
    proxy_read_timeout 1800s;
    proxy_connect_timeout 1600s;
    proxy_pass http://loki;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;
    proxy_set_header Connection "Keep-Alive";
    proxy_set_header Proxy-Connection "Keep-Alive";
    proxy_redirect off;
  }

  location /ready {
    proxy_pass http://loki;
    proxy_http_version 1.1;
    proxy_set_header Connection "Keep-Alive";
    proxy_set_header Proxy-Connection "Keep-Alive";
    proxy_redirect off;
    auth_basic "off";
  }
}
</code></pre>

<p>As you&rsquo;ve noticed, we are providing a <code>auth_basic_user_file</code> to <code>/etc/nginx/passwords</code>, so let&rsquo;s create a user that we will be using to authenticate against loki:</p>

<pre><code>$ htpasswd -c /etc/nginx/passwords lokiisamazing
</code></pre>

<h2>Enable and Start Services</h2>

<p>Because we created a systemd unit file, we need to reload the systemd daemon:</p>

<pre><code>$ sudo systemctl daemon-reload
</code></pre>

<p>Then enable nginx and loki on boot:</p>

<pre><code>$ sudo systemctl enable nginx
$ sudo systemctl enable loki
</code></pre>

<p>Then start or restart both services:</p>

<pre><code>$ sudo systemctl restart nginx
$ sudo systemctl restart loki
</code></pre>

<p>You should see both ports, 80 and 3100 are listening:</p>

<pre><code>$ sudo netstat -tulpn | grep -E '(3100|80)'
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      8949/nginx: master
tcp        0      0 127.0.0.1:3100          0.0.0.0:*               LISTEN      23498/loki
</code></pre>

<h2>Test Access</h2>

<p>You will notice that I have a <code>/ready</code> endpoint that I am proxy passing to loki, which bypasses authentication, this has been setup for my AWS Application Load Balancer&rsquo;s Target Group to perform health checks against.</p>

<p>We can verify if we are getting a 200 response code without passing authentication:</p>

<pre><code>$ curl -i http://loki.localdns.xyz/ready
HTTP/1.1 200 OK
Server: nginx/1.14.0 (Ubuntu)
Date: Thu, 29 Oct 2020 09:15:52 GMT
Content-Type: text/plain; charset=utf-8
Content-Length: 6
Connection: keep-alive
X-Content-Type-Options: nosniff

ready
</code></pre>

<p>If we try to make a request to Loki&rsquo;s labels API endpoint, you will notice that we are returned with a 401 unauthorized response:</p>

<pre><code>$ curl -i http://loki.localdns.xyz/loki/api/v1/labels
HTTP/1.1 401 Unauthorized
Server: nginx/1.14.0 (Ubuntu)
Date: Thu, 29 Oct 2020 09:16:52 GMT
Content-Type: text/html
Content-Length: 204
Connection: keep-alive
WWW-Authenticate: Basic realm="loki auth"
</code></pre>

<p>So let&rsquo;s access the labels API endpoint by passing our basic auth credentials. To leave no leaking passwords behind, create a file and save your password content in that file:</p>

<pre><code>$ vim /tmp/.pass
-&gt; then enter your password and save the file &lt;-
</code></pre>

<p>Expose the content as an environment variable:</p>

<pre><code>$ pass=$(cat /tmp/.pass)
</code></pre>

<p>Now make a request to Loki&rsquo;s labels endpoint by passing authentication:</p>

<pre><code>$ curl -i -u lokiisawesome:$pass http://loki.localdns.xyz/loki/api/v1/labels
HTTP/1.1 200 OK
Server: nginx/1.14.0 (Ubuntu)
Date: Thu, 29 Oct 2020 09:20:20 GMT
Content-Type: application/json; charset=UTF-8
Content-Length: 277
Connection: keep-alive

{"status":"success","data":["__name__","aws_account","cluster_name","container_name","environment","filename","job","service","team"]}
</code></pre>

<p>Then ensure that your remove the password file:</p>

<pre><code>$ rm -rf /tmp/.pass
</code></pre>

<p>And unset your pass environment variable, to clean up your tracks:</p>

<pre><code>$ unset pass
</code></pre>

<h2>LogCLI</h2>

<p>Now for my favorite part, using logcli to interact with Loki, but more specifically using <code>--tail</code> as it requires websockets, nginx will now be able to upgrade those connections:</p>

<p>Install logcli, in my case I am using a mac, so I will be using darwin:</p>

<pre><code>$ wget https://github.com/grafana/loki/releases/download/v2.0.0/logcli-darwin-amd64.zip
$ unzip logcli-darwin-amd64.zip
$ mv logcli-darwin-amd64 /usr/local/bin/logcli
</code></pre>

<p>Set your environment variables for logcli:</p>

<pre><code>$ export LOKI_ADDR=https://loki.yourdomain.com # im doing ssl termination on the aws alb
$ export LOKI_USERNAME=lokiisawesome
$ export LOKI_PASSWORD=$pass 
</code></pre>

<p>Now for that sweetness of tailing ALL THE LOGS!! :-D . Let&rsquo;s first discover the label that we want to select:</p>

<pre><code>$ logcli labels --quiet container_name | grep deadman
ecs-deadmanswitch-4-deadmanswitch-01234567890abcdefghi
</code></pre>

<p>Then tail for the win!</p>

<pre><code>$ logcli query --quiet --output raw --tail '{job="prod/dockerlogs", container_name=~"ecs-deadmanswitch.*"}'
time="2020-10-29T09:03:36Z" level=info msg="timerID: xxxxxxxxxxxxxxxxxxxx"
time="2020-10-29T09:03:36Z" level=info msg="POST - /ping/xxxxxxxxxxxxxxxxxxx"
</code></pre>

<p>Awesome right?</p>

<p><img src="https://media.giphy.com/media/3ohzdIuqJoo8QdKlnW/giphy.gif" alt="" /></p>

<h2>Thank You</h2>

<p>Hope that you found this useful, make sure to follow Grafana&rsquo;s blog for more awesome content:</p>

<ul>
<li><a href="https://grafana.com/blog/">https://grafana.com/blog/</a></li>
</ul>


<p>If you liked this content, please make sure to share or come say hi on my website or twitter:</p>

<ul>
<li><a href="https://ruan.dev">w: ruan.dev</a></li>
<li><a href="https://ruan.dev">t: @ruanbekker</a></li>
</ul>


<p>For other content of mine on Loki:</p>

<ul>
<li><a href="https://blog.ruanbekker.com/blog/categories/loki/">https://blog.ruanbekker.com/blog/categories/loki/</a></li>
<li><a href="https://github.com/ruanbekker/docker-loki-distributed-minio">https://github.com/ruanbekker/docker-loki-distributed-minio</a></li>
<li><a href="https://github.com/ruanbekker/loki-docker-nginx-example">https://github.com/ruanbekker/loki-docker-nginx-example</a></li>
<li><a href="https://github.com/ruanbekker/loki-minio-docker">https://github.com/ruanbekker/loki-minio-docker</a></li>
<li><a href="https://github.com/ruanbekker/cheatsheets/tree/master/loki">https://github.com/ruanbekker/cheatsheets/tree/master/loki</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
