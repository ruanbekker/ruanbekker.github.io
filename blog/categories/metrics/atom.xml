<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Metrics | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/metrics/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2020-04-29T00:15:42+02:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nginx Metrics on Prometheus With the Nginx Log Exporter]]></title>
    <link href="http://blog.ruanbekker.com/blog/2020/04/25/nginx-metrics-on-prometheus-with-the-nginx-log-exporter/"/>
    <updated>2020-04-25T01:42:35+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2020/04/25/nginx-metrics-on-prometheus-with-the-nginx-log-exporter</id>
    <content type="html"><![CDATA[<p>In this post we will setup a nginx log exporter for prometeus to get metrics of our nginx web server, such as number of requests per method, status code, processed bytes etc. Then we will configure prometheus to scrape our nginx metric endpoint and also create a basic dashbaord to visualize our data.</p>

<p>If you follow along on this tutorial, it assumes that you have <a href="https://blog.ruanbekker.com/blog/2019/05/07/setup-prometheus-and-node-exporter-on-ubuntu-for-epic-monitoring/">Prometheus</a> and <a href="https://blog.ruanbekker.com/blog/2019/05/17/install-grafana-to-visualize-your-metrics-from-datasources-such-as-prometheus-on-linux/">Grafana</a> up and running. But if not the embedded links will take you to the blog posts to set it up.</p>

<h2>Nginx Webserver</h2>

<p>Install nginx:</p>

<pre><code>$ apt update
$ apt install nginx -y
</code></pre>

<p>Configure your nginx server&rsquo;s log format to match the nginx log exporter&rsquo;s expected format, we will name it custom:</p>

<pre><code>  log_format custom   '$remote_addr - $remote_user [$time_local] '
                      '"$request" $status $body_bytes_sent '
                      '"$http_referer" "$http_user_agent" "$http_x_forwarded_for"';
</code></pre>

<p>Edit your main nginx config:</p>

<pre><code>$ vim /etc/nginx/nginx.conf
</code></pre>

<p>This is how my complete config looks like:</p>

<pre><code>user www-data;
worker_processes auto;
pid /run/nginx.pid;
# remote the escape char if you are going to use this config
include /etc/nginx/modules-enabled/\*.conf;

events {
  worker_connections 768;
}

http {

  # basic config
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;
  types_hash_max_size 2048;
  include /etc/nginx/mime.types;
  default_type application/octet-stream;

  # ssl config
  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 
  ssl_prefer_server_ciphers on;

  # logging config
  log_format custom   '$remote_addr - $remote_user [$time_local] '
                      '"$request" $status $body_bytes_sent '
                      '"$http_referer" "$http_user_agent" "$http_x_forwarded_for"';

  access_log /var/log/nginx/access.log custom;
  error_log /var/log/nginx/error.log;

  # gzip
  gzip on;

  # virtual host config
  include /etc/nginx/conf.d/myapp.conf;

}
</code></pre>

<p>I will delete the default host config:</p>

<pre><code>$ rm -rf /etc/nginx/sites-enabled/default
</code></pre>

<p>And then create my <code>/etc/nginx/conf.d/myapp.conf</code> as referenced in my main config, with the following:</p>

<pre><code>server {

  listen 80 default_server;
  # remove the escape char if you are going to use this config
  server_name \_;

  root /var/www/html;
  index index.html index.htm index.nginx-debian.html;

  location / {
    try_files $uri $uri/ =404;
  }

}
</code></pre>

<p>When you make a GET request to your server, you should see something like this in your access log:</p>

<pre><code>10x.1x.2x.1x - - [25/Apr/2020:00:31:11 +0000] "GET / HTTP/1.1" 200 396 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Safari/605.1.15" "-"
</code></pre>

<h2>Nginx Log Exporter</h2>

<p>Head over to the <a href="https://github.com/martin-helmich/prometheus-nginxlog-exporter/releases">prometheus-nginxlog-exporter releases</a> page and get the latest version, in the time of writing it is v1.4.0:</p>

<pre><code>$ wget https://github.com/martin-helmich/prometheus-nginxlog-exporter/releases/download/v1.4.0/prometheus-nginxlog-exporter
</code></pre>

<p>Make it executable and move it to your path:</p>

<pre><code>$ chmod +x prometheus-nginxlog-exporter
$ mv prometheus-nginxlog-exporter /usr/bin/prometheus-nginxlog-exporter
</code></pre>

<p>Create the directory where we will place our config for our exporter:</p>

<pre><code>$ mkdir /etc/prometheus
</code></pre>

<p>Create the config file:</p>

<pre><code>$ vim /etc/prometheus/nginxlog_exporter.yml
</code></pre>

<p>You can follow the instructions from <a href="https://github.com/martin-helmich/prometheus-nginxlog-exporter">github.com/prometheus-nginxlog-exporter</a> for more information on configuration, but I will be using the following config:</p>

<pre><code>listen:
  port: 4040
  address: "0.0.0.0"

consul:
  enable: false

namespaces:
  - name: myapp
    format: "$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\" \"$http_x_forwarded_for\""
    source:
      files:
        - /var/log/nginx/access.log
    labels:
      service: "myapp"
      environment: "production"
      hostname: "myapp.example.com"
    histogram_buckets: [.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10]
</code></pre>

<p>Create the systemd unit file:</p>

<pre><code>$ vim /etc/systemd/system/nginxlog_exporter.service
</code></pre>

<p>And my configuration that I will be using:</p>

<pre><code>[Unit]
Description=Prometheus Log Exporter
Wants=network-online.target
After=network-online.target

[Service]
User=root
Group=root
Type=simple
ExecStart=/usr/bin/prometheus-nginxlog-exporter -config-file /etc/prometheus/nginxlog_exporter.yml

[Install]
WantedBy=multi-user.target
</code></pre>

<p>Reload systemd and enable the service on boot:</p>

<pre><code>$ systemctl daemon-reload
$ systemctl enable nginxlog_exporter
</code></pre>

<p>Restart the service:</p>

<pre><code>$ systemctl restart nginxlog_exporter
</code></pre>

<p>Ensure that the service is running:</p>

<pre><code>$ systemctl status nginxlog_exporter

● nginxlog_exporter.service - Prometheus Log Exporter
   Loaded: loaded (/etc/systemd/system/nginxlog_exporter.service; disabled; vendor preset: enabled)
   Active: active (running) since Sat 2020-04-25 00:50:06 UTC; 5s ago
 Main PID: 4561 (prometheus-ngin)
    Tasks: 7 (limit: 2317)
   CGroup: /system.slice/nginxlog_exporter.service
           └─4561 /usr/bin/prometheus-nginxlog-exporter -config-file /etc/prometheus/nginxlog_exporter.yml

Apr 25 00:50:06 nginx-log-exporter systemd[1]: Started Prometheus Log Exporter.
Apr 25 00:50:06 nginx-log-exporter prometheus-nginxlog-exporter[4561]: loading configuration file /etc/prometheus/nginxlog_exporter.yml
Apr 25 00:50:06 nginx-log-exporter prometheus-nginxlog-exporter[4561]: using configuration {Listen:{Port:4040 Address:0.0.0.0} Consul:{Enable:false Address: Datacenter: Scheme: Toke
Apr 25 00:50:06 nginx-log-exporter prometheus-nginxlog-exporter[4561]: starting listener for namespace myapp
Apr 25 00:50:06 nginx-log-exporter prometheus-nginxlog-exporter[4561]: running HTTP server on address 0.0.0.0:4040
Apr 25 00:50:06 nginx-log-exporter prometheus-nginxlog-exporter[4561]: 2020/04/25 00:50:06 Seeked /var/log/nginx/access.log - &amp;{Offset:0 Whence:2}
</code></pre>

<h2>Test the exporter</h2>

<p>Make a couple of requests against your webserver:</p>

<pre><code>$ for each in {1..10}; do curl http://78.141.211.49 ; done
</code></pre>

<p>So prometheus will now scrape the exporter http endpoint (<code>:4040/metrics</code>) and push the returned values into prometheus. But to get a feel on how the metrics look like, make a request to the metrics endpoint:</p>

<pre><code>$ curl http://localhost:4040/metrics
...
# HELP myapp_http_response_count_total Amount of processed HTTP requests
# TYPE myapp_http_response_count_total counter
myapp_http_response_count_total{environment="production",hostname="myapp.example.com",method="GET",service="myapp",status="200"} 10
myapp_http_response_count_total{environment="production",hostname="myapp.example.com",method="POST",service="myapp",status="404"} 1
# HELP myapp_http_response_size_bytes Total amount of transferred bytes
# TYPE myapp_http_response_size_bytes counter
myapp_http_response_size_bytes{environment="production",hostname="myapp.example.com",method="GET",service="myapp",status="200"} 6120
myapp_http_response_size_bytes{environment="production",hostname="myapp.example.com",method="POST",service="myapp",status="404"} 152
# HELP myapp_parse_errors_total Total number of log file lines that could not be parsed
# TYPE myapp_parse_errors_total counter
myapp_parse_errors_total 0
...
</code></pre>

<p>As you can see we are getting metrics such as response count total, response size, errors, etc.</p>

<h2>Configure Prometheus</h2>

<p>Let&rsquo;s configure prometheus to scrape this endpoint. Head over to your prometheus instance, and edit your prometheus config:</p>

<pre><code>$ vim /etc/prometheus/prometheus.yml
</code></pre>

<p>Note that in my config I have 2 endpoints that I am scraping, the prometheus endpoint which exists and I will be adding the nginx endpoint, so in full, this is how my config will look like:</p>

<pre><code>global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'prometheus'
    scrape_interval: 5s
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'nginx'
    scrape_interval: 15s
    static_configs:
      - targets: ['ip.of.nginx.exporter:4040']
</code></pre>

<p>Restart prometheus:</p>

<pre><code>$ systemctl restart prometheus
</code></pre>

<p>To verify that the exporter is working as expected, head over to your prometheus ui on port 9090, and query <code>up{}</code> to see if your exporters are returning 1:</p>

<p><img width="1280" alt="image" src="https://user-images.githubusercontent.com/567298/80267654-7b51be00-86a2-11ea-98e2-a48a5c2a1e4f.png"></p>

<p>We can then query prometheus with <code>myapp_http_response_count_total{service="myapp"}</code> to see the response counts:</p>

<p><img width="1273" alt="image" src="https://user-images.githubusercontent.com/567298/80267823-590c7000-86a3-11ea-9098-28e37e7941d7.png"></p>

<h2>Dashboarding in Grafana</h2>

<p>If you don&rsquo;t have Grafana installed, you can look at my <a href="https://blog.ruanbekker.com/blog/2019/05/17/install-grafana-to-visualize-your-metrics-from-datasources-such-as-prometheus-on-linux/">Grafana Installation</a> post to get that up and running.</p>

<p>If you have not created the Prometheus datasource, on Grafana, head over to the configuration section on your left, select Datasources, add a Prometheus datasource and add the following (this is assuming grafana runs on the prometheus node - which is fine for testing):</p>

<p><img width="592" alt="image" src="https://user-images.githubusercontent.com/567298/80267986-48a8c500-86a4-11ea-9046-3fba601d41cf.png"></p>

<p>Create a new dashboard and add a new panel:</p>

<p><img width="605" alt="image" src="https://user-images.githubusercontent.com/567298/80267884-b3a5cc00-86a3-11ea-8624-797e5310de80.png"></p>

<p>Let&rsquo;s query our data to show us HTTP Method and Status code per 30s: <code>rate(myapp_http_response_count_total{service="myapp"}[$__interval])</code></p>

<p><img width="1271" alt="image" src="https://user-images.githubusercontent.com/567298/80269073-e607f700-86ac-11ea-8d42-4814084dfb4a.png"></p>

<h2>Thank You</h2>

<p>Hope you found this helpful, if you haven&rsquo;t seen my other posts on Prometheus, have a look at the following:</p>

<ul>
<li><a href="https://blog.ruanbekker.com/blog/2019/05/07/setup-prometheus-and-node-exporter-on-ubuntu-for-epic-monitoring/">Setup Prometheus</a></li>
<li><a href="https://blog.ruanbekker.com/blog/2019/05/17/install-grafana-to-visualize-your-metrics-from-datasources-such-as-prometheus-on-linux/">Setup Grafana</a></li>
<li><a href="https://blog.ruanbekker.com/blog/2019/05/07/setup-prometheus-and-node-exporter-on-ubuntu-for-epic-monitoring/">Setup Node Exporter</a></li>
<li><a href="https://blog.ruanbekker.com/blog/2019/05/17/install-blackbox-exporter-to-monitor-websites-with-prometheus/">Setup Blackbox Exporter</a></li>
<li><a href="https://blog.ruanbekker.com/blog/2019/05/17/install-alertmanager-to-alert-based-on-metrics-from-prometheus/">Setup Alertmanager</a></li>
<li><a href="https://blog.ruanbekker.com/blog/2019/05/17/install-pushgateway-to-expose-metrics-to-prometheus/">Setup Pushgateway</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Thanos on Docker: A Highly Available Prometheus]]></title>
    <link href="http://blog.ruanbekker.com/blog/2020/02/01/setup-thanos-on-docker-a-highly-available-prometheus/"/>
    <updated>2020-02-01T01:28:12+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2020/02/01/setup-thanos-on-docker-a-highly-available-prometheus</id>
    <content type="html"><![CDATA[<p>Today we will look at Thanos, a open source, highly available prometheus setup with long term storage capabilites, that we will run on docker to simplify the setup.</p>

<p>Note that running this proof of concept does not make it highly available as we will run everything on one host, but it will give you a feel what Thanos is about. In a future post, I will setup Thanos in a multi node environment.</p>

<h2>Prometheus</h2>

<p>If you are not familiar with <a href="https://prometheus.io">Prometheus</a>, then have a look at their documentation, but in short, prometheus is a open source monitoring system and time series database developed by soundcloud.</p>

<p>Prometheus is a monitoring system includes a rich, multidimensional data model, a concise and powerful query language called PromQL, an efficient embedded timeseries database, and over 150 integrations with third-party systems.</p>

<h2>Thanos</h2>

<p>Thanos is a highly available prometheus setup with long term storage capabilities.</p>

<p>Thanos allows you to ship your data to S3/Minio for long storage capabilites, so you could for example only store your &ldquo;live&rdquo; data on prometheus for 2 weeks, then everything older than that gets sent to object storage such as amazon s3 or minio. This helps your prometheus instance not to be flooded with data or prevents you from running out of storage space. The nice thing is, when you query for data older than 2 weeks, it will fetch the data from object storage.</p>

<p>Thanos has a global query view, which essentially means you can query your prometheus metrics from one endpoint backed by multiple prometheus servers or cluster.</p>

<p>You can still use the same tools such as Grafana as it utilizes the same Prometheus Query API.</p>

<p>Thanos provides downsampling and compaction, so that you downsample your historical data for massive query speedup when querying large time ranges.</p>

<h2>Thanos Components</h2>

<p>Thanos is a clustered system of components which can be categorized as follows:</p>

<ul>
<li><p>Metric sources</p>

<ul>
<li>Thanos provides two components that act as data sources: Prometheus Sidecar and Rule Nodes</li>
<li>Sidecar implements gRPC service on top of Prometheus</li>
<li>Rule Node directly implements it on top of the Prometheus storage engine it is running</li>
<li>Data sources that persist their data for long term storage, do so via the Prometheus 2.0 storage engine</li>
<li>Storage engine periodically produces immutable blocks of data for a fixed time range</li>
<li>A blocks top-level directory includes chunks, index and meta.json files</li>
<li>Chunk files hold a few hundred MB worth of chunks each</li>
<li>The index file holds all information needed to lookup specific series by their labels and the positions of their chunks.</li>
<li>The <code>meta.json</code> file holds metadata about block like stats, time range, and compaction level</li>
</ul>
</li>
<li><p>Stores</p>

<ul>
<li>A Store Node acts as a Gateway to block data that is stored in an object storage bucket</li>
<li>It implements the same gRPC API as Data Sources to provide access to all metric data found in the bucket</li>
<li>Continuously synchronizes which blocks exist in the bucket and translates requests for metric data into object storage requests</li>
<li>Implements various strategies to minimize the number of requests to the object storage</li>
<li>Prometheus 2.0 storage layout is optimized for minimal read amplification</li>
<li>At this time of writing, only index data is cached</li>
<li>Stores and Data Sources are the same, store nodes and data sources expose the same gRPC Store API</li>
<li>Store API allows to look up data by a set of label matchers and a time range</li>
<li>It then returns compressed chunks of samples as they are found in the block data</li>
<li>So it&rsquo;s purely a data retrieval API and does not provide complex query execution</li>
</ul>
</li>
<li><p>Query Layer</p>

<ul>
<li>Queriers are stateless and horizontally scalable instances that implement PromQL on top of the Store APIs exposed in the cluster</li>
<li>Queriers participate in the cluster to be able to resiliently discover all data sources and store nodes</li>
<li>Rule nodes in return can discover query nodes to evaluate recording and alerting rules</li>
<li>Based on the metadata of store and source nodes, they attempt to minimize the request fanout to fetch data for a particular query</li>
<li>The only scalable components of Thanos is the query nodes as none of the Thanos components provide sharding</li>
<li>Scaling of storage capacity is ensured by relying on an external object storage system</li>
<li>Store, rule, and compactor nodes are all expected to scale significantly within a single instance or high availability pair</li>
</ul>
</li>
</ul>


<p>The information from above was retrieved from their <a href="https://thanos.io/design.md/">website</a>, feel free to check them out if you want to read more on the concepts of thanos.</p>

<p>The Architecture Overview of Thanos looks like this:</p>

<p><img src="https://github.com/thanos-io/thanos/blob/master/docs/img/arch.jpg?raw=true" alt="" /></p>

<h2>What are we doing today</h2>

<p>We will setup a Thanos Cluster with Minio, Node-Exporter, Grafana on Docker. Our Thanos setup will consist of 3 prometheus containers, each one running with a sidecar container, a store container, 2 query containers, then we have the remotewrite and receive containers which node-exporter will use to ship its metrics to.</p>

<p>The minio container will be used as our long-term storage and the mc container will be used to initialize the storage bucket which is used by thanos.</p>

<h2>Deploy the Cluster</h2>

<p>Below is the docker-compose.yml and the script to generate the configs for thanos:</p>

<script src="https://gist.github.com/ruanbekker/acd1b17d3aea4c71031e72dfc8ebbb4d.js"></script>


<p>Once you have saved the compose as <code>docker-compose.yml</code> and the script as <code>configs.sh</code> you can create the configs:</p>

<pre><code>$ bash configs.sh
</code></pre>

<p>The script from above creates the data directory and place all the configs that thanos will use in there. Next deploy the thanos cluster:</p>

<pre><code>$ docker-compose -f docker-compose.yml up
</code></pre>

<p>It should look something like this:</p>

<pre><code>$ docker-compose -f docker-compose.yml up
Starting node-exporter ... done
Starting minio         ... done
Starting grafana        ... done
Starting prometheus0    ... done
Starting prometheus1     ... done
Starting thanos-receive  ... done
Starting thanos-store    ... done
Starting prometheus2     ... done
Starting mc             ... done
Starting thanos-sidecar0 ... done
Starting thanos-sidecar1     ... done
Starting thanos-sidecar2     ... done
Starting thanos-remote-write ... done
Starting thanos-query1       ... done
Starting thanos-query0       ... done
Attaching to node-exporter, minio, grafana, mc, prometheus0, prometheus1, thanos-store, prometheus2, thanos-receive, thanos-sidecar0, thanos-sidecar1, thanos-sidecar2, thanos-remote-write, thanos-query0, thanos-query1
</code></pre>

<p>Access the Query UI, which looks identical to the Prometheus UI:
- <a href="http://localhost:10904/graph">http://localhost:10904/graph</a></p>

<p>It will look more or less like this:</p>

<p><img width="1280" alt="image" src="https://user-images.githubusercontent.com/567298/73583506-4e26b280-449b-11ea-96ca-9b0cefec0acd.png"></p>

<p>When we access minio on:
- <a href="http://localhost:9000/minio">http://localhost:9000/minio</a></p>

<p>And under the thanos bucket you will see the objects being persisted:</p>

<p><img width="1278" alt="image" src="https://user-images.githubusercontent.com/567298/73583542-7ca48d80-449b-11ea-955c-7b1e766229a3.png"></p>

<p>When we access grafana on:
- <a href="http://localhost:3000/">http://localhost:3000/</a></p>

<p>Select datasources, add a prometheus datasource and select the endpoint: <code>http://query0:10904</code>, which should look like this:</p>

<p><img width="618" alt="image" src="https://user-images.githubusercontent.com/567298/73583601-d73de980-449b-11ea-9a71-c94e8184336f.png"></p>

<p>When we create a dashboard, you can test a query with <code>thanos_sidecar_prometheus_up</code> and it should look something like this:</p>

<p><img width="1279" alt="image" src="https://user-images.githubusercontent.com/567298/73583684-49aec980-449c-11ea-97bd-35145ff8330c.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prometheus Series of Tutorials for Your Guide to Epic Metrics]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/05/17/prometheus-series-of-tutorials-for-your-guide-to-epic-metrics/"/>
    <updated>2019-05-17T20:24:40+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/05/17/prometheus-series-of-tutorials-for-your-guide-to-epic-metrics</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/57307750-696bb980-70e5-11e9-9b0b-73ad88bde6a3.png" alt="prometheus" /></p>

<p>This is a curated list of tutorials of prometheus, from installing prometheus, installing grafana, exporters, docker versions of the prometheus / grafana / node exporter stack, etc.</p>

<h2>The List</h2>

<ul>
<li>Install <a href="http://blog.ruanbekker.com/blog/2019/05/07/setup-prometheus-and-node-exporter-on-ubuntu-for-epic-monitoring/">Prometheus</a></li>
<li>Install <a href="http://blog.ruanbekker.com/blog/2019/05/07/setup-prometheus-and-node-exporter-on-ubuntu-for-epic-monitoring/">Node Exporter</a></li>
<li>Install <a href="http://blog.ruanbekker.com/blog/2019/05/17/install-pushgateway-to-expose-metrics-to-prometheus/">Pushgateway</a></li>
<li>Install <a href="http://blog.ruanbekker.com/blog/2019/05/17/install-grafana-to-visualize-your-metrics-from-datasources-such-as-prometheus-on-linux/">Grafana</a></li>
<li>Install <a href="http://blog.ruanbekker.com/blog/2019/05/17/install-alertmanager-to-alert-based-on-metrics-from-prometheus/">Alertmananger</a></li>
<li>Install <a href="http://blog.ruanbekker.com/blog/2019/05/17/install-blackbox-exporter-to-monitor-websites-with-prometheus/">Blackbox Exporter</a></li>
<li>Install <a href="">Docker Prometheus Grafana Stack</a></li>
</ul>


<p>This list will be updated as I publish more tutorials</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Install Blackbox Exporter to Monitor Websites With Prometheus]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/05/17/install-blackbox-exporter-to-monitor-websites-with-prometheus/"/>
    <updated>2019-05-17T18:55:15+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/05/17/install-blackbox-exporter-to-monitor-websites-with-prometheus</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/57307750-696bb980-70e5-11e9-9b0b-73ad88bde6a3.png" alt="prometheus" /></p>

<p>Blackbox Exporter by Prometheus allows probing over endpoints such as http, https, icmp, tcp and dns.</p>

<p><a href="https://bekkerclothing.com/collections/developer?utm_source=blog.ruanbekker.com&utm_medium=blog&utm_campaign=leaderboard_ad" target="_blank"><img alt="bekker-clothing-developer-tshirts" src="https://user-images.githubusercontent.com/567298/70170981-7c278a80-16d6-11ea-9759-6621d02c1423.png"></a></p>

<h2>What will we be doing</h2>

<p>In this tutorial we will install the blackbox exporter on linux. Im assuming that you have already <a href="https://blog.ruanbekker.com/blog/2019/05/07/setup-prometheus-and-node-exporter-on-ubuntu-for-epic-monitoring/">set up prometheus</a>.</p>

<h2>Install the Blackbox Exporter</h2>

<p>First create the blackbox exporter user:</p>

<pre><code>$ useradd --no-create-home --shell /bin/false blackbox_exporter
</code></pre>

<p>Download blackbox exporter and extract:</p>

<pre><code>$ wget https://github.com/prometheus/blackbox_exporter/releases/download/v0.14.0/blackbox_exporter-0.14.0.linux-amd64.tar.gz
$ tar -xvf blackbox_exporter-0.14.0.linux-amd64.tar.gz
</code></pre>

<p>Move the binaries in place and change the ownership:</p>

<pre><code>$ cp blackbox_exporter-0.14.0.linux-amd64/blackbox_exporter /usr/local/bin/blackbox_exporter
$ chown blackbox_exporter:blackbox_exporter /usr/local/bin/blackbox_exporter
</code></pre>

<p>Remove the downloaded archive:</p>

<pre><code>$ rm -rf blackbox_exporter-0.14.0.linux-amd64*
</code></pre>

<p>Create the blackbox directory and create the config:</p>

<pre><code>$ mkdir /etc/blackbox_exporter
$ vim /etc/blackbox_exporter/blackbox.yml
</code></pre>

<p>Populate this config:</p>

<pre><code>modules:
  http_2xx:
    prober: http
    timeout: 5s
    http:
      valid_status_codes: []
      method: GET
</code></pre>

<p>Update the permissions of the config so that the user has ownership:</p>

<pre><code>$ chown blackbox_exporter:blackbox_exporter /etc/blackbox_exporter/blackbox.yml
</code></pre>

<p>Create the systemd unit file:</p>

<pre><code>$ vim /etc/systemd/system/blackbox_exporter.service
</code></pre>

<p>Populate the systemd unit file configuration:</p>

<pre><code>[Unit]
Description=Blackbox Exporter
Wants=network-online.target
After=network-online.target

[Service]
User=blackbox_exporter
Group=blackbox_exporter
Type=simple
ExecStart=/usr/local/bin/blackbox_exporter --config.file /etc/blackbox_exporter/blackbox.yml

[Install]
WantedBy=multi-user.target
</code></pre>

<p>Reload the systemd daemon and restart the service:</p>

<pre><code>$ systemctl daemon-reload
$ systemctl start blackbox_exporter
</code></pre>

<p>The service should be started, verify:</p>

<pre><code>$ systemctl status blackbox_exporter
  blackbox_exporter.service - Blackbox Exporter
   Loaded: loaded (/etc/systemd/system/blackbox_exporter.service; disabled; vendor preset: enabled)
   Active: active (running) since Wed 2019-05-08 00:02:40 UTC; 5s ago
 Main PID: 10084 (blackbox_export)
    Tasks: 6 (limit: 4704)
   CGroup: /system.slice/blackbox_exporter.service
           └─10084 /usr/local/bin/blackbox_exporter --config.file /etc/blackbox_exporter/blackbox.yml

May 08 00:02:40 ip-172-31-41-126 systemd[1]: Started Blackbox Exporter.
May 08 00:02:40 ip-172-31-41-126 blackbox_exporter[10084]: level=info ts=2019-05-08T00:02:40.5229204Z caller=main.go:213 msg="Starting blackbox_exporter" version="(version=0.14.0, branch=HEAD, revision=bb
May 08 00:02:40 ip-172-31-41-126 blackbox_exporter[10084]: level=info ts=2019-05-08T00:02:40.52553523Z caller=main.go:226 msg="Loaded config file"
May 08 00:02:40 ip-172-31-41-126 blackbox_exporter[10084]: level=info ts=2019-05-08T00:02:40.525695324Z caller=main.go:330 msg="Listening on address" address=:9115
</code></pre>

<p>Enable the service on boot:</p>

<pre><code>$ systemctl enable blackbox_exporter
</code></pre>

<h2>Configure Prometheus</h2>

<p>Next, we need to provide context to prometheus on what to monitor. We will inform prometheus to monitor a web endpoint on port 8080 using the blackbox exporter (we will create a python simplehttpserver to run on port 8080).</p>

<p>Edit the prometheus config <code>/etc/prometheus/prometheus.yml</code> and append the following:</p>

<pre><code>  - job_name: 'blackbox'
    metrics_path: /probe
    params:
      module: [http_2xx]
    static_configs:
      - targets:
        - http://localhost:8080
    relabel_configs:
      - source_labels: [__address__]
        target_label: __param_target
      - source_labels: [__param_target]
        target_label: instance
      - target_label: __address__
        replacement: localhost:9115
</code></pre>

<p>Open a new terminal, create a <code>index.html</code>:</p>

<pre><code>$ echo "ok" &gt; index.html
</code></pre>

<p>Then start a SimpleHTTPServer on port 8080:</p>

<pre><code>$ python -m SimpleHTTPServer 8080
</code></pre>

<p>Head back to the previous terminal session and restart prometheus:</p>

<pre><code>$ systemctl restart prometheus
</code></pre>

<h2>Configure the Alarm definition:</h2>

<p>Create a alarm definition that desribes that defines when to notify when a endpoint goes down:</p>

<pre><code>$ vim /etc/prometheus/alert.rules.yml
</code></pre>

<p>And our alert definition:</p>

<pre><code>groups:
- name: alert.rules
  rules:
  - alert: EndpointDown
    expr: probe_success == 0
    for: 10s
    labels:
      severity: "critical"
    annotations:
      summary: "Endpoint  down"
</code></pre>

<p>Ensure that the permission is set:</p>

<pre><code>$ chown prometheus:prometheus /etc/prometheus/alert.rules.yml
</code></pre>

<p>Use the <code>promtool</code> to validate that the alert is correctly configured:</p>

<pre><code>$ promtool check rules /etc/prometheus/alert.rules.yml
Checking /etc/prometheus/alert.rules.yml
  SUCCESS: 1 rules found
</code></pre>

<p>If everything is good, restart prometheus:</p>

<pre><code>$ systemctl restart prometheus
</code></pre>

<h2>Blackbox Exporter Dashboard</h2>

<p>To install a blackbox exporter dashboard: <a href="https://grafana.com/dashboards/7587">https://grafana.com/dashboards/7587</a>, create a new dashboard, select import, provide the ID: <code>7587</code>, select the prometheus datasource and select save.</p>

<p>The dashboard should look similar to this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57947217-99357100-78de-11e9-9108-9338c97ca59d.png" alt="blackbox-exporter" /></p>

<h2>Next up, Alertmanager</h2>

<p>In the <a href="https://blog.ruanbekker.com/blog/2019/05/17/install-alertmanager-to-alert-based-on-metrics-from-prometheus/">next tutorial</a> we will setup Alertmanager to alert when our endpoint goes down</p>

<h2>Resources</h2>

<p>See all <a href="https://blog.ruanbekker.com/blog/categories/prometheus/">#prometheus</a> blogposts</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Install Alertmanager to Alert Based on Metrics From Prometheus]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/05/17/install-alertmanager-to-alert-based-on-metrics-from-prometheus/"/>
    <updated>2019-05-17T18:49:26+02:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/05/17/install-alertmanager-to-alert-based-on-metrics-from-prometheus</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/57307750-696bb980-70e5-11e9-9b0b-73ad88bde6a3.png" alt="prometheus" /></p>

<p>So we are pushing our time series metrics into prometheus, and now we would like to alarm based on certain metric dimensions. That&rsquo;s where alertmanager fits in. We can setup targets and rules, once rules for our targets does not match, we can alarm to destinations suchs as slack, email etc.</p>

<p><a href="https://bekkerclothing.com/collections/developer?utm_source=blog.ruanbekker.com&utm_medium=blog&utm_campaign=leaderboard_ad" target="_blank"><img alt="bekker-clothing-developer-tshirts" src="https://user-images.githubusercontent.com/567298/70170981-7c278a80-16d6-11ea-9759-6621d02c1423.png"></a></p>

<h2>What we will be doing:</h2>

<p>In our previous tutorial we installed blackbox exporter to probe a endpoint. Now we will install Alertmanager and configure an alert to notify us via email and slack when our endpoint goes down. See <a href="https://blog.ruanbekker.com/blog/2019/05/17/install-blackbox-exporter-to-monitor-websites-with-prometheus/">this post</a> if you have not seen the previous tutorial.</p>

<h2>Install Alertmanager</h2>

<p>Create the user for alertmanager:</p>

<pre><code>$ useradd --no-create-home --shell /bin/false alertmanager
</code></pre>

<p>Download alertmanager and extract:</p>

<pre><code>$ https://github.com/prometheus/alertmanager/releases/download/v0.17.0/alertmanager-0.17.0.linux-amd64.tar.gz
$ tar -xvf alertmanager-0.17.0.linux-amd64.tar.gz
</code></pre>

<p>Move alertmanager and amtool birnaries in place:</p>

<pre><code>$ cp alertmanager-0.17.0.linux-amd64/alertmanager /usr/local/bin/
$ cp alertmanager-0.17.0.linux-amd64/amtool /usr/local/bin/
</code></pre>

<p>Ensure that the correct permissions are in place:</p>

<pre><code>$ chown alertmanager:alertmanager /usr/local/bin/alertmanager
$ chown alertmanager:alertmanager /usr/local/bin/amtool
</code></pre>

<p>Cleanup:</p>

<pre><code>$ rm -rf alertmanager-0.17.0*
</code></pre>

<h2>Configure Alertmanager:</h2>

<p>Create the alertmanager directory and configure the global alertmanager configuration:</p>

<pre><code>$ mkdir /etc/alertmanager
$ vim /etc/alertmanager/alertmanager.yml
</code></pre>

<p>Provide the global config and ensure to populate your personal information. See <a href="https://blog.ruanbekker.com/blog/2019/04/18/setup-a-slack-webhook-for-sending-messages-from-applications/">this post</a> to create a slack webhook.</p>

<pre><code>global:
  smtp_smarthost: 'smtp.domain.net:587'
  smtp_from: 'AlertManager &lt;mailer@domain.com&gt;'
  smtp_require_tls: true
  smtp_hello: 'alertmanager'
  smtp_auth_username: 'username'
  smtp_auth_password: 'password'

  slack_api_url: 'https://hooks.slack.com/services/x/xx/xxx'

route:
  group_by: ['instance', 'alert']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 3h
  receiver: team-1

receivers:
  - name: 'team-1'
    email_configs:
      - to: 'user@domain.com'
    slack_configs:
      # https://prometheus.io/docs/alerting/configuration/#slack_config
      - channel: 'system_events'
      - username: 'AlertManager'
      - icon_emoji: ':joy:'
</code></pre>

<p>Ensure the permissions are in place:</p>

<pre><code>$ chown alertmanager:alertmanager -R /etc/alertmanager
</code></pre>

<p>Create the alertmanager systemd unit file:</p>

<pre><code>$ vim /etc/systemd/system/alertmanager.service
</code></pre>

<p>And supply the unit file configuration. Note that I am exposing port <code>9093</code> directly as Im not using a reverse proxy.</p>

<pre><code>[Unit]
Description=Alertmanager
Wants=network-online.target
After=network-online.target

[Service]
User=alertmanager
Group=alertmanager
Type=simple
WorkingDirectory=/etc/alertmanager/
ExecStart=/usr/local/bin/alertmanager --config.file=/etc/alertmanager/alertmanager.yml --web.external-url http://0.0.0.0:9093

[Install]
WantedBy=multi-user.target
</code></pre>

<p>Now we need to inform prometheus that we will send alerts to alertmanager to it&rsquo;s exposed port:</p>

<pre><code>$ vim /etc/prometheus/prometheus.yml
</code></pre>

<p>And supply the alertmanager configuration for prometheus:</p>

<pre><code>...
alerting:
  alertmanagers:
  - static_configs:
    - targets:
      - localhost:9093
...
</code></pre>

<p>So when we get alerted, our alert will include a link to our alert. We need to provide the base url of that alert. That get&rsquo;s done in our alertmanager systemd unit file: <code>/etc/systemd/system/alertmanager.service</code> under <code>--web.external-url</code> passing the alertmanager base ip address:</p>

<pre><code>[Unit]
Description=Alertmanager
Wants=network-online.target
After=network-online.target

[Service]
User=alertmanager
Group=alertmanager
Type=simple
WorkingDirectory=/etc/alertmanager/
ExecStart=/usr/local/bin/alertmanager --config.file=/etc/alertmanager/alertmanager.yml --web.external-url http://&lt;your.alertmanager.ip.address&gt;:9093

[Install]
WantedBy=multi-user.target
</code></pre>

<p>Then we need to do the same with the prometheus systemd unit file: <code>/etc/systemd/system/prometheus.service</code> under <code>--web.external-url</code> passing the prometheus base ip address:</p>

<pre><code>[Unit]
Description=Prometheus
Wants=network-online.target
After=network-online.target

[Service]
User=prometheus
Group=prometheus
Type=simple
ExecStart=/usr/local/bin/prometheus \
    --config.file /etc/prometheus/prometheus.yml \
    --storage.tsdb.path /var/lib/prometheus/ \
    --web.console.templates=/etc/prometheus/consoles \
    --web.console.libraries=/etc/prometheus/console_libraries \
    --web.external-url http://&lt;your.prometheus.ip.address&gt;

[Install]
WantedBy=multi-user.target
</code></pre>

<p>Since we have edited the systemd unit files, we need to reload the systemd daemon:</p>

<pre><code>$ systemctl daemon-reload
</code></pre>

<p>Then restart prometheus and alertmanager:</p>

<pre><code>$ systemctl restart prometheus
$ systemctl restart alertmanager
</code></pre>

<p>Inspect the status of alertmanager and prometheus:</p>

<pre><code>$ systemctl status alertmanager
$ systemctl status prometheus
</code></pre>

<p>If everything seems good, enable alertmanager on boot:</p>

<pre><code>$ systemctl enable alertmanager
</code></pre>

<h2>Access Alertmanager:</h2>

<p>Access alertmanager on your endpoint on port <code>9093</code>:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57946361-69856980-78dc-11e9-8c48-ebcc3b0d201e.png" alt="alertmanager" /></p>

<p>From our previous tutorial we started a local web service on port <code>8080</code> that is being monitored by prometheus. Let&rsquo;s stop that service to test out the alerting. You should get a notification via email:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57946586-f29ca080-78dc-11e9-983c-6b857ef21bae.png" alt="alertmanager" /></p>

<p>And the notification via slack:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57946602-03e5ad00-78dd-11e9-9ecc-c3d58b2ad3ec.png" alt="alertmanager" /></p>

<p>When you start the service again and head over to the prometheus ui under alerts, you will see that the service recovered:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57946647-2677c600-78dd-11e9-95a9-b9f4190172bf.png" alt="prometheus" /></p>

<h2>Install Prometheus Alertmanager Plugin</h2>

<p>Install the Prometheus Alertmanager Plugin in Grafana. Head to the instance where grafana is installed and install the plugin:</p>

<pre><code>$ grafana-cli plugins install camptocamp-prometheus-alertmanager-datasource
</code></pre>

<p>Once the plugin is installed, restart grafana:</p>

<pre><code>$ service grafana-server restart
</code></pre>

<p>Install the dasboard <a href="https://grafana.com/dashboards/8010">grafana.com/dashboards/8010</a>. Create a new datasource, select the prometheus-alertmanager datasource, configure and save.</p>

<p>Add a new dasboard, select import and provide the ID <code>8010</code>, select the prometheus-alertmanager datasource and save. You should see the following (more or less):</p>

<p><img src="https://user-images.githubusercontent.com/567298/57947092-3f34ab80-78de-11e9-904b-f42d5ecd7d0a.png" alt="prometheus-alertmanager" /></p>

<h2>Resources</h2>

<p>See all <a href="https://blog.ruanbekker.com/blog/categories/prometheus/">#prometheus</a> blogposts</p>
]]></content>
  </entry>
  
</feed>
