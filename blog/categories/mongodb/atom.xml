<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mongodb | Ruan Bekker's Blog]]></title>
  <link href="https://blog.ruanbekker.com/blog/categories/mongodb/atom.xml" rel="self"/>
  <link href="https://blog.ruanbekker.com/"/>
  <updated>2023-12-22T00:45:53-05:00</updated>
  <id>https://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Getting Started With FerretDB on Docker]]></title>
    <link href="https://blog.ruanbekker.com/blog/2023/06/14/getting-started-with-ferretdb-on-docker/"/>
    <updated>2023-06-14T22:00:00-04:00</updated>
    <id>https://blog.ruanbekker.com/blog/2023/06/14/getting-started-with-ferretdb-on-docker</id>
    <content type="html"><![CDATA[<p><img src="https://blog.ruanbekker.com/images/how-to-run-ferretdb-on-docker.png" alt="how-to-run-ferretdb-on-docker" /></p>

<p>In this post we will have a look at <strong>FerretDB</strong> which is a opensource proxy that translates MongoDB queries to SQL, where PostgreSQL being the database engine.</p>

<h2>More about FerretDB</h2>

<p>From <a href="https://www.ferretdb.io/">FerretDB</a> website, they describe FerretDB as:</p>

<blockquote><p>Initially built as open-source software, MongoDB was a game-changer for many developers, enabling them to build fast and robust applications. Its ease of use and extensive documentation made it a top choice for many developers looking for an open-source database. However, all this changed when they switched to an SSPL license, moving away from their open-source roots.</p>

<p>In light of this, FerretDB was founded to become the true open-source alternative to MongoDB, making it the go-to choice for most MongoDB users looking for an open-source alternative to MongoDB. With FerretDB, users can run the same MongoDB protocol queries without needing to learn a new language or command.</p></blockquote>

<h2>What can you expect from this tutorial</h2>

<p>We will be doing the following:</p>

<ul>
<li>deploying ferretdb and postgres on docker containers using docker compose</li>
<li>then use <code>mongosh</code> as a client to logon to ferretdb using the ferretdb endpoint</li>
<li>explore some example queries to insert and read data from ferretdb</li>
<li>use scripting to generate data into ferretedb</li>
<li>explore the embedded prometheus endpoint for metrics</li>
</ul>


<h2>Deploy FerretDB</h2>

<p>The following <code>docker-compose.yaml</code> defines a postgres container which will be used as the database engine for ferretdb, and then we define the ferretdb container, which connects to postgres via the environment variable <code>FERRETDB_POSTGRESQL_URL</code>.</p>

<pre><code class="yml">version: "3.9"

services:
  postgres:
    image: postgres:14.8-bullseye
    container_name: postgres
    restart: unless-stopped
    environment:
      - POSTGRES_USER=ferret
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=ferretdb
    volumes:
      - pgvol:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready", "-d", "db_prod"]
      interval: 30s
      timeout: 15s
      retries: 5
      start_period: 60s
    networks:
      - ferretdb
    logging:
      driver: "json-file"
      options:
        max-size: "1m"
        max-file: "1"

  ferretdb:
    image: ghcr.io/ferretdb/ferretdb:1.1.0
    container_name: ferretdb
    restart: unless-stopped
    ports:
      - 27017:27017
      - 8080:8080
    environment:
      - FERRETDB_POSTGRESQL_URL=postgres://postgres:5432/ferretdb
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - ferretdb
    logging:
      driver: "json-file"
      options:
        max-size: "1m"
        max-file: "1"

networks:
  ferretdb:
    name: ferretdb

volumes:
  pgvol: 
</code></pre>

<p>Once you have the content above saved in <code>docker-compose.yaml</code> you can run the following to run the containers in a detached mode:</p>

<pre><code class="bash">docker-compose up -d
</code></pre>

<h2>Connect to FerretDB</h2>

<p>Once the containers started, we can connect to our ferretdb server using mongosh, which is a shell utility to connect to the database). I will make use of a container to do this, where I will reference the network which we defined in our docker compose file, and set the endpoint that mongosh need to connect to:</p>

<pre><code class="bash">docker run --rm -it --network=ferretdb --entrypoint=mongosh mongo:6.0 "mongodb://ferret:password@ferretdb/ferretdb?authMechanism=PLAIN"
</code></pre>

<p>Once it successfully connects to ferretdb, we should see the following prompt:</p>

<pre><code class="bash">Current Mongosh Log ID: 64626c5c259916d1a68b7dad
Connecting to:      mongodb://&lt;credentials&gt;@ferretdb/ferretdb?authMechanism=PLAIN&amp;directConnection=true&amp;appName=mongosh+1.8.2
Using MongoDB:      6.0.42
Using Mongosh:      1.8.2

ferretdb&gt;
</code></pre>

<h2>Run example queries on FerretDB</h2>

<p>If you are familiar with MongoDB, you will find the following identical to MongoDB.</p>

<p>First we show the current databases:</p>

<pre><code class="bash">ferretdb&gt; show dbs;
public  0 B
</code></pre>

<p>The we create and use the database named <code>mydb</code>:</p>

<pre><code class="bash">ferretdb&gt; use mydb
switched to db mydb
</code></pre>

<p>To see which database are we currently connected to:</p>

<pre><code class="bash">mydb&gt; db
mydb
</code></pre>

<p>Now we can create a collection named <code>mycol1</code> and <code>mycol2</code>:</p>

<pre><code class="bash">mydb&gt; db.createCollection("mycol1")
{ ok: 1 }
mydb&gt; db.createCollection("mycol2")
{ ok: 1 }
</code></pre>

<p>We can view our collections by running the following:</p>

<pre><code class="bash">mydb&gt; show collections
mycol1
mycol2
</code></pre>

<p>To write one document into our collection named <code>col1</code> with the following data:</p>

<pre><code class="json">{
  "name": "ruan",
  "age": 32,
  "hobbies": [
    "golf",
    "programming",
    "music"
  ]
}
</code></pre>

<p>We can execute:</p>

<pre><code class="bash">mydb&gt; db.mycol1.insertOne({"name": "ruan", "age": 32, "hobbies": ["golf", "programming", "music"]})
{
  acknowledged: true,
  insertedIds: { '0': ObjectId("64626cea259916d1a68b7dae") }
}
</code></pre>

<p>And we can insert another document:</p>

<pre><code class="bash">mydb&gt; db.mycol1.insertOne({"name": "michelle", "age": 28, "hobbies": ["art", "music", "reading"]})
{
  acknowledged: true,
  insertedIds: { '0': ObjectId("64626cf1259916d1a68b7daf") }
}
</code></pre>

<p>We can then use <code>countDocuments()</code> to view the number of documents in our collection named <code>mycol1</code>:</p>

<pre><code class="bash">ferretdb&gt; db.mycol1.countDocuments()
2
</code></pre>

<p>If we want to find all our documents in our <code>mycol1</code> collection:</p>

<pre><code class="bash">mydb&gt; db.mycol1.find()
[
  {
    _id: ObjectId("64626cea259916d1a68b7dae"),
    name: 'ruan',
    age: 32,
    hobbies: [ 'golf', 'programming', 'music' ]
  },
  {
    _id: ObjectId("64626cf1259916d1a68b7daf"),
    name: 'michelle',
    age: 28,
    hobbies: [ 'art', 'music', 'reading' ]
  }
]
</code></pre>

<p>If we want to only display specific fields in our response, such as name and age, we can project fields to return from our query:</p>

<pre><code class="bash">mydb&gt; db.mycol1.find({}, {"name": 1, "age": 1})
[
  { _id: ObjectId("64626cea259916d1a68b7dae"), name: 'ruan', age: 32 },
  {
    _id: ObjectId("64626cf1259916d1a68b7daf"),
    name: 'michelle',
    age: 28
  }
]
</code></pre>

<p>We can also suppress the <code>_id</code> field by setting the value to <code>0</code>:</p>

<pre><code class="bash">mydb&gt; db.mycol1.find({}, {"_id": 0, "name": 1, "age": 1})
[
  { name: 'ruan', age: 32 },
  { name: 'michelle', age: 28 }
]
</code></pre>

<p>Next we can return all the fields name and age from our collection where the age field is equals to 32:</p>

<pre><code class="bash">mydb&gt; db.mycol1.find({"age": 32}, {"_id": 0, "name": 1, "age": 1})
[ { name: 'ruan', age: 32 } ]
</code></pre>

<p>We can also find a specific document by its id as example, and return only the field value, like name:</p>

<pre><code class="bash">mydb&gt; db.mycol1.findOne({_id: ObjectId("64626cea259916d1a68b7dae")}).name
ruan
</code></pre>

<p>Next we will find all documents where the age is greater than 30:</p>

<pre><code class="bash">mydb&gt; db.mycol1.find({"age": {"$gt": 30}})
[
  {
    _id: ObjectId("64626cea259916d1a68b7dae"),
    name: 'ruan',
    age: 32,
    hobbies: [ 'golf', 'programming', 'music' ]
  }
]
</code></pre>

<p>Let&rsquo;s explore how to insert many documents at once using <code>insertMany()</code>, first create a new collection:</p>

<pre><code class="bash">ferretdb&gt; db.createCollection("mycol2")
{ ok: 1 }
</code></pre>

<p>We can then define the docs variable, and assign a array with 2 json documents:</p>

<pre><code class="bash">ferretdb&gt; var docs = [{name: "peter", age: 34, hobbies: ["ski", "programming", "music"]}, {name: "sam", age: 39, hobbies: ["running", "camping", "music"]}]
</code></pre>

<p>Now we can insert our documents to ferretdb using <code>insertMany()</code>:</p>

<pre><code class="bash">ferretdb&gt; db.mycol2.insertMany(docs)
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId("6464ceb1413cee26e9bf709f"),
    '1': ObjectId("6464ceb1413cee26e9bf70a0")
  }
}
</code></pre>

<p>We can count the documents inside our collection using:</p>

<pre><code class="bash">ferretdb&gt; db.mycol2.countDocuments()
2
</code></pre>

<p>And we can search for all the documents inside the collection:</p>

<pre><code class="bash">ferretdb&gt; db.mycol2.find()
[
  {
    _id: ObjectId("6464ceb1413cee26e9bf709f"),
    name: 'peter',
    age: 34,
    hobbies: [ 'ski', 'programming', 'music' ]
  },
  {
    _id: ObjectId("6464ceb1413cee26e9bf70a0"),
    name: 'sam',
    age: 39,
    hobbies: [ 'running', 'camping', 'music' ]
  }
]
</code></pre>

<p>And searching for any data using the name <code>peter</code>:</p>

<pre><code class="bash">ferretdb&gt; db.mycol2.find({name: "peter"})
[
  {
    _id: ObjectId("6464ceb1413cee26e9bf709f"),
    name: 'peter',
    age: 34,
    hobbies: [ 'ski', 'programming', 'music' ]
  }
]
</code></pre>

<h2>Scripting</h2>

<p>We will create a script so that we can generate data that we want to write into FerretDB.</p>

<p>Create the following script, <code>write.js</code>:</p>

<pre><code>var txs = []
for (var x = 0; x &lt; 1000 ; x++) {
 var transaction_types = ["credit card", "cash", "account"];
 var store_names = ["edgards", "cna", "makro", "picknpay", "checkers"];
 var random_transaction_type = Math.floor(Math.random() * (2 - 0 + 1)) + 0;
 var random_store_name = Math.floor(Math.random() * (4 - 0 + 1)) + 0;
 var random_age = Math.floor(Math.random() * (80 - 18) + 18)
 txs.push({
   transaction: 'tx_' + x,
   transaction_price: Math.round(Math.random()*1000),
   transaction_type: transaction_types[random_transaction_type],
   store_name: store_names[random_store_name],
   age: random_age
   });
}
console.log("drop and recreate the collection")
db.mycollection1.drop()
db.createCollection("mycollection1")
console.log("insert documents into collection")
db.mycollection1.insertMany(txs)
</code></pre>

<p>The script will loop a 1000 times and create documents that will include fields of <code>transaction_types</code>, <code>store_names</code>, <code>random_transaction_type</code>, <code>random_store_name</code> and <code>random_age</code>.</p>

<p>Use docker, mount the file inside the container, point the database endpoint to ferretdb and load the file that we want to execute:</p>

<pre><code class="bash">docker run --rm -it --network=ferretdb -v $PWD/write.js:/src/write.js --entrypoint=mongosh mongo:6.0 "mongodb://ferret:password@ferretdb/ferretdb?authMechanism=PLAIN" --eval 'load("/src/write.js")'
</code></pre>

<p>Now when we run a mongosh client:</p>

<pre><code class="bash">docker run --rm -it --network=ferretdb -v $PWD/write.js:/src/write.js --entrypoint=mongosh mongo:6.0 "mongodb://ferret:password@ferretdb/ferretdb?authMechanism=PLAIN"
</code></pre>

<p>And we query for the <code>store_name: picknpay</code> and only show the <code>transaction_type</code> and <code>transaction</code> fields:</p>

<pre><code class="bash">ferretdb&gt; db.mycollection1.find({"store_name": "picknpay"}, {_id: 0, transaction_type: 1, transaction: 1})
[
  { transaction_type: 'credit card', transaction: 'tx_3' },
  { transaction_type: 'cash', transaction: 'tx_9' },
  { transaction_type: 'account', transaction: 'tx_10' },
  { transaction_type: 'credit card', transaction: 'tx_15' },
  { transaction_type: 'credit card', transaction: 'tx_19' },
  { transaction_type: 'cash', transaction: 'tx_21' },
  { transaction_type: 'cash', transaction: 'tx_28' },
  { transaction_type: 'account', transaction: 'tx_31' },
  { transaction_type: 'cash', transaction: 'tx_37' },
  { transaction_type: 'cash', transaction: 'tx_39' },
  { transaction_type: 'account', transaction: 'tx_40' },
  { transaction_type: 'cash', transaction: 'tx_51' },
  { transaction_type: 'account', transaction: 'tx_52' },
  { transaction_type: 'cash', transaction: 'tx_58' },
  { transaction_type: 'credit card', transaction: 'tx_62' },
  { transaction_type: 'credit card', transaction: 'tx_65' },
  { transaction_type: 'account', transaction: 'tx_69' },
  { transaction_type: 'account', transaction: 'tx_71' },
  { transaction_type: 'cash', transaction: 'tx_72' },
  { transaction_type: 'account', transaction: 'tx_74' }
]
</code></pre>

<p>We can also use the <code>--eval</code> flag with the mongosh container to run ad-hoc queries such as counting documents for a collection:</p>

<pre><code class="bash">docker run --rm -it --network=ferretdb \
  -v $PWD/write.js:/src/write.js:ro \
  --entrypoint=mongosh mongo:6.0 \
  "mongodb://ferret:password@ferretdb/ferretdb?authMechanism=PLAIN" --eval 'db.mycollection1.countDocuments()'
</code></pre>

<h2>Prometheus Metrics</h2>

<p>FerretDB provides prometheus metrics out of the box, and outputs prometheus metrics on the <code>:8080/debug/metrics</code> endpoint:</p>

<pre><code class="bash">curl http://localhost:8080/debug/metrics
</code></pre>

<p>Which will output metrics more or less like the following:</p>

<pre><code>ferretdb_client_accepts_total{error="0"} 98
ferretdb_client_connected 0
ferretdb_client_requests_total{command="aggregate",opcode="OP_MSG"} 5
ferretdb_client_requests_total{command="atlasVersion",opcode="OP_MSG"} 27
ferretdb_client_requests_total{command="buildInfo",opcode="OP_MSG"} 27
ferretdb_client_requests_total{command="buildinfo",opcode="OP_MSG"} 2
ferretdb_client_requests_total{command="count",opcode="OP_MSG"} 5
ferretdb_client_requests_total{command="create",opcode="OP_MSG"} 7
ferretdb_client_requests_total{command="drop",opcode="OP_MSG"} 3
ferretdb_client_requests_total{command="dropDatabase",opcode="OP_MSG"} 4
ferretdb_client_requests_total{command="find",opcode="OP_MSG"} 27
ferretdb_client_requests_total{command="getCmdLineOpts",opcode="OP_MSG"} 27
ferretdb_client_requests_total{command="getFreeMonitoringStatus",opcode="OP_MSG"} 20
ferretdb_client_requests_total{command="getLog",opcode="OP_MSG"} 20
ferretdb_client_requests_total{command="getParameter",opcode="OP_MSG"} 27
ferretdb_client_requests_total{command="hello",opcode="OP_MSG"} 20
ferretdb_client_requests_total{command="insert",opcode="OP_MSG"} 15
ferretdb_client_requests_total{command="ismaster",opcode="OP_MSG"} 238
ferretdb_client_requests_total{command="listCollections",opcode="OP_MSG"} 49
ferretdb_client_requests_total{command="listDatabases",opcode="OP_MSG"} 12
ferretdb_client_requests_total{command="ping",opcode="OP_MSG"} 40
ferretdb_client_requests_total{command="saslStart",opcode="OP_MSG"} 70
ferretdb_client_requests_total{command="setFreeMonitoring",opcode="OP_MSG"} 1
ferretdb_client_requests_total{command="unknown",opcode="OP_QUERY"} 96
ferretdb_client_responses_total{argument="unknown",command="aggregate",opcode="OP_MSG",result="ok"} 5
ferretdb_client_responses_total{argument="unknown",command="atlasVersion",opcode="OP_MSG",result="CommandNotFound"} 27
ferretdb_client_responses_total{argument="unknown",command="buildInfo",opcode="OP_MSG",result="ok"} 27
ferretdb_client_responses_total{argument="unknown",command="buildinfo",opcode="OP_MSG",result="ok"} 2
ferretdb_client_responses_total{argument="unknown",command="count",opcode="OP_MSG",result="ok"} 5
ferretdb_client_responses_total{argument="unknown",command="create",opcode="OP_MSG",result="ok"} 7
ferretdb_client_responses_total{argument="unknown",command="drop",opcode="OP_MSG",result="NamespaceNotFound"} 2
ferretdb_client_responses_total{argument="unknown",command="drop",opcode="OP_MSG",result="ok"} 1
ferretdb_client_responses_total{argument="unknown",command="dropDatabase",opcode="OP_MSG",result="ok"} 4
ferretdb_client_responses_total{argument="unknown",command="find",opcode="OP_MSG",result="ok"} 27
ferretdb_client_responses_total{argument="unknown",command="getCmdLineOpts",opcode="OP_MSG",result="ok"} 27
ferretdb_client_responses_total{argument="unknown",command="getFreeMonitoringStatus",opcode="OP_MSG",result="ok"} 20
ferretdb_client_responses_total{argument="unknown",command="getLog",opcode="OP_MSG",result="ok"} 20
ferretdb_client_responses_total{argument="unknown",command="getParameter",opcode="OP_MSG",result="Unset"} 27
ferretdb_client_responses_total{argument="unknown",command="hello",opcode="OP_MSG",result="ok"} 20
ferretdb_client_responses_total{argument="unknown",command="insert",opcode="OP_MSG",result="ok"} 15
ferretdb_client_responses_total{argument="unknown",command="ismaster",opcode="OP_MSG",result="ok"} 238
ferretdb_client_responses_total{argument="unknown",command="listCollections",opcode="OP_MSG",result="ok"} 49
ferretdb_client_responses_total{argument="unknown",command="listDatabases",opcode="OP_MSG",result="ok"} 12
ferretdb_client_responses_total{argument="unknown",command="ping",opcode="OP_MSG",result="ok"} 40
ferretdb_client_responses_total{argument="unknown",command="saslStart",opcode="OP_MSG",result="ok"} 70
ferretdb_client_responses_total{argument="unknown",command="setFreeMonitoring",opcode="OP_MSG",result="ok"} 1
ferretdb_client_responses_total{argument="unknown",command="unknown",opcode="OP_REPLY",result="ok"} 93
ferretdb_client_responses_total{argument="unknown",command="unknown",opcode="OP_REPLY",result="unhandled"} 3
ferretdb_up{branch="unknown",commit="3344cbb98bb744dd044bcf2d51fe9ab65db22f0b",debug="false",dirty="true",package="docker",telemetry="disabled",update_available="false",uuid="08174d33-05fd-45ed-adb9-d2e343e0af83",version="v1.1.0"} 1
process_cpu_seconds_total 16.98
process_max_fds 1.048576e+06
process_open_fds 13
process_resident_memory_bytes 2.5714688e+07
process_start_time_seconds 1.68425346762e+09
process_virtual_memory_bytes 7.52529408e+08
process_virtual_memory_max_bytes 1.8446744073709552e+19
promhttp_metric_handler_errors_total{cause="encoding"} 0
promhttp_metric_handler_errors_total{cause="gathering"} 0
promhttp_metric_handler_requests_in_flight 1
promhttp_metric_handler_requests_total{code="200"} 2
promhttp_metric_handler_requests_total{code="500"} 0
promhttp_metric_handler_requests_total{code="503"} 0
</code></pre>

<h2>Resources</h2>

<p>Please see the follwoing resources for FerretDB:</p>

<ul>
<li><a href="https://docs.ferretdb.io/">https://docs.ferretdb.io/</a></li>
<li><a href="https://github.com/ferretdb/FerretDB/pkgs/container/ferretdb">https://github.com/ferretdb/FerretDB/pkgs/container/ferretdb</a></li>
<li><a href="https://docs.ferretdb.io/quickstart-guide/docker/">https://docs.ferretdb.io/quickstart-guide/docker/</a></li>
<li><a href="https://github.com/ruanbekker/cheatsheets/tree/master/mongodb/shell">https://github.com/ruanbekker/cheatsheets/tree/master/mongodb/shell</a></li>
</ul>


<h2>Thank You</h2>

<p>Thanks for reading, feel free to check out my <a href="https://ruan.dev/">website</a>, feel free to subscribe to my <a href="http://digests.ruanbekker.com/?via=ruanbekker-blog">newsletter</a> or follow me at <a href="https://twitter.com/ruanbekker">@ruanbekker</a> on Twitter.</p>

<ul>
<li>Linktree: <a href="https://go.ruan.dev/links">https://go.ruan.dev/links</a></li>
<li>Patreon: <a href="https://go.ruan.dev/patreon">https://go.ruan.dev/patreon</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using MongoDB Inside Drone CI Services for Unit Testing]]></title>
    <link href="https://blog.ruanbekker.com/blog/2019/05/04/using-mongodb-inside-drone-ci-services-for-unit-testing/"/>
    <updated>2019-05-04T14:52:37-04:00</updated>
    <id>https://blog.ruanbekker.com/blog/2019/05/04/using-mongodb-inside-drone-ci-services-for-unit-testing</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/57184017-4b1f7700-6eb5-11e9-886d-4b811687221a.png" alt="" /></p>

<p>Another nice thing about Drone CI is the &ldquo;Services&rdquo; configuration within your pipeline. At times your unit or integration testing steps might be dependent of a database such as MongoDB, MySQL etc.</p>

<p>Drone allows you to spin up a ephemeral database service such as MongoDB using a Docker container as the fist step within your pipeline, defined in the services section. This step will always run first.</p>

<p>The service container will be reachable via the configured container name as its hostname. Keep note that if you run multiple paralel jobs that the service container will only be reachable from the container where the mongodb container is running.</p>

<h2>What are we doing today</h2>

<p>We will setup a really basic (and a bit useless) pipeline that will spin up a mongodb service container, use a step to write random data to mongodb and a step that reads data from mongodb.</p>

<p>For demonstration purposes, the data is really random but more focused on the service section.</p>

<p>All the source code for this demonstration is available on my <strong><a href="https://github.com/ruanbekker/demo-drone-mongodb-tests">github repository</a></strong></p>

<h2>Our Drone Pipeline</h2>

<p>First we define our service, mongodb. Once the mongodb service is running, we will have our build step, our step that runs the mongodb version against our database, write data into our mongodb database, then read the data from mongodb, then the last step running a shell command with the date.</p>

<p>Our <code>.drone.yml</code> pipeline definition:</p>

<pre><code class="yaml">---
kind: pipeline
name: mongotests

services:
- name: mongo
  image: mongo:4
  command: [ --smallfiles ]
  ports:
  - 27017

steps:
- name: build-step
  image: alpine
  commands:
  - echo "this should be a step that does something"

- name: mongodb-return-version
  image: mongo:4
  commands:
  - date
  - mongo --host mongo --eval "db.version()"

- name: mongodb-test-writes
  image: mongo:4
  commands:
  - date
  - sh scripts/write_mongo.sh

- name: mongodb-test-reads
  image: mongo:4
  commands:
  - date
  - sh scripts/read_mongo.sh

- name: last-step
  image: alpine
  commands:
  - echo "completed at $(date)"
</code></pre>

<p>Our scripts referenced in our steps:</p>

<p>The first will be our script that write random data into mongodb, <code>scripts/write_mongo.sh</code>:</p>

<pre><code class="bash">#!/bin/sh
set -ex
echo "start writing"
mongo mongo:27017/mydb scripts/write.js
echo "done writing"
</code></pre>

<p>We are referencing a <code>scripts/write.js</code> file which is a function that randomizes data and generates a 1000 documents to write to mongodb:</p>

<pre><code class="javascript">var txs = []
for (var x = 0; x &lt; 1000 ; x++) {
 var transaction_types = ["credit card", "cash", "account"];
 var store_names = ["edgards", "cna", "makro", "picknpay", "checkers"];
 var random_transaction_type = Math.floor(Math.random() * (2 - 0 + 1)) + 0;
 var random_store_name = Math.floor(Math.random() * (4 - 0 + 1)) + 0;
 txs.push({
   transaction: 'tx_' + x,
   transaction_price: Math.round(Math.random()*1000),
   transaction_type: transaction_types[random_transaction_type],
   store_name: store_names[random_store_name]
   });
}
db.mycollection.insert(txs)
</code></pre>

<p>Our script that will read data from mongodb, <code>scripts/read_mongo.sh</code>:</p>

<pre><code>#!/bin/sh
set -ex
echo "start reading"
mongo mongo:27017/mydb &lt;&lt;EOF
db.mycollection.find().count();
db.mycollection.find({transaction_price: { \$gt: 990}}).forEach( printjson );
EOF
echo "done reading"
</code></pre>

<p>The <code>README.md</code> to include the build status:</p>

<pre><code>## project-name ![](https://cloud.drone.io/api/badges/&lt;user-name&gt;/&lt;project-name&gt;/status.svg?branch=master)
</code></pre>

<p>Once your source code is set in github, enable the repository on drone and push to github to trigger the build.</p>

<h2>Demo and Screenshots</h2>

<p>After pushing to github to trigger the build, heading over to drone, I can see that mongodb is running and our step has completed that executes the <code>db.version()</code> against mongodb:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183883-317d3000-6eb3-11e9-9aa0-7dd729514033.png" alt="" /></p>

<p>Next our step executes to write the random data into mongodb:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183911-989ae480-6eb3-11e9-942a-a9c1af191b7f.png" alt="" /></p>

<p>After the data has been written to mongodb, our next step will read the number of documents from mongodb, and also run a query for transaction prices more than 990:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183917-bc5e2a80-6eb3-11e9-802d-87e268b2fc43.png" alt="" /></p>

<p>Once that has completed, we will have a shell command returning the time when the last step completed:</p>

<p><img src="https://user-images.githubusercontent.com/567298/57183934-fa5b4e80-6eb3-11e9-9eb3-e58248e2286c.png" alt="" /></p>

<h2>Resources</h2>

<ul>
<li><a href="https://cloud.drone.io">Drone Hosted Service</a></li>
<li><a href="https://docs.drone.io/user-guide/pipeline/services/">Drone Services Documentation</a></li>
<li><a href="https://github.com/ruanbekker/demo-drone-mongodb-tests">Github Repository</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB Examples With Golang]]></title>
    <link href="https://blog.ruanbekker.com/blog/2019/04/17/mongodb-examples-with-golang/"/>
    <updated>2019-04-17T08:51:35-04:00</updated>
    <id>https://blog.ruanbekker.com/blog/2019/04/17/mongodb-examples-with-golang</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/55478904-236e9200-561d-11e9-9382-f31b25a9ae03.png" alt="" /></p>

<p>While looking into working with mongodb using golang, I found it quite frustrating getting it up and running and decided to make a quick post about it.</p>

<p><a href="https://github.com/ruanbekker/cheatsheets" target="_blank"><img alt="ruanbekker-cheatsheets" src="https://user-images.githubusercontent.com/567298/169162832-ef3019de-bc49-4d6c-b2a6-8ac17c457d24.png"></a></p>

<h2>What are we doing?</h2>

<p>Examples using the golang driver for mongodb to connect, read, update and delete documents from mongodb.</p>

<h2>Environment:</h2>

<p>Provision a mongodb server in docker:</p>

<pre><code>$ docker network create container-net
$ docker run -itd --name mongodb --network container-net -p 27017:27017 ruanbekker/mongodb
</code></pre>

<p>Drop into a golang environment using docker:</p>

<pre><code>$ docker run -it golang:alpine sh
</code></pre>

<p>Get the dependencies:</p>

<pre><code>$ apk add --no-cache git
</code></pre>

<p>Change to your project path:</p>

<pre><code>$ mkdir $GOPATH/src/myapp
$ cd $GOPATH/src/myapp
</code></pre>

<p>Download the golang mongodb driver:</p>

<pre><code>$ go get go.mongodb.org/mongo-driver
</code></pre>

<h2>Connecting to MongoDB in Golang</h2>

<p>First example will be to connect to your mongodb instance:</p>

<pre><code class="go">package main

import (
    "context"
    "fmt"
    "log"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/mongo/options"
)

type Person struct {
    Name string
    Age  int
    City string
}

func main() {
    clientOptions := options.Client().ApplyURI("mongodb://mongodb:27017")
    client, err := mongo.Connect(context.TODO(), clientOptions)

    if err != nil {
        log.Fatal(err)
    }

    err = client.Ping(context.TODO(), nil)

    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("Connected to MongoDB!")

}
</code></pre>

<p>Running our app:</p>

<pre><code class="bash">$ go run main.go
Connected to MongoDB!
</code></pre>

<h2>Writing to MongoDB with Golang</h2>

<p>Let&rsquo;s insert a single document to MongoDB:</p>

<pre><code class="go">func main() {
    ..
    collection := client.Database("mydb").Collection("persons")

    ruan := Person{"Ruan", 34, "Cape Town"}

    insertResult, err := collection.InsertOne(context.TODO(), ruan)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("Inserted a Single Document: ", insertResult.InsertedID)
}
</code></pre>

<p>Running it will produce:</p>

<pre><code class="bash">$ go run main.go
Connected to MongoDB!
Inserted a single document:  ObjectID("5cb717dcf597b4411252341f")
</code></pre>

<p>Writing more than one document:</p>

<pre><code>func main() {
    ..
    collection := client.Database("mydb").Collection("persons")

    ruan := Person{"Ruan", 34, "Cape Town"}
    james := Person{"James", 32, "Nairobi"}
    frankie := Person{"Frankie", 31, "Nairobi"}

    trainers := []interface{}{james, frankie}

    insertManyResult, err := collection.InsertMany(context.TODO(), trainers)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("Inserted multiple documents: ", insertManyResult.InsertedIDs)
}
</code></pre>

<p>This will output in:</p>

<pre><code class="bash">$ go run main.go
Inserted Multiple Documents:  [ObjectID("5cb717dcf597b44112523420") ObjectID("5cb717dcf597b44112523421")]
</code></pre>

<h2>Updating Documents in MongoDB using Golang</h2>

<p>Updating Frankie&rsquo;s age:</p>

<pre><code>func main() {
    ..
    filter := bson.Dname
    update := bson.D{
        {"$inc", bson.D{
            {"age", 1},
        }},
    }

    updateResult, err := collection.UpdateOne(context.TODO(), filter, update)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Matched %v documents and updated %v documents.\n", updateResult.MatchedCount, updateResult.ModifiedCount)
}
</code></pre>

<p>Running that will update Frankie&rsquo;s age:</p>

<pre><code class="bash">$ go run main.go
Matched 1 documents and updated 1 documents.
</code></pre>

<h2>Reading Data from MongoDB</h2>

<p>Reading the data:</p>

<pre><code class="go">funct main() {
    ..
    filter := bson.Dname
    var result Trainer

    err = collection.FindOne(context.TODO(), filter).Decode(&amp;result)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Found a single document: %+v\n", result)

    findOptions := options.Find()
    findOptions.SetLimit(2)

}
</code></pre>



<pre><code class="bash">$ go run main.go
Found a single document: {Name:Frankie Age:32 City:Nairobi}
</code></pre>

<p>Finding multiple documents and returning the cursor</p>

<pre><code class="go">func main() {
    ..
    var results []*Trainer
    cur, err := collection.Find(context.TODO(), bson.D, findOptions)
    if err != nil {
        log.Fatal(err)
    }

    for cur.Next(context.TODO()) {
        var elem Trainer
        err := cur.Decode(&amp;elem)
        if err != nil {
            log.Fatal(err)
        }

        results = append(results, &amp;elem)
    }

    if err := cur.Err(); err != nil {
        log.Fatal(err)
    }

    cur.Close(context.TODO())
    fmt.Printf("Found multiple documents (array of pointers): %+v\n", results)
}
</code></pre>

<p>Running the example:</p>

<pre><code>$ go run main.go
Found multiple documents (array of pointers): [0xc0001215c0 0xc0001215f0]
</code></pre>

<h2>Deleting Data from MongoDB:</h2>

<p>Deleting our data and closing the connection:</p>

<pre><code class="go">func main(){
    ..
    deleteResult, err := collection.DeleteMany(context.TODO(), bson.D)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Deleted %v documents in the trainers collection\n", deleteResult.DeletedCount)

    err = client.Disconnect(context.TODO())

    if err != nil {
        log.Fatal(err)
    } else {
        fmt.Println("Connection to MongoDB closed.")
    }
}
</code></pre>

<p>Running the example:</p>

<pre><code class="bash">$ go run main.go
Deleted 3 documents in the trainers collection
Connection to MongoDB closed.
</code></pre>

<p>The code for this example can be found at <a href="https://github.com/ruanbekker/code-examples/blob/master/mongodb/golang/examples.go">github.com/ruanbekker/code-examples/mongodb/golang/examples.go</a></p>

<h2>Resources:</h2>

<ul>
<li><a href="https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial">https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create Read Only Users in MongoDB]]></title>
    <link href="https://blog.ruanbekker.com/blog/2018/11/12/create-read-only-users-in-mongodb/"/>
    <updated>2018-11-12T17:02:53-05:00</updated>
    <id>https://blog.ruanbekker.com/blog/2018/11/12/create-read-only-users-in-mongodb</id>
    <content type="html"><![CDATA[<p>In this post I will demonstrate how to setup 2 read only users in MongoDB, one user that will have access to one MongoDB Database and all the Collections, and one user with access to one MongoDB Database and only one Collection.</p>

<script id="mNCC" language="javascript">
    medianet_width = "728";
    medianet_height = "90";
    medianet_crid = "218284798";
    medianet_versionId = "3111299";
  </script>


<script src="//contextual.media.net/nmedianet.js?cid=8CUD78FSV"></script>


<h2>First Method: Creating and Assigning the User</h2>

<p>The first method we will create the user and assign it the read permissions that he needs. In this case read only access to the mytest db.</p>

<p>First logon to mongodb and switch to the admin database:</p>

<pre><code class="bash">$ mongo -u dbadmin -p --authenticationDatabase admin
&gt; use admin
switched to db admin
</code></pre>

<p>Now list the dbs:</p>

<pre><code class="bash">&gt; show dbs
admin       0.000GB
mytest      0.000GB
</code></pre>

<p>List the collections and read the data from it for demonstration purposes:</p>

<pre><code class="bash">&gt; use mytest
&gt; show collections;
col1
col2
&gt; db.col1.find()
{ "_id" : ObjectId("5be3d377b54849bb738e3b6b"), "name" : "ruan" }
&gt; db.col2.find()
{ "_id" : ObjectId("5be3d383b54849bb738e3b6c"), "name" : "stefan" }
</code></pre>

<p>Now create the user collectionreader that will have access to read all the collections from the database:</p>

<pre><code class="bash">$ &gt; db.createUser({user: "collectionreader", pwd: "secretpass", roles: [{role: "read", db: "mytest"}]})
Successfully added user: {
  "user" : "collectionreader",
  "roles" : [
    {
      "role" : "read",
      "db" : "mytest"
    }
  ]
}
</code></pre>

<p>Exit and log out and log in with the new user to test the permissions:</p>

<pre><code class="bash">$ mongo -u collectionreader -p --authenticationDatabase mytest
&gt; use mytest
switched to db mytest

&gt; show collections
col1
col2

&gt; db.col1.find()
{ "_id" : ObjectId("5be3d377b54849bb738e3b6b"), "name" : "ruan" }
</code></pre>

<p>Now lets try to write to a collection:</p>

<pre><code class="bash">&gt; db.col1.insert({"name": "james"})
WriteResult({
  "writeError" : {
    "code" : 13,
    "errmsg" : "not authorized on mytest to execute command { insert: \"col1\", documents: [ { _id: ObjectId('5be3d6c0492818b2c966d61a'), name: \"james\" } ], ordered: true }"
  }
})
</code></pre>

<p>So we can see it works as expected.</p>

<h2>Second Method: Create Roles and Assign Users to the Roles</h2>

<p>In the second method, we will create the roles then assign the users to the roles. And in this scenario, we will only grant a user <code>reader</code> access to one collection on a database. Login with the admin user:</p>

<pre><code class="bash">$ mongo -u dbadmin -p --authenticationDatabase admin
&gt; use admin
</code></pre>

<p>First create the read only role <code>myReadOnlyRole</code>:</p>

<pre><code class="bash">&gt; db.createRole({ role: "myReadOnlyRole", privileges: [{ resource: { db: "mytest", collection: "col2"}, actions: ["find"]}], roles: []})
</code></pre>

<p>Now create the user and assign it to the role:</p>

<pre><code class="bash">&gt; db.createUser({ user: "reader", pwd: "secretpass", roles: [{ role: "myReadOnlyRole", db: "mytest"}]})
</code></pre>

<p>Similarly, if we had an existing user that we also would like to add to that role, we can do that by doing this:</p>

<pre><code class="bash">&gt; db.grantRolesToUser("anotheruser", [ { role: "myReadOnlyRole", db: "mytest" } ])
</code></pre>

<p>Logout and login with the reader user:</p>

<pre><code class="bash">$ mongo -u reader -p --authenticationDatabase mytest
&gt; use mytest
</code></pre>

<p>Now try to list the collections:</p>

<pre><code class="bash">&gt; show collections
2018-11-08T07:42:39.907+0100 E QUERY    [thread1] Error: listCollections failed: {
  "ok" : 0,
  "errmsg" : "not authorized on mytest to execute command { listCollections: 1.0, filter: {} }",
  "code" : 13,
  "codeName" : "Unauthorized"
}
</code></pre>

<p>As we only have read (find) access on col2, lets try to read data from collection col1:</p>

<pre><code class="bash">&gt; db.col1.find()
Error: error: {
  "ok" : 0,
  "errmsg" : "not authorized on mytest to execute command { find: \"col1\", filter: {} }",
  "code" : 13,
  "codeName" : "Unauthorized"
}
</code></pre>

<p>And finally try to read data from the collection we are allowed to read from:</p>

<pre><code class="bash">&gt; db.col2.find()
{ "_id" : ObjectId("5be3d383b54849bb738e3b6c"), "name" : "stefan" }
</code></pre>

<p>And also making sure we cant write to that collection:</p>

<pre><code>&gt; db.col2.insert({"name": "frank"})
WriteResult({
  "writeError" : {
    "code" : 13,
    "errmsg" : "not authorized on mytest to execute command { insert: \"col2\", documents: [ { _id: ObjectId('5be3db1530a86d900c361465'), name: \"frank\" } ], ordered: true }"
  }
})
</code></pre>

<h2>Assigning Permissions to Roles</h2>

<p>If you later on want to add more permissions to the role, this can easily be done by using <code>grantPrivilegesToRole()</code>:</p>

<pre><code class="bash">$ mongo -u dbadmin -p --authenticationDatabase admin
&gt; use mytest
&gt; db.grantPrivilegesToRole("myReadOnlyRole", [{ resource: { db : "mytest", collection : "col1"}, actions : ["find"] }])
</code></pre>

<p>To view the permissions for that role:</p>

<pre><code class="bash">&gt; db.getRole("myReadOnlyRole", { showPrivileges : true })
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://docs.mongodb.com/manual/tutorial/create-users/">https://docs.mongodb.com/manual/tutorial/create-users/</a></li>
<li><a href="https://docs.mongodb.com/manual/core/collection-level-access-control/">https://docs.mongodb.com/manual/core/collection-level-access-control/</a></li>
<li><a href="https://docs.mongodb.com/manual/reference/privilege-actions/">https://docs.mongodb.com/manual/reference/privilege-actions/</a></li>
<li><a href="https://sanderknape.com/2018/07/manage-custom-secrets-aws-secrets-manager/">https://sanderknape.com/2018/07/manage-custom-secrets-aws-secrets-manager/</a></li>
<li><a href="https://blog.mlab.com/2016/07/mongodb-tips-tricks-collection-level-access-control/">https://blog.mlab.com/2016/07/mongodb-tips-tricks-collection-level-access-control/</a></li>
<li><a href="https://studio3t.com/knowledge-base/articles/mongodb-users-roles-explained-part-1/">https://studio3t.com/knowledge-base/articles/mongodb-users-roles-explained-part-1/</a></li>
</ul>


<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Experimenting With Python and TinyMongo a MongoDB Wrapper for TinyDB]]></title>
    <link href="https://blog.ruanbekker.com/blog/2018/04/15/experimenting-with-python-and-tinymongo-a-mongodb-wrapper-for-tinydb/"/>
    <updated>2018-04-15T16:39:22-04:00</updated>
    <id>https://blog.ruanbekker.com/blog/2018/04/15/experimenting-with-python-and-tinymongo-a-mongodb-wrapper-for-tinydb</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/schapman1974/tinymongo">TinyMongo</a> is a wrapper for MongoDB on top of TinyDB.</p>

<p>This is awesome for testing, where you need a local document orientated database which is backed by a flat file. It feels just like using MongoDB, except that its local, lightweight and using TinyDB in the backend.</p>

<h2>Installing Dependencies:</h2>

<pre><code class="bash">$ pip install tinymongo
</code></pre>

<h2>Usage Examples:</h2>

<p>Initialize tinymongo and create the database and collection:</p>

<pre><code class="python">&gt;&gt;&gt; from tinymongo import TinyMongoClient
&gt;&gt;&gt; connection = TinyMongoClient('foo')
&gt;&gt;&gt; db_init = connection.mydb
&gt;&gt;&gt; db = db_init.users
</code></pre>

<p>Insert a Document, catch the document id and search for that document:</p>

<pre><code class="python">&gt;&gt;&gt; record_id = db .insert_one({'username': 'ruanb', 'name': 'ruan', 'age': 31, 'gender': 'male', 'location': 'south africa'}).inserted_id
&gt;&gt;&gt; user_info = db.find_one({"_id": record_id})
&gt;&gt;&gt; print(user_info)
{u'username': u'ruanb', u'name': u'ruan', u'gender': u'male', u'age': 31, u'_id': u'8d2ce01140ec11e888110242ac110004', u'location': u'south africa'}
</code></pre>

<p>Update a document: Update the age attribute from 31 to 32</p>

<pre><code class="python">&gt;&gt;&gt; db.users.update_one({'_id': '8d2ce01140ec11e888110242ac110004'}, {'$set': {'age': 32 }})
&gt;&gt;&gt; print(user_info)
{u'username': u'ruanb', u'name': u'ruan', u'gender': u'male', u'age': 32, u'_id': u'8d2ce01140ec11e888110242ac110004', u'location': u'south africa'}
</code></pre>

<p>Insert some more data:</p>

<pre><code class="python">&gt;&gt;&gt; record_id = db .insert_one({'username': 'stefanb', 'name': 'stefan', 'age': 30, 'gender': 'male', 'location': 'south africa'}).inserted_id
&gt;&gt;&gt; record_id = db .insert_one({'username': 'alexa', 'name': 'alex', 'age': 34, 'gender': 'male', 'location': 'south africa'}).inserted_id
</code></pre>

<p>Find all the users, sorted by descending age, oldest to youngest:</p>

<pre><code class="python">&gt;&gt;&gt; response = db.users.find(sort=[('age', -1)])
&gt;&gt;&gt; for doc in response:
...     print(doc)
...
{u'username': u'alexa', u'name': u'alex', u'gender': u'male', u'age': 34, u'_id': u'66b1cc3d40ee11e892980242ac110004', u'location': u'south africa'}
{u'username': u'ruanb', u'name': u'ruan', u'gender': u'male', u'age': 32, u'_id': u'8d2ce01140ec11e888110242ac110004', u'location': u'south africa'}
{u'username': u'stefanb', u'name': u'stefan', u'gender': u'male', u'age': 30, u'_id': u'fbe9da8540ed11e88c5e0242ac110004', u'location': u'south africa'}
</code></pre>

<p>Find the number of documents in the collection:</p>

<pre><code class="python">&gt;&gt;&gt; db.users.find().count()
3
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://github.com/schapman1974/tinymongo">TinyMongo</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
