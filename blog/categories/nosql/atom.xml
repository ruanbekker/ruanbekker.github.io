<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Nosql | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/nosql/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2018-08-21T11:40:53-04:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tutorial on DynamoDB Using Bash and the AWS CLI Tools to Interact With a Music Dataset]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/08/14/tutorial-on-dynamodb-using-bash-and-the-aws-cli-tools-to-interact-with-a-music-dataset/"/>
    <updated>2018-08-14T16:33:22-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/08/14/tutorial-on-dynamodb-using-bash-and-the-aws-cli-tools-to-interact-with-a-music-dataset</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/aws-logo.png" alt="" /></p>

<p>In this tutorial we will be using Amazons DynamoDB (DynamoDB Local) to host a sample dataset consisting of music data that I retrieved from the iTunes API, which we will be using the aws cli tools to interact with the data.</p>

<p>We will be doing the following:</p>

<ul>
<li>Use Docker to provision a Local DynamoDB Server</li>
<li>Create a DynamoDB Table with a Hash and Range Key</li>
<li>List the Table</li>
<li>Create a Item in DynamoDB</li>
<li>Read a Item from DynamoDB</li>
<li>Read a Item from DynamoDB by specifying the details you would like to read</li>
<li>Batch Write multiple items to DynamoDB</li>
<li>Scan all your Items from DynamoDB</li>
<li>Query by Artist</li>
<li>Query by Artist and Song</li>
<li>Query all the Songs from an Artist starting with a specific letter</li>
<li>Indexes</li>
<li>Delete the Table</li>
</ul>


<p>If you are just getting started with DynamoDB, I recommend having a look at <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html">Amazons DynamoDB Documentation</a> Page first.</p>

<h2>The Music Dataset:</h2>

<p>I used the <a href="https://affiliate.itunes.apple.com/resources/documentation/itunes-store-web-service-search-api/">iTunes API</a> to get the music metadata, but I also have a post on <a href="http://blog.ruanbekker.com/blog/2018/05/08/use-python-requests-to-interact-with-the-itunes-api-to-search-for-music-info/">how to query the iTunes API</a> to get data from them to use.</p>

<p>a Quick way in Python to get the top 10 songs from Guns and Roses, will look like this:</p>

<pre><code class="python">&gt;&gt;&gt; a = 'https://itunes.apple.com/search?term=guns+and+roses&amp;limit=10'
&gt;&gt;&gt; b = requests.get(a).json()
&gt;&gt;&gt; print(json.dumps(b, indent=2))
</code></pre>

<h2>Create the DynamoDB Local Server on Docker:</h2>

<p>If you have a AWS Account you can provision your table from there, but if you want to test it locally, you can provision a local DynamoDB Server using Docker:</p>

<pre><code>$ docker run -it -p 8000:8000 --name dynamodb-local rbekker87/dynamodb-local
</code></pre>

<h2>Install the AWS CLI Tools:</h2>

<pre><code class="bash">$ pip install awscli
$ aws configure
# you can enter random data if you are using dynamodb-local
</code></pre>

<h2>Create the DynamoDB Table:</h2>

<p>Create a DynamoDB Table named <code>MusicCollection</code> with a <code>Artist (HASH)</code> and <code>SongTitle (RANGE)</code> key attributes:</p>

<pre><code class="bash">$ aws dynamodb create-table --table-name MusicCollection \
  --attribute-definitions AttributeName=Artist,AttributeType=S AttributeName=SongTitle,AttributeType=S \
  --key-schema AttributeName=Artist,KeyType=HASH AttributeName=SongTitle,KeyType=RANGE \
  --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
  --endpoint-url http://localhost:8000

Response:
{
    "TableDescription": {
        "TableArn": "arn:aws:dynamodb:ddblocal:000000000000:table/MusicCollection",
        "AttributeDefinitions": [
            {
                "AttributeName": "Artist",
                "AttributeType": "S"
            },
            {
                "AttributeName": "SongTitle",
                "AttributeType": "S"
            }
        ],
        "ProvisionedThroughput": {
            "NumberOfDecreasesToday": 0,
            "WriteCapacityUnits": 5,
            "LastIncreaseDateTime": 0.0,
            "ReadCapacityUnits": 5,
            "LastDecreaseDateTime": 0.0
        },
        "TableSizeBytes": 0,
        "TableName": "MusicCollection",
        "TableStatus": "ACTIVE",
        "KeySchema": [
            {
                "KeyType": "HASH",
                "AttributeName": "Artist"
            },
            {
                "KeyType": "RANGE",
                "AttributeName": "SongTitle"
            }
        ],
        "ItemCount": 0,
        "CreationDateTime": 1525339294.186
    }
}
</code></pre>

<h2>Listing the Tables:</h2>

<p>List the DynamoDB Table that you created:</p>

<pre><code class="bash">$ aws dynamodb list-tables --endpoint-url http://localhost:8000

{
    "TableNames": [
        "MusicCollection"
    ]
}
</code></pre>

<h2>Create a Item in DynamoDB:</h2>

<p>Add a song from the band <code>Bring me the Horizon</code> called <code>Sleepwalking</code> from the album <code>Sempiternal</code> to the table by using the <code>PutItem</code> call:</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 put-item --table-name MusicCollection \
  --item '{"Artist": {"S": "Bring me the Horizon"}, "SongTitle": {"S": "Sleepwalking"}, "AlbumTitle": {"S": "Sempiternal"}}'
</code></pre>

<h2>Read a Item from DynamoDB</h2>

<p>Get the Song Details from the Table by using the <code>GetItem</code> call:</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 get-item --table-name MusicCollection \
  --key  '{"Artist": {"S": "Bring me the Horizon"}, "SongTitle": {"S": "Sleepwalking"}}'

{
    "Item": {
        "Artist": {
            "S": "Bring me the Horizon"
        },
        "SongTitle": {
            "S": "Sleepwalking"
        },
        "AlbumTitle": {
            "S": "Sempiternal"
        }
    }
}
</code></pre>

<p>To only get specific attributes we can use <code>--aatributes-to-get</code>:</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 get-item --table-name MusicCollection \
  --attributes-to-get '["AlbumTitle", "SongTitle"]' \
  --key  '{"Artist": {"S": "Bring me the Horizon"}, "SongTitle": {"S": "Sleepwalking"}}'

{
    "Item": {
        "SongTitle": {
            "S": "Sleepwalking"
        },
        "AlbumTitle": {
            "S": "Sempiternal"
        }
    }
}
</code></pre>

<p>However, AWS Recommends to use the <code>--projection-expression</code> parameter:</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 get-item --table-name MusicCollection \
  --projection-expression "AlbumTitle, SongTitle" \
  --key  '{"Artist": {"S": "Bring me the Horizon"}, "SongTitle": {"S": "Sleepwalking"}}'

{
    "Item": {
        "SongTitle": {
            "S": "Sleepwalking"
        },
        "AlbumTitle": {
            "S": "Sempiternal"
        }
    }
}
</code></pre>

<ul>
<li><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html</a></li>
</ul>


<h2>Batch Write</h2>

<p>Now lets use the <a href="https://affiliate.itunes.apple.com/resources/documentation/itunes-store-web-service-search-api/">iTunes API</a> to get a collection of some songs, which I will dump into a <a href="https://github.com/ruanbekker/dynamodb-local-docker/blob/master/demo/batch-write-songs.json">json file on github</a>. So now that we have a json file with a collection of songs from multiple artists, we can go ahead and write it into our table using the <code>BatchWriteItem</code> call:</p>

<pre><code class="bash">$ wget https://raw.githubusercontent.com/ruanbekker/dynamodb-local-docker/master/demo/batch-write-songs.json
$ aws dynamodb batch-write-item --request-items file://music-table/batch-write-songs.json --endpoint-url http://localhost:8000
</code></pre>

<h2>Scan the Table:</h2>

<p>This can be a very expensive call, as a <code>Scan</code> will return all the items from your table, and depending on the size of your table, you could be throttled, but since we are using dynamodb local and only having 16 items in our table, we can do a scan to return all the items in our table:</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 scan --table-name MusicCollection
{
    "Count": 16,
</code></pre>

<h2>Query</h2>

<p>Let&rsquo;s start using the <code>Query</code> call to get all the songs from the Artist: AC/DC</p>

<ul>
<li><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.QueryFilter.html">https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.QueryFilter.html</a></li>
</ul>


<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 query --select ALL_ATTRIBUTES \
  --table-name MusicCollection \
  --key-condition-expression "Artist = :a" \
  --expression-attribute-values  '{":a":{"S":"AC/DC"}}'

{
    "Count": 3,
    "Items": [
        {
            "Artist": {
                "S": "AC/DC"
            },
            "SongTitle": {
                "S": "Back In Black"
            },
            "AlbumTitle": {
                "S": "Back In Black"
            }
        },
        {
            "Artist": {
                "S": "AC/DC"
            },
            "SongTitle": {
                "S": "Thunderstruck"
            },
            "AlbumTitle": {
                "S": "The Razors Edge"
            }
        },
        {
            "Artist": {
                "S": "AC/DC"
            },
            "SongTitle": {
                "S": "You Shook Me All Night Long"
            },
            "AlbumTitle": {
                "S": "Back in Black"
            }
        }
    ],
    "ScannedCount": 3,
    "ConsumedCapacity": null
}
</code></pre>

<p>Query to get the details of a specific Song from a specific Artist:</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 query --select ALL_ATTRIBUTES \
  --table-name MusicCollection \
  --key-condition-expression "Artist = :a and SongTitle = :t" \
  --expression-attribute-values  '{ ":a": {"S": "AC/DC"}, ":t": {"S": "You Shook Me All Night Long"}}'

{
    "Count": 1,
    "Items": [
        {
            "Artist": {
                "S": "AC/DC"
            },
            "SongTitle": {
                "S": "You Shook Me All Night Long"
            },
            "AlbumTitle": {
                "S": "Back in Black"
            }
        }
    ],
    "ScannedCount": 1,
    "ConsumedCapacity": null
}
</code></pre>

<p>Query to get all the songs from the Beatles that starts with the letter &lsquo;H&rsquo;:</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 query --select ALL_ATTRIBUTES \
  --table-name MusicCollection \
  --key-condition-expression "Artist = :a and begins_with(SongTitle, :t)" \
  --expression-attribute-values  '{":a":{"S":"The Beatles"}, ":t": {"S": "h"}}'

{
    "Count": 2,
    "Items": [
        {
            "Artist": {
                "S": "The Beatles"
            },
            "SongTitle": {
                "S": "Happy Day"
            },
            "AlbumTitle": {
                "S": "The Beatles 1967-1970 (The Blue Album)"
            }
        },
        {
            "Artist": {
                "S": "The Beatles"
            },
            "SongTitle": {
                "S": "Help!"
            },
            "AlbumTitle": {
                "S": "The Beatles Box Set"
            }
        }
    ],
    "ScannedCount": 2,
    "ConsumedCapacity": null
}
</code></pre>

<p>So our table consists of Artist (HASH) and SongTitle (RANGE), so we can only query based on those attributes. You will find when you try to query on a attribute that is not part of the KeySchema, a exception will be received:</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 query --select ALL_ATTRIBUTES --table-name MusicCollection --key-condition-expression "Artist = :a and AlbumTitle = :t" --expression-attribute-values  '{":a":{"S":"AC/DC"}, ":t": {"S": "Back in Black"}}'

An error occurred (ValidationException) when calling the Query operation: Query condition missed key schema element
</code></pre>

<p>So how do we query on a attribute that is not part of the KeySchema? Let&rsquo;s say you want to query all the songs from a Artist and a specific Album.</p>

<h2>Global Secondary Indexes:</h2>

<p>Add Global Secondary Index, with the Attributes: Artist and AlbumTitle.</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 update-table --table-name MusicCollection \
  --attribute-definitions AttributeName=Artist,AttributeType=S AttributeName=SongTitle,AttributeType=S AttributeName=AlbumTitle,AttributeType=S \
  --global-secondary-index-updates "Create={"IndexName"="album-index", "KeySchema"=[ {"AttributeName"="Artist", "KeyType"="HASH"}, {"AttributeName"="AlbumTitle", "KeyType"="RANGE" }], "Projection"={"ProjectionType"="INCLUDE", "NonKeyAttributes"="AlbumTitle"}, "ProvisionedThroughput"= {"ReadCapacityUnits"=1, "WriteCapacityUnits"=1} }"

{
    "TableDescription": {
        "TableArn": "arn:aws:dynamodb:ddblocal:000000000000:table/MusicCollection",
        "AttributeDefinitions": [
            {
                "AttributeName": "Artist",
                "AttributeType": "S"
            },
            {
                "AttributeName": "SongTitle",
                "AttributeType": "S"
            },
            {
                "AttributeName": "AlbumTitle",
                "AttributeType": "S"
            }
        ],
        "GlobalSecondaryIndexes": [
            {
                "IndexName": "album-index",
                "Projection": {
                    "ProjectionType": "INCLUDE",
                    "NonKeyAttributes": [
                        "AlbumTitle"
                    ]
                },
                "ProvisionedThroughput": {
                    "WriteCapacityUnits": 1,
                    "ReadCapacityUnits": 1
                },
                "IndexStatus": "CREATING",
                "Backfilling": false,
                "KeySchema": [
                    {
                        "KeyType": "HASH",
                        "AttributeName": "Artist"
                    },
                    {
                        "KeyType": "RANGE",
                        "AttributeName": "AlbumTitle"
                    }
                ],
                "IndexArn": "arn:aws:dynamodb:ddblocal:000000000000:table/MusicCollection/index/album-index"
            }
        ],
        "ProvisionedThroughput": {
            "NumberOfDecreasesToday": 0,
            "WriteCapacityUnits": 5,
            "LastIncreaseDateTime": 0.0,
            "ReadCapacityUnits": 5,
            "LastDecreaseDateTime": 0.0
        },
        "TableSizeBytes": 984,
        "TableName": "MusicCollection",
        "TableStatus": "ACTIVE",
        "KeySchema": [
            {
                "KeyType": "HASH",
                "AttributeName": "Artist"
            },
            {
                "KeyType": "RANGE",
                "AttributeName": "SongTitle"
            }
        ],
        "ItemCount": 15,
        "CreationDateTime": 1525339294.186
    }
}
</code></pre>

<p>Now when we use the same query, but we specify our index, we will get the data:</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 query \
  --select ALL_ATTRIBUTES \
  --table-name MusicCollection \
  --index-name album-index \
  --key-condition-expression "Artist = :a and AlbumTitle = :t" \
  --expression-attribute-values  '{":a":{"S":"AC/DC"}, ":t": {"S": "Back in Black"}}'

{
    "Count": 1,
    "Items": [
        {
            "Artist": {
                "S": "AC/DC"
            },
            "SongTitle": {
                "S": "You Shook Me All Night Long"
            },
            "AlbumTitle": {
                "S": "Back in Black"
            }
        }
    ],
    "ScannedCount": 1,
    "ConsumedCapacity": null
}
</code></pre>

<h2>Delete the Table:</h2>

<p>Delete the Table that we created:</p>

<pre><code class="bash">$ aws dynamodb --endpoint-url http://localhost:8000 delete-table --table-name MusicCollection
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SQLtoNoSQL.ReadData.Query.html">https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SQLtoNoSQL.ReadData.Query.html</a></li>
<li><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SQLtoNoSQL.Indexes.html">https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SQLtoNoSQL.Indexes.html</a></li>
<li><a href="https://affiliate.itunes.apple.com/resources/documentation/itunes-store-web-service-search-api/">https://affiliate.itunes.apple.com/resources/documentation/itunes-store-web-service-search-api/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Experimenting With Python and TinyMongo a MongoDB Wrapper for TinyDB]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/04/15/experimenting-with-python-and-tinymongo-a-mongodb-wrapper-for-tinydb/"/>
    <updated>2018-04-15T16:39:22-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/04/15/experimenting-with-python-and-tinymongo-a-mongodb-wrapper-for-tinydb</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/schapman1974/tinymongo">TinyMongo</a> is a wrapper for MongoDB on top of TinyDB.</p>

<p>This is awesome for testing, where you need a local document orientated database which is backed by a flat file. It feels just like using MongoDB, except that its local, lightweight and using TinyDB in the backend.</p>

<h2>Installing Dependencies:</h2>

<pre><code class="bash">$ pip install tinymongo
</code></pre>

<h2>Usage Examples:</h2>

<p>Initialize tinymongo and create the database and collection:</p>

<pre><code class="python">&gt;&gt;&gt; from tinymongo import TinyMongoClient
&gt;&gt;&gt; connection = TinyMongoClient('foo')
&gt;&gt;&gt; db_init = connection.mydb
&gt;&gt;&gt; db = db_init.users
</code></pre>

<p>Insert a Document, catch the document id and search for that document:</p>

<pre><code class="python">&gt;&gt;&gt; record_id = db .insert_one({'username': 'ruanb', 'name': 'ruan', 'age': 31, 'gender': 'male', 'location': 'south africa'}).inserted_id
&gt;&gt;&gt; user_info = db.find_one({"_id": record_id})
&gt;&gt;&gt; print(user_info)
{u'username': u'ruanb', u'name': u'ruan', u'gender': u'male', u'age': 31, u'_id': u'8d2ce01140ec11e888110242ac110004', u'location': u'south africa'}
</code></pre>

<p>Update a document: Update the age attribute from 31 to 32</p>

<pre><code class="python">&gt;&gt;&gt; db.users.update_one({'_id': '8d2ce01140ec11e888110242ac110004'}, {'$set': {'age': 32 }})
&gt;&gt;&gt; print(user_info)
{u'username': u'ruanb', u'name': u'ruan', u'gender': u'male', u'age': 32, u'_id': u'8d2ce01140ec11e888110242ac110004', u'location': u'south africa'}
</code></pre>

<p>Insert some more data:</p>

<pre><code class="python">&gt;&gt;&gt; record_id = db .insert_one({'username': 'stefanb', 'name': 'stefan', 'age': 30, 'gender': 'male', 'location': 'south africa'}).inserted_id
&gt;&gt;&gt; record_id = db .insert_one({'username': 'alexa', 'name': 'alex', 'age': 34, 'gender': 'male', 'location': 'south africa'}).inserted_id
</code></pre>

<p>Find all the users, sorted by descending age, oldest to youngest:</p>

<pre><code class="python">&gt;&gt;&gt; response = db.users.find(sort=[('age', -1)])
&gt;&gt;&gt; for doc in response:
...     print(doc)
...
{u'username': u'alexa', u'name': u'alex', u'gender': u'male', u'age': 34, u'_id': u'66b1cc3d40ee11e892980242ac110004', u'location': u'south africa'}
{u'username': u'ruanb', u'name': u'ruan', u'gender': u'male', u'age': 32, u'_id': u'8d2ce01140ec11e888110242ac110004', u'location': u'south africa'}
{u'username': u'stefanb', u'name': u'stefan', u'gender': u'male', u'age': 30, u'_id': u'fbe9da8540ed11e88c5e0242ac110004', u'location': u'south africa'}
</code></pre>

<p>Find the number of documents in the collection:</p>

<pre><code class="python">&gt;&gt;&gt; db.users.find().count()
3
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://github.com/schapman1974/tinymongo">TinyMongo</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Experimenting With Python and Flata the Lightweight Document Orientated Database]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/04/15/experimenting-with-python-and-flata-the-lightweight-document-orientated-database/"/>
    <updated>2018-04-15T15:09:25-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/04/15/experimenting-with-python-and-flata-the-lightweight-document-orientated-database</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/l298Y7.jpg" alt="" /></p>

<p><a href="https://github.com/harryho/flata">Flata</a> is a lightweight document orientated database, which was inspired by <a href="https://github.com/msiemens/tinydb">TinyDB</a> and <a href="https://github.com/typicode/lowdb">LowDB</a>.</p>

<h2>Why Flata?</h2>

<p>Most of the times my mind gets in its curious states and I think about alternative ways on doing things, especially testing lightweight apps and today I wondered if theres any NoSQL-like software out there that is easy to spin up and is backed by a flat file, something like <code>sqlite</code> for SQL-like services, so this time just something for NoSQL-like.</p>

<p>So I stumbled upon TinyDB and Flata which is really easy to use and awesome!</p>

<h2>What will we be doing today:</h2>

<ul>
<li>Create Database / Table</li>
<li>Write to the Table</li>
<li>Update Documents from the Table</li>
<li>Scan the Table</li>
<li>Query the Table</li>
<li>Delete Documents from the Table</li>
<li>Purge the Table</li>
</ul>


<h2>Getting the Dependencies:</h2>

<p>Flata is written in Python, so no external dependencies is needed. To install it:</p>

<pre><code class="bash">$ pip install flata
</code></pre>

<h2>Usage Examples:</h2>

<p>My home working directory:</p>

<pre><code class="bash">$ pwd
/home/ruan
</code></pre>

<p>This will be the directory where we will save our database in <code>.json</code> format.</p>

<p>Import the Dependencies:</p>

<pre><code class="python">&gt;&gt;&gt; from flata import Flata, Query, where
&gt;&gt;&gt; from flata.storages import JSONStorage
</code></pre>

<p>Create the Database file where all the data will be persisted:</p>

<pre><code class="python">&gt;&gt;&gt; db_init = Flata('mydb.json', storage=JSONStorage)
</code></pre>

<p>Create the collection / table, with a custom id field. If the resource already exists a retrieve will be done:</p>

<pre><code class="python">&gt;&gt;&gt; db_init.table('collection1', id_field = 'uid')
</code></pre>

<p>List the tables:</p>

<pre><code class="python">&gt;&gt;&gt; db_init.all()
{u'collection1': {}}
</code></pre>

<p>a get method can only be done if the resource exists, and we will assign it to the <code>db</code> object:</p>

<pre><code class="python">&gt;&gt;&gt; db = db_init.get('collection1')
</code></pre>

<p>Insert some data into our table:</p>

<pre><code class="python">&gt;&gt;&gt; db.insert({'username': 'ruanb', 'name': 'ruan', 'age': 31, 'gender': 'male', 'location': 'south africa'})
{'username': 'ruanb', 'uid': 1, 'gender': 'male', 'age': 31, 'location': 'south africa', 'name': 'ruan'}

&gt;&gt;&gt; db.insert({'username': 'stefanb', 'name': 'stefan', 'age': 30, 'gender': 'male', 'location': 'south africa'})
{'username': 'stefanb', 'uid': 2, 'gender': 'male', 'age': 30, 'location': 'south africa', 'name': 'stefan'}

&gt;&gt;&gt; db.insert({'username': 'mikec', 'name': 'mike', 'age': 28, 'gender': 'male', 'location': 'south africa'})
{'username': 'mikec', 'uid': 3, 'gender': 'male', 'age': 28, 'location': 'south africa', 'name': 'mike'}

&gt;&gt;&gt; db.insert({'username': 'sam', 'name': 'samantha', 'age': 24, 'gender': 'female', 'location': 'south africa'})
{'username': 'sam', 'uid': 4, 'gender': 'female', 'age': 24, 'location': 'south africa', 'name': 'samantha'}

&gt;&gt;&gt; db.insert({'username': 'michellek', 'name': 'michelle', 'age': 32, 'gender': 'female', 'location': 'south africa'})
{'username': 'michellek', 'uid': 5, 'gender': 'female', 'age': 32, 'location': 'south africa', 'name': 'michelle'}
</code></pre>

<p>Scan the whole table:</p>

<pre><code class="python">&gt;&gt;&gt; db.all()
[{u'username': u'ruanb', u'uid': 1, u'name': u'ruan', u'gender': u'male', u'age': 31, u'location': u'south africa'}, {u'username': u'stefanb', u'uid': 2, u'name': u'stefan', u'gender': u'male', u'age': 30, u'location': u'south africa'}, {u'username': u'mikec', u'uid': 3, u'name': u'mike', u'gender': u'male', u'age': 28, u'location': u'south africa'}, {u'username': u'sam', u'uid': 4, u'name': u'samantha', u'gender': u'female', u'age': 24, u'location': u'south africa'}, {u'username': u'michellek', u'uid': 5, u'name': u'michelle', u'gender': u'female', u'age': 32, u'location': u'south africa'}]
</code></pre>

<p>Query data from the table.</p>

<p>Query the table for the <code>username =&gt; ruanb</code>:</p>

<pre><code class="python">&gt;&gt;&gt; import json
&gt;&gt;&gt; q = Query()

&gt;&gt;&gt; response = db.search(q.username == 'ruanb')
&gt;&gt;&gt; print(json.dumps(response, indent=2))
[
  {
    u'username': u'ruanb', 
    u'uid': 1, 
    u'name': u'ruan', 
    u'gender': u'male', 
    u'age': 31, 
    u'location': u'south africa'
  }
]
</code></pre>

<p>Query the table for everyone that is older than <code>29</code> and only <code>male</code> genders:</p>

<pre><code class="python">&gt;&gt;&gt; db.search(( q.gender == 'male' ) &amp; (q.age &gt;= 29 ))
[
  {
    u'username': u'ruanb', 
    u'uid': 1, 
    u'name': u'ruan', 
    u'gender': u'male', 
    u'age': 31, 
    u'location': u'south africa'
  }, 
  {
    u'username': u'stefanb', 
    u'uid': 2, 
    u'name': u'stefan', 
    u'gender': u'male', 
    u'age': 30, 
    u'location': u'south africa'
  }
]
</code></pre>

<p>Query the table for everyone that is younger than 25 or males:</p>

<pre><code class="python">&gt;&gt;&gt; db.search(( q.age &lt; 25 ) | (q.gender == 'male' ) )
[
  {
    "username": "ruanb",
    "uid": 1,
    "name": "ruan",
    "gender": "male",
    "age": 31,
    "location": "south africa"
  },
  {
    "username": "stefanb",
    "uid": 2,
    "name": "stefan",
    "gender": "male",
    "age": 30,
    "location": "south africa"
  },
  {
    "username": "mikec",
    "uid": 3,
    "name": "mike",
    "gender": "male",
    "age": 28,
    "location": "south africa"
  },
  {
    "username": "sam",
    "uid": 4,
    "name": "samantha",
    "gender": "female",
    "age": 24,
    "location": "south africa"
  }
]
</code></pre>

<p>Update the location value: Lets say Samantha relocated to New Zealand, and we need to update her location from <code>South Africa</code> to <code>New Zealand</code>:</p>

<pre><code class="python">&gt;&gt;&gt; db.update({'location': 'new zealand'}, where('username') == 'sam' )
([4], [{u'username': u'sam', u'uid': 4, u'name': u'samantha', u'gender': u'female', u'age': 24, u'location': 'new zealand'}])

&gt;&gt;&gt; db.search(q.username == 'sam')
[{u'username': u'sam', u'uid': 4, u'name': u'samantha', u'gender': u'female', u'age': 24, u'location': u'new zealand'}]
</code></pre>

<p>Delete a document by its id:</p>

<pre><code class="python">&gt;&gt;&gt; db.remove(ids=[4])
([4], [])
</code></pre>

<p>Delete all documents matching a query, for this example, all people with the gender: <code>male</code>:</p>

<pre><code class="python">&gt;&gt;&gt; db.remove(q.gender == 'male')
([1, 2, 3], [])
</code></pre>

<p>Delete all the data in the table:</p>

<pre><code class="python">&gt;&gt;&gt; db.purge()
</code></pre>

<p>When we exit, you will find the database file, which we created:</p>

<pre><code class="bash">$ ls
mydb.json
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://github.com/harryho/flata">Flata</a></li>
<li><a href="https://github.com/msiemens/tinydb">TinyDB</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup MongoDB Server on ARM64 Using Scaleway]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/04/01/setup-mongodb-server-on-arm64-using-scaleway/"/>
    <updated>2018-04-01T18:46:27-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/04/01/setup-mongodb-server-on-arm64-using-scaleway</id>
    <content type="html"><![CDATA[<p><img src="https://preview.ibb.co/bBRhn7/scw.png" alt="" /></p>

<p>I&rsquo;ve been using Scaleway for the past 18 months and I must admit, I love hosting my Applications on their Infrastructure. They have expanded rapidly recently, and currently deploying more infrstructure due to the high demand.</p>

<p>Scaleway is a Cloud Division of Online.net. They provide Baremetal and Cloud SSD Virtual Servers. Im currently hosting a Docker Swarm Cluster, Blogs, Payara Java Application Servers, Elasticsearch and MongoDB Clusters with them and really happy with the performance and stability of their services.</p>

<h2>What will we be doing today:</h2>

<p>Today I will be deploying MongoDB Server on a ARM64-2GB Instance, which costs you 2.99 Euros per month, absolutely awesome pricing! After we install MongoDB we will setup authentication, and then just a few basic examples on writing and reading from MongoDB.</p>

<h2>Getting Started:</h2>

<p>Logon to <a href="cloud.scaleway.com">cloud.scaleway.com</a> then launch an instance, which will look like the following:</p>

<p><img src="https://image.ibb.co/e7T9jn/scw_launch.png" alt="" /></p>

<p>After you deployed your instance, SSH to your instance, and it should look like this:</p>

<p><img src="https://preview.ibb.co/k16C4n/scw_ssh.png" alt="" /></p>

<h2>Dependencies:</h2>

<p>Get the repository and install MongoDB:</p>

<pre><code class="bash">$ apt update
$ apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5
$ echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.6 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list
$ apt update &amp;&amp; apt upgrade -y
$ apt install mongodb-org -y
</code></pre>

<p>Enable MongoDB on Boot:</p>

<pre><code class="bash">$ systemctl enable mongod
</code></pre>

<h2>Configuration:</h2>

<p>Your configuration might look different from mine, so I recommend to backup your config first, as the following command will overwrite the config to the configuration that I will be using for this demonstration:</p>

<pre><code class="bash">$ cat &gt; /etc/mongod.conf &lt;&lt; EOF
storage:
  dbPath: /var/lib/mongodb
  journal:
    enabled: false

storage:
  mmapv1:
    smallFiles: true

systemLog:
  destination: file
  logAppend: true
  path: /var/log/mongodb/mongod.log

net:
  port: 27017
  bindIp: 0.0.0.0

processManagement:
  timeZoneInfo: /usr/share/zoneinfo

security:
  authorization: enabled
EOF
</code></pre>

<p>Restart MongoDB for the config changes to take affect:</p>

<pre><code class="bash">$ systemctl restart mongod
</code></pre>

<h2>Authentication:</h2>

<p>Create the Authentication:</p>

<pre><code class="bash">$ mongo
MongoDB shell version v3.6.3
connecting to: mongodb://127.0.0.1:27017
MongoDB server version: 3.6.3
Welcome to the MongoDB shell.

&gt; use admin
&gt; db.createUser({user: "ruan", pwd: "pass123", roles:[{role: "root", db: "admin"}]})
Successfully added user: {
        "user" : "ruan",
        "roles" : [
                {
                        "role" : "root",
                        "db" : "admin"
                }
        ]
}

&gt; exit
</code></pre>

<p>Restart MongoDB and logon with your credentials:</p>

<pre><code class="bash">$ systemctl restart mongod

$ mongo --authenticationDatabase admin --host localhost --port 27017 -u ruan -p
MongoDB shell version v3.6.3
Enter password:
connecting to: mongodb://localhost:27017/
MongoDB server version: 3.6.3
&gt;
</code></pre>

<h2>Write and Read from MongoDB</h2>

<p>While you are on the MongoDB Shell, we will insert a couple of documents, first drop in to the database that you would like to write to:</p>

<pre><code class="bash">&gt; use testdb
switched to db testdb
</code></pre>

<p>Now we will write to the collection: <code>collection1</code>:</p>

<pre><code class="bash">&gt; db.collection1.insert({"name": "ruan", "surname": "bekker", "age": 31, "country": "south africa"})
WriteResult({ "nInserted" : 1 })

&gt; db.collection1.insert({"name": "stefan", "surname": "bester", "age": 30, "country": "south africa"})
WriteResult({ "nInserted" : 1 })
</code></pre>

<p>To find all the documents in our collection:</p>

<pre><code class="bash">&gt; db.collection1.find()
{ "_id" : ObjectId("5ac15ff0f4a5500484defd23"), "name" : "ruan", "surname" : "bekker", "age" : 31, "country" : "south africa" }
{ "_id" : ObjectId("5ac16003f4a5500484defd24"), "name" : "stefan", "surname" : "bester", "age" : 30, "country" : "south africa" }
</code></pre>

<p>To prettify the output:</p>

<pre><code class="bash">&gt; db.collection1.find().pretty()
{
        "_id" : ObjectId("5ac15ff0f4a5500484defd23"),
        "name" : "ruan",
        "surname" : "bekker",
        "age" : 31,
        "country" : "south africa"
}
{
        "_id" : ObjectId("5ac16003f4a5500484defd24"),
        "name" : "stefan",
        "surname" : "bester",
        "age" : 30,
        "country" : "south africa"
}
</code></pre>

<p>To find a document with the key/value of <code>name: ruan</code>:</p>

<pre><code class="bash">&gt; db.collection1.find({"name": "ruan"}).pretty()
{
        "_id" : ObjectId("5ac15ff0f4a5500484defd23"),
        "name" : "ruan",
        "surname" : "bekker",
        "age" : 31,
        "country" : "south africa"
}
</code></pre>

<p>To view the database that you are currently switched to:</p>

<pre><code class="bash">&gt; db
testdb
</code></pre>

<p>To view all the databases:</p>

<pre><code class="bash">&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
testdb  0.000GB
</code></pre>

<p>To view the collections in the database:</p>

<pre><code class="bash">&gt; show collections
collection1

&gt; exit
</code></pre>

<p>That was just a quick post on installing MongoDB on ARM64 using Scaleway. Try them out, and they are also hiring: <a href="https://careers.scaleway.com/">careers.scaleway.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Delete Old Items With Amazons DynamoDB TTL Feature]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/11/22/delete-old-items-with-amazons-dynamodb-ttl-feature/"/>
    <updated>2017-11-22T17:47:31-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/11/22/delete-old-items-with-amazons-dynamodb-ttl-feature</id>
    <content type="html"><![CDATA[<p><img src="http://obj-cache.cloud.ruanbekker.com/dynamodb.png" alt="" /></p>

<p>As you may know a DynamoDB Table&rsquo;s Partition Splits on 2 factors, Read/Write Capacity Units and when Storage goes over 10GB.</p>

<h2>Automatically Deleting Old Data in DynamoDB:</h2>

<p>With the TTL Feature in DynamoDB, we can enable TTL on a Attribute on our Table, the attributes value needs to have an epoc time value, more specifically, when the current time is the same as the value of on of the items attribute value, that item will be expired, which will be deleted.</p>

<h2>What we will be doing:</h2>

<ul>
<li>Use Boto3 in Python</li>
<li>Create DynamoDB Table: &lsquo;session-table&rsquo;</li>
<li>Set TTL Attribute on &lsquo;ExpirationTime&rsquo;, so whenever the epoch time is equals to the AttributeValue it will delete the item</li>
<li>Do one PUT Item with 48 Hours expiry Date from the Write</li>
<li>Do 240 PUT Items with 24 Hours expiry Date from the Write</li>
<li>Verify after 24 hours if only one item is in our table.</li>
</ul>


<h2>Pre-Requisites:</h2>

<p>Install the AWS CLI, Boto3 and configure your credentials, so that boto3 can read from your credential provider:</p>

<pre><code class="bash">$ pip install awscli
$ pip install boto3
$ aws configure
AWS Access Key ID [****************XYZ]: 
AWS Secret Access Key [****************xyz]: 
Default region name [eu-west-1]: 
Default output format [json]: 
</code></pre>

<h2>Create the Table:</h2>

<pre><code class="python">$ python

import boto3
session = boto3.Session(region_name='eu-west-1', profile_name='default')
dynamodb = session.resource('dynamodb')
table = dynamodb.create_table(
    TableName='session-table',
    KeySchema=[
        {
            'AttributeName': 'sessionid', 
            'KeyType': 'HASH'
        }
    ], 
    AttributeDefinitions=[
        {
            'AttributeName': 'sessionid', 
            'AttributeType': 'S'
        } 
    ], 
    ProvisionedThroughput={
        'ReadCapacityUnits': 2, 
        'WriteCapacityUnits': 2
    }
)
</code></pre>

<p>From the Console, enable TTL and set the TTL Attribute on <code>ExpirationTime</code></p>

<h2>Write Data to DynamoDB</h2>

<p>We have 2 functions that will write the current epoch time to the <code>CreationTime</code> attribute and <code>ExpirationTime</code> will have the current time plus the 24 hours in seconds, which will be used for the 240 items that will be written using the for loop and the other function with the 48 hours of seconds, which will be a single write item.</p>

<p>Then we will just write random data to the session data attribute:</p>

<pre><code class="python">import boto3
import time
import random
from uuid import uuid4

names = ['james', 'john', 'steve', 'peter', 'frank', 'steven', 'jonathan', 'stephen', 'will', 'adam', 'william']
retailer = ['shoprite', 'edgars', 'pnp', 'bestbuy', 'ok', 'grocer-a', 'amazon', 'seveneleven', 'shop-a']

session = boto3.Session(region_name='eu-west-1', profile_name='dev')
ddb = session.resource('dynamodb')
client = ddb.Table('session-table')

def current_time():
    int(time.time())

def current_time():
    return int(time.time())

def expiration_time():
    return int(time.time()) + 86400

def 48h_expiration_time():
    return int(time.time()) + 172800

# expiry on 48 hours
client.put_item(
    Item={
        'sessionid': str(uuid4()),
        'CreationTime': current_time(),
        'ExpirationTime': 48h_expiration_time(),
        'SessionData': {
            'Name': random.choice(names),
            'Retailer': random.choice(retailer),
            'TimeOfTransaction': current_time(),
            'Amount': random.randint(100,9000)
        }
    }
)

# expiry on 24 hours
for x in xrange(240):
    time.sleep(1)
    client.put_item(
        Item={
            'sessionid': str(uuid4()),
            'CreationTime': current_time(),
            'ExpirationTime': expiration_time(),
            'SessionData': {
                'Name': random.choice(names),
                'Retailer': random.choice(retailer),
                'TimeOfTransaction': current_time(),
                'Amount': random.randint(100,9000)
            }
        }
    )
</code></pre>

<h2>Verify:</h2>

<p>Verify after 24 hours if the item with the 48 hour expiration time is still in our table:</p>

<pre><code class="python">client.get_item( Key={'sessionid': '69c2a472-f70e-4d72-b25f-e27573696b0c'} )['Item']

{
    u'ExpirationTime': Decimal('1510672221'),
    u'CreationTime': Decimal('1510585821'),
    u'sessionid': u'69c2a472-f70e-4d72-b25f-e27573696b0c',
    u'SessionData': {
        u'Amount': Decimal('3553'),
        u'Retailer': u'amazon',
        u'TimeOfTransaction': Decimal('1510585821'),
        u'Name': u'steve'
    }
}
</code></pre>

<p>Which we can see is still there, when doing a GET item on one of our 24 hour expired items, we can see that its no longer there:</p>

<pre><code class="python">client.get_item( Key={'sessionid': '70b9fc8c-19c4-49d3-bf63-046e992335af'} )['Item']

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'Item'
</code></pre>

<p>Doing a SCAN operation, we should see one item:</p>

<pre><code class="python">import json
r = client.scan(TableName='session-table', Limit=10, Select='COUNT', ReturnConsumedCapacity='TOTAL')

print(json.dumps(r, indent=4))
{
    "Count": 1,
    "ScannedCount": 1,
    "ConsumedCapacity": {
        "CapacityUnits": 0.5,
        "TableName": "session-table"
    },
    "ResponseMetadata": {
        "RetryAttempts": 0,
        "HTTPStatusCode": 200,
        "RequestId": "",
        "HTTPHeaders": {
            "x-amzn-requestid": "",
            "content-length": "107",
            "server": "Server",
            "connection": "keep-alive",
            "x-amz-crc32": "2228370918",
            "date": "Tue, 14 Nov 2017 12:02:31 GMT",
            "content-type": "application/x-amz-json-1.0"
        }
    }
}
</code></pre>

<p>So we can confirm that the TTL feature expires the data based on the epoch value we provide our item.</p>

<h2>Delete the Table:</h2>

<pre><code class="python">client.delete(TableName='session-table')
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://sysadmins.co.za/interfacing-amazon-dynamodb-with-python-using-boto3/">https://sysadmins.co.za/interfacing-amazon-dynamodb-with-python-using-boto3/</a></li>
<li><a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html">http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
