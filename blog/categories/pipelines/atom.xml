<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Pipelines | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/pipelines/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2019-04-18T06:20:44-04:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Self Hosted Git and CICD Platform With Gitea and Drone on Docker]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/04/04/self-hosted-git-and-cicd-platform-with-gitea-and-drone-on-docker/"/>
    <updated>2019-04-04T17:57:16-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/04/04/self-hosted-git-and-cicd-platform-with-gitea-and-drone-on-docker</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/55591102-f57c7100-5734-11e9-96cf-8a60d091a769.png" alt="" /></p>

<p>Both gitea and drone is built on golang runs on multiple platforms including a raspberry pi and its super lightweight. Oh yes, and its awesome!</p>

<p>In this tutorial we will see how we can implement our own git service and cicd platform by setting up gitea and drone on docker and commit a python flask application to gitea and build a pipeline on drone.</p>

<h2>Some definition</h2>

<p><strong>Gitea</strong>: will be your self hosted git server</p>

<p><strong>Drone Server</strong>: will be server being responsible for the web service, repositories, secrets, users, etc.</p>

<p><strong>Drone Agent</strong>: will be the workers that runs your builds, jobs etc.</p>

<h2>Server Confguration</h2>

<p>We will change our host&rsquo;s ssh port to something else as our git server&rsquo;s ssh method will be listening on port 22 and we would like to add our ssh key to gitea so that we can commit to our git server via ssh.</p>

<p>Change your server&rsquo;s ssh port to 2222, by opening <code>/etc/ssh/sshd_config</code> and edit the port to <code>2222</code> then restart sshd with:</p>

<pre><code>$ /etc/init.d/sshd restart
</code></pre>

<p>Your ssh connection will still be established, but you can exit and ssh to your server by specifying the new port:</p>

<pre><code>$ ssh -p 2222 user@host
</code></pre>

<h2>Pre-Requirements</h2>

<p>Make sure you have <a href="https://docs.docker.com/install/">docker and docker-compose</a> installed</p>

<h2>Deploy Gitea and Drone</h2>

<p>Below is the docker-compose file for our deployment. Note that we are running a postgres database which gitea will be configured on, you can also use other databases like mysql, sqlite etc. Visit their <a href="https://docs.gitea.io/en-us/">documentation</a> for more info.</p>

<pre><code class="yaml">version: "2"

services:
  gitea-app:
    image: gitea/gitea:latest
    container_name: gitea-app
    environment:
      - USER_UID=1000
      - USER_GID=1000
      - ROOT_URL=http://gitea:3000
      - SSH_DOMAIN=mydomain.com
    restart: always
    volumes:
      - ./volumes/gitea_app:/data
    ports:
      - "3000:3000"
      - "22:22"
    networks:
      - appnet

  gitea-db:
    image: postgres:alpine
    container_name: gitea-db
    ports:
      - 5440:5432
    restart: always
    volumes:
      - ./volumes/gitea_db:/var/lib/postgresql/data
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=gitea
    networks:
      - appnet

  drone-server:
    image: drone/drone:0.8
    container_name: drone-server
    ports:
      - 80:8000
      - 9000
    volumes:
      - ./volumes/drone:/var/lib/drone/
    restart: always
    depends_on:
      - gitea
    environment:
      - DRONE_OPEN=true
      - DRONE_HOST=http://drone-server:8000
      - DRONE_GITEA=true
      - DRONE_GITEA_URL=http://gitea:3000
      - DRONE_SECRET=secret
      - DRONE_NETWORK=appnet
    networks:
      - appnet

  drone-agent:
    image: drone/agent:0.8
    container_name: drone-agent
    command: agent
    restart: always
    depends_on:
      - drone-server
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - DRONE_SERVER=drone-server:9000
      - DRONE_SECRET=secret
    networks:
      - appnet

volumes:
  gitea-app:
  gitea-db:

networks:
  appnet:
    external: true
</code></pre>

<p>Create the volumes path:</p>

<pre><code>$ mkdir volumes
</code></pre>

<p>Create the external network:</p>

<pre><code>$ docker network create appnet
</code></pre>

<p>Some key configuration,</p>

<p>Our <code>SSH_DOMAIN</code> will be the domain that gets used for things like cloning a repository. When you register your gitea account, you will use the same credentials to logon to drone.</p>

<p>Deploy your stack:</p>

<pre><code>$ docker-compose up -d
</code></pre>

<h2>Register on Gitea</h2>

<p>When your deployment is done, access your gitea server which should be available on <code>http://your-docker-ip:3000/</code> complete the registration, if you decide to go with postgres your username/password will be <code>postgres</code> and your host will be <code>gitea-db:5432</code>.</p>

<p>Make sure to complete the administrator account to get your admin credentials.</p>

<h2>Setup SSH Key and Repo</h2>

<p>Generate a ssh key that you will use for communicating to git over ssh. If you have already have an ssh key you can skip this step.</p>

<pre><code class="bash">$ ssh-keygen -t rsa
# use the defaults
</code></pre>

<p>Login on gitea, once you are logged in, head over to profile / settings / ssh keys: <code>http://your-docker-ip:3000/user/settings/keys</code>.</p>

<p>Add a new ssh key, go back to your terminal and copy the public key which we will provide to gitea:</p>

<pre><code>$ cat ~/.ssh/id_rsa.pub
&lt;copy the contents to your clipboard&gt;
</code></pre>

<p>Paste your public key and provide a descriptive title.</p>

<p>Head back to your dashboard and create your first repository:</p>

<p><img width="1277" alt="image" src="https://user-images.githubusercontent.com/567298/55589336-49388b80-5730-11e9-8ae5-2589fea7e2b2.png"></p>

<p>It should look more or less like this:</p>

<p><img width="1007" alt="image" src="https://user-images.githubusercontent.com/567298/55589473-9583cb80-5730-11e9-8124-3bdedc221a70.png"></p>

<h2>Enable Repo on Drone</h2>

<p>Head over to drone and select the repositores on the right hand side <a href="http://">http://</a><your-docker-ip>:80/account/repos and enable your repository by toggline the selector, it should look more or less like this:</p>

<p><img width="1275" alt="image" src="https://user-images.githubusercontent.com/567298/55589614-f3b0ae80-5730-11e9-9358-54a6be611198.png"></p>

<p>Once its enabled head back to gitea.</p>

<h2>Clone the repository</h2>

<p>On your repository select ssh and copy the ssh link for your repository:</p>

<p><img width="974" alt="image" src="https://user-images.githubusercontent.com/567298/55589710-3b373a80-5731-11e9-956b-c921c42e6a2d.png"></p>

<p>Then from your terminal add your private ssh key to your ssh agent and clone the repository:</p>

<pre><code>$ eval $(ssh-agent)
$ ssh-add ~/.ssh/id_rsa
$ git clone git@your-docker-ip:your-user/your-repo.git
</code></pre>

<h2>Add Example Python Flask app to git</h2>

<p>I will use a basic python flask application with some tests.</p>

<p>Let&rsquo;s first add our pipeline definition for drone, so that drone understands how the pipeline should be run when gitea receives a commit:</p>

<pre><code class="bash">$ touch .drone.yml
</code></pre>

<p>Our pipeline:</p>

<pre><code class="yaml .drone.yml">pipeline:
  build:
    image: python:3.5.1-alpine
    commands:
      - pip install --upgrade pip setuptools wheel
      - pip wheel -r requirements.txt --wheel-dir=wheeldir --find-links=wheeldir
      - pip install --no-index --find-links=wheeldir -r requirements.txt
      - flake8 app
      - mkdir -p coverage
      - nosetests -v tests/ 
</code></pre>

<p>Lets add that to git:</p>

<pre><code>$ git add .drone.yml
$ git commit -m "initial add of our pipeline"
$ git push origin master
</code></pre>

<p>Our drone file should be in git, now our requirements dependency file for python:</p>

<pre><code class="bash requirements.txt">flask
nose
flake8
</code></pre>

<p>Our blank file to make our application a module:</p>

<pre><code>$ mkdir app
$ touch app/__init__.py
</code></pre>

<p>And our flask app:</p>

<pre><code class="python app/app.py">from flask import Flask
app = Flask(__name__)


@app.route("/")
def hello():
    return "Hello, World!"
</code></pre>

<p>Our tests directory and our python init file:</p>

<pre><code>$ mkdir tests
$ touch tests/__init__.py
</code></pre>

<p>Now that we have all our files ready, commit and push to git:</p>

<pre><code class="bash">$ git add .
$ git commit -m "add python app"
$ git push origin master
</code></pre>

<h2>Look at Drone Running</h2>

<p>Head over to drone and look at the builds, you should see your build running at <code>http://&lt;docker-ip&gt;:80/&lt;user&gt;/&lt;repo-name&gt;</code>:</p>

<p><img width="1269" alt="image" src="https://user-images.githubusercontent.com/567298/55590369-f8766200-5732-11e9-82fb-2bda2c8ad40a.png"></p>

<p>If everything ran as expected you should see that it passed.</p>

<h2>Build Status Badges</h2>

<p>You can also include the build status badges from drone which will look like:</p>

<p><img width="1032" alt="image" src="https://user-images.githubusercontent.com/567298/55590552-82bec600-5733-11e9-91f2-a65c5a94fac5.png"></p>

<p>You can use the drone api: <code>http://drone-ip:80/api/badges/&lt;your-user&gt;/&lt;your-repo&gt;/status.svg</code></p>

<pre><code>[![Build Status](http://your-ip/api/badges/your-user/your-repo/status.svg)
[![](https://images.microbadger.com/badges/image/gitea/gitea.svg)](https://microbadger.com/images/gitea/gitea "Get your own image badge on microbadger.com")
[![GitHub release](https://img.shields.io/github/release/go-gitea/gitea.svg)](https://github.com/go-gitea/gitea/releases/latest)
[![Help Contribute to Open Source](https://www.codetriage.com/go-gitea/gitea/badges/users.svg)](https://www.codetriage.com/go-gitea/gitea)
[![Become a backer/sponsor of gitea](https://opencollective.com/gitea/tiers/backer/badge.svg?label=backer&amp;color=brightgreen)](https://opencollective.com/gitea)
</code></pre>

<p>Overall gitea and drone is really amazing and quite impressed with it, especially from the low memory footprint and that its so easy to work with.</p>

<h2>Resources</h2>

<p>Have a look at this for more resources:</p>

<p><strong>Docs:</strong></p>

<ul>
<li><a href="https://github.com/drone/drone">https://github.com/drone/drone</a></li>
<li><a href="http://plugins.drone.io/drone-plugins/drone-docker/">http://plugins.drone.io/drone-plugins/drone-docker/</a></li>
<li><a href="https://docs.drone.io/reference/server/drone-user-create/">https://docs.drone.io/reference/server/drone-user-create/</a></li>
<li><a href="https://docs.gitea.io/en-us/install-with-docker/">https://docs.gitea.io/en-us/install-with-docker/</a></li>
</ul>


<p><strong>Examples:</strong></p>

<ul>
<li><a href="https://hackernoon.com/build-your-own-ci-cd-pipeline-with-drone-e43d7190989b">https://hackernoon.com/build-your-own-ci-cd-pipeline-with-drone-e43d7190989b</a></li>
<li><a href="https://github.com/drone-demos/drone-with-python">https://github.com/drone-demos/drone-with-python</a></li>
<li><a href="https://github.com/drone/awesome-drone">https://github.com/drone/awesome-drone</a></li>
<li><a href="https://github.com/juliantellez/drone-ci-pipeline">https://github.com/juliantellez/drone-ci-pipeline</a></li>
<li><a href="https://github.com/sguter90/docker-compose-gitea">https://github.com/sguter90/docker-compose-gitea</a></li>
<li><a href="https://gist.github.com/joffilyfe/1a99250cb74bb75e29cbe8d6ca8ceedb">https://gist.github.com/joffilyfe/1a99250cb74bb75e29cbe8d6ca8ceedb</a></li>
<li><a href="https://florian-latifi.at/2018/02/21/using-drone-to-build-and-deploy-a-jekyll-site/">https://florian-latifi.at/2018/02/21/using-drone-to-build-and-deploy-a-jekyll-site/</a></li>
<li><a href="https://angristan.xyz/host-your-own-ci-cd-server-with-drone/">https://angristan.xyz/host-your-own-ci-cd-server-with-drone/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Concourse Pipeline to Build a Docker Image Automatically on Git Commit]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/03/27/concourse-pipeline-to-build-a-docker-image-automatically-on-git-commit/"/>
    <updated>2019-03-27T17:50:54-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/03/27/concourse-pipeline-to-build-a-docker-image-automatically-on-git-commit</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/gzkdu9.jpg?nocache=1511644783495" alt="" /></p>

<p>In this tutorial we will build a ci pipeline using concourse to build and push a image to dockerhub automatically, whenever a new git commit is made to the master branch.</p>

<h2>Our Project Setup</h2>

<p>Our Directory Tree:</p>

<pre><code class="bash">$ find .
./Dockerfile
./ci
./ci/pipeline.yml
./README.md
./docker-tunnel
</code></pre>

<p>The project used in this example is not important, but you can check it out at <a href="https://github.com/ruanbekker/docker-remote-tunnel">https://github.com/ruanbekker/docker-remote-tunnel</a></p>

<h2>Our Pipeline</h2>

<p>A visual to see how the pipeline will look like in concourse:</p>

<p><img src="https://user-images.githubusercontent.com/567298/55114996-1832d800-50ec-11e9-85ef-bc283711fbde.png" alt="" /></p>

<p>Our pipeline definition will consist of 3 resources, <code>github repo</code>, <code>dockerhub image</code> and a <code>slack resource</code> to inform use whether a build has completed.</p>

<p>Then we are specifying that the job should be triggered on a git commit for the master branch, build and push to our dockerhub repo.</p>

<p>Our pipeline definition <code>ci/pipeline.yml</code>:</p>

<pre><code class="yaml">resources:
- name: git-repo
  type: git
  source:
    uri: git@github.com:ruanbekker/docker-remote-tunnel.git
    branch: master
    private_key: ((github_private_key))

- name: docker-remote-tunnel-image
  type: docker-image
  source:
    repository: ruanbekker/docker-remote-tunnel
    tag: test
    username: ((dockerhub_user))
    password: ((dockerhub_password))

- name: slack-alert
  type: slack-notification
  source:
    url: ((slack_notification_url))

resource_types:
  - name: slack-notification
    type: docker-image
    source:
      repository: cfcommunity/slack-notification-resource
      tag: v1.3.0

jobs:
- name: build-cached-image
  plan:
  - get: git-repo
    trigger: true
  - task: build-cached-image-workspace
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: rbekker87/build-tools

      outputs:
      - name: workspace
      inputs:
      - name: git-repo

      run:
        path: /bin/sh
        args:
        - -c
        - |
          output_dir=workspace

          cat &lt;&lt; EOF &gt; "${output_dir}/Dockerfile"
          FROM alpine

          ADD git-repo /tmp/git-repo
          RUN mv /tmp/git-repo/docker-tunnel /usr/bin/docker-tunnel
          RUN apk --no-cache add screen docker openssl openssh-client apache2-utils
          RUN /usr/bin/docker-tunnel -h
          RUN rm -rf /tmp/git-repo
          EOF

          cp -R ./git-repo "${output_dir}/git-repo"

  - put: docker-remote-tunnel-image
    params:
      build: workspace

    on_failure:
      put: slack-alert
      params:
        channel: '#system_events'
        username: 'concourse'
        icon_emoji: ':concourse:'
        silent: true
        text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) FAILED to build image
            https://ci.domain.com/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
    on_success:
      put: slack-alert
      params:
        channel: '#system_events'
        username: 'concourse'
        icon_emoji: ':concourse:'
        silent: true
        text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) SUCCESS - Image has been published
            https://ci.domain.com/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME

- name: test
  plan:
  - get: docker-remote-tunnel-image
    passed: [build-cached-image]
    trigger: true
  - get: git-repo
    passed: [build-cached-image]
  - task: run-tests
    image: docker-remote-tunnel-image
    config:
      platform: linux
      inputs:
      - name: git-repo
      run:
        dir: git-repo
        path: sh
        args:
        - /usr/bin/docker-tunnel
        - --help

    on_failure:
      put: slack-alert
      params:
        channel: '#system_events'
        username: 'concourse'
        icon_emoji: ':concourse:'
        silent: true
        text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) FAILED - Testing image failure
            https://ci.domain.com/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
    on_success:
      put: slack-alert
      params:
        channel: '#system_events'
        username: 'concourse'
        icon_emoji: ':concourse:'
        silent: true
        text: |
            *$BUILD_PIPELINE_NAME/$BUILD_JOB_NAME* ($BUILD_NAME) SUCCESS - Testing image Succeeded
            https://ci.domain.com/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME
</code></pre>

<p>Note that our secret information is templatized and saved in our local <code>credentials.yml</code> which should never be stored in version control:</p>

<pre><code class="yaml">slack_notification_url: https://api.slack.com/aaa/bbb/ccc
dockerhub_user: myuser
dockerhub_password: mypasswd
github_private_key: |-
        -----BEGIN RSA PRIVATE KEY-----
        some-secret-data
        -----END RSA PRIVATE KEY------
</code></pre>

<h2>Set the Pipeline:</h2>

<p>Now that we have our pipeline definition, credentials and application code (stored in version control), go ahead and set the pipeline, which will save the pipeline configuration in concourse:</p>

<pre><code class="bash"># pipeline name: my-docker-app-pipeline
$ fly -t scw sp -n main -c pipeline.yml -p my-docker-app-pipeline -l credentials.yml
</code></pre>

<p>Now the pipeline is saved on concourse but in a paused state, go ahead and unpause the pipeline:</p>

<pre><code class="bash">$ fly -t scw up -p my-docker-app-pipeline
</code></pre>

<h2>Test your Pipeline</h2>

<p>Make a commit to master and head over to concourse and look at it go:</p>

<p><img src="https://user-images.githubusercontent.com/567298/55116018-a5772c00-50ee-11e9-861e-a5ddc74550e2.png" alt="" /></p>

<p>Thanks for reading, make sure to check out my other posts on <a href="https://blog.ruanbekker.com/blog/categories/concourse">#concourse</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Concourse Pipeline With Resources Tutorial]]></title>
    <link href="http://blog.ruanbekker.com/blog/2019/02/14/concourse-pipeline-with-resources-tutorial/"/>
    <updated>2019-02-14T15:58:10-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2019/02/14/concourse-pipeline-with-resources-tutorial</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/gzkdu9.jpg?nocache=1511644783495" alt="" /></p>

<p>In Concourse, Resources refer to external resource types such as <code>s3</code>, <code>github</code> etc.</p>

<p>So for example, we can run a pipeline which pulls data from github, such as cloning a repository, so in other words the data that was cloned from the github repository is within the container where your tasks will be executed.</p>

<h2>Concourse Github Resourse Example</h2>

<p>In this tutorial we will use the github resource type, in conjunction with a task that will execute a script, where the script will be inside the github repository.</p>

<p>Our pipeline as <code>pipeline.yml</code>:</p>

<pre><code class="yaml">resources:
- name: concourse-tutorial
  type: git
  source:
    uri: https://github.com/ruanbekker/concourse-tutorial.git
    branch: master

jobs:
- name: job-hello-world
  public: true
  plan:
  - get: concourse-tutorial
  - task: hello-world
    file: concourse-tutorial/00-basic-tasks/task_hello_world.yml
</code></pre>

<p>You can head over to <a href="https://raw.githubusercontent.com/ruanbekker/concourse-tutorial/master/00-basic-tasks/task_hello_world.yml">hello-world</a> task on github to see the task, but all it does is running a <code>uname -a</code></p>

<p>So our job has a task that will call the action defined in our <code>task_hello_world.yml</code> which retrieves it from the <code>get</code> step, as you can see it&rsquo;s the <code>concourse-tutorial</code> resource, which is defined under the resources section as a git resource type.</p>

<p>Set the pipeline:</p>

<pre><code class="bash">$ fly -t ci sp -c pipeline.yml -p 04-hello-world

apply configuration? [yN]: y
pipeline created!
</code></pre>

<p>Unpause the pipeline:</p>

<pre><code class="bash">$ fly -t ci up -p 04-hello-world
unpaused '04-hello-world'
</code></pre>

<p>Trigger the job (trigger is off; default)</p>

<pre><code class="bash">$ fly -t ci tj -j 04-hello-world/job-hello-world --watch
started 04-hello-world/job-hello-world #4

initializing
running uname -a
Linux 6a91b808-c488-4e3c-7b51-404f73405c31 4.9.0-8-amd64 #1 SMP Debian 4.9.110-3+deb9u4 (2018-08-21) x86_64 GNU/Linux
succeeded
</code></pre>

<p>So this job cloned the github repository, called the task file which calls the bash script from th github repository to run <code>uname -a</code></p>

<p>For my other content on concourse, have a look at the <a href="https://blog.ruanbekker.com/blog/categories/concourse/">concourse</a> category.</p>

<h2>Thank You</h2>

<p>Please feel free to show support by, <strong>sharing</strong> this post, making a <strong>donation</strong>, <strong>subscribing</strong> or <strong>reach out to me</strong> if you want me to demo and write up on any specific tech topic.</p>

<center>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick" />
<input type="hidden" name="hosted_button_id" value="W7CBGYTCWGANQ" />
<input type="image" src="https://user-images.githubusercontent.com/567298/49853901-461c3700-fdf1-11e8-9d80-8a424a3173af.png" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
<img alt="" border="0" src="https://www.paypal.com/en_ZA/i/scr/pixel.gif" width="1" height="1" />
</form>
</center>


<p><br></p>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a Basic CI Pipeline on Gitlab]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/12/19/setup-a-basic-ci-pipeline-on-gitlab/"/>
    <updated>2018-12-19T05:43:00-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/12/19/setup-a-basic-ci-pipeline-on-gitlab</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/50217968-0629f680-0393-11e9-8387-ad69937eb891.png" alt="" /></p>

<p>In this tutorial we will setup a Basic CI (Continuous Integration) Pipeline on Gitlab.</p>

<p>The code for this example is available on <a href="https://gitlab.com/rbekker87/demo-ci-basic-pipeline">gitlab.com/rbekker87/demo-ci-basic-pipeline</a>.</p>

<p>If you would like to read more on <a href="https://www.atlassian.com/continuous-delivery/continuous-integration">Continuous Integration / Continuous Deliver (CI/CD)</a>.</p>

<h2>What will we be doing?</h2>

<p>The aim for this is every time there is a commit made to the master branch, that the jobs defined by the <code>.gitlab-ci.yml</code> will be executed and will only pass if exit code 0 has been returned on the scripts.</p>

<p>The jobs gets executed on <a href="https://docs.gitlab.com/ee/ci/yaml/">gitlab runners</a> which is hosted with Giltab. Important to note is that every job runs independently from each other.</p>

<h2>Our Basic Pipeline</h2>

<p>In this pipeline we will have 2 basic jobs, each job execute a set of scripts:</p>

<p>Build:</p>

<pre><code>$ echo "this is building" 
$ hostname
$ mkdir builds
$ touch builds/data.txt
$ echo "true" &gt; builds/data.txt
</code></pre>

<p>Test:</p>

<pre><code>$ echo "this is testing"
$ hostname
$ test -f builds/data.txt
$ grep "true" builds/data.txt
</code></pre>

<h2>Setup the Pipeline:</h2>

<p>From a newly created repository which i&rsquo;ve cloned to my workspace, create the config:</p>

<pre><code>$ touch .gitlab-ci.yml
</code></pre>

<p>The config for above yaml file:</p>

<pre><code class="yaml">stages:
  - build
  - test

build:
  stage: build
  script:
    - echo "this is building" 
    - hostname
    - mkdir builds
    - touch builds/data.txt
    - echo "false" &gt; builds/data.txt
  artifacts:
    paths:
      - builds/

test:
  stage: test
  script:
    - echo "this is testing"
    - hostname
    - test -f builds/data.txt
    - grep "true" builds/data.txt
</code></pre>

<h2>Config Explained</h2>

<ul>
<li>We define 2 stages for this pipeline: build and test</li>
<li>We provide context of each job, the stage, the script (commands that will be executed in the lifecycle of the runner) and artifacts (artifacts will be the content that will be transferred, as each job runs in a different runner/container)</li>
</ul>


<p>Note that I deliberately made a mistake so that my pipeline can fail. I populated the content &ldquo;false&rdquo; into the <code>builds/data.txt</code> file from the build job and grep for the word &ldquo;true&rdquo; on the test job, so this job will fail.</p>

<h2>Push to Github</h2>

<p>Save the content to the config file, add, commit and push to master:</p>

<pre><code class="bash">$ git add .gitlab-ci.yml
$ git commit -m "add gitlab-ci config"
$ git push origin master
</code></pre>

<h2>Gitlab Pipelines</h2>

<p>From the Gitlab UI, if you head over to CI/CD -> Pipelines, you should see your pipeline running:</p>

<p><img src="https://user-images.githubusercontent.com/567298/50216548-c103c580-038e-11e9-959b-ffdcf6038305.png" alt="" /></p>

<p>When you select the Pipeline ID, you should be presented with the jobs available in your pipeline:</p>

<p><img src="https://user-images.githubusercontent.com/567298/50216698-2ce62e00-038f-11e9-8cb5-8b67dc6e6e3d.png" alt="" /></p>

<p>Select Jobs, and you should see an overview of your jobs. At this moment we can see that the build job has completed, and that the test job is busy running:</p>

<p><img src="https://user-images.githubusercontent.com/567298/50216644-0922e800-038f-11e9-81d8-d40dd6ff0862.png" alt="" /></p>

<p>Shortly thereafter the status of the test job should change to failed, select the Job ID and you should see the output:</p>

<p><img src="https://user-images.githubusercontent.com/567298/50216833-89e1e400-038f-11e9-896f-9d36aad1c55d.png" alt="" /></p>

<p>From the above output it gives you a link to create a new issue, which is quite handy.</p>

<h2>Fix the Pipeline Config</h2>

<p>Let&rsquo;s go ahead and change the content in the <code>.gitlab-ci.yml</code> config and push to master:</p>

<pre><code class="bash">$ vim .gitlab-ci.yml
</code></pre>

<p>Change line 12 from <code>- echo "false" &gt; builds/data.txt</code> to <code>- echo "true" &gt; builds/data.txt</code>, the full content of the file:</p>

<pre><code class="yaml">stages:
  - build
  - test

build:
  stage: build
  script:
    - echo "this is building" 
    - hostname
    - mkdir builds
    - touch builds/data.txt
    - echo "true" &gt; builds/data.txt
  artifacts:
    paths:
      - builds/

test:
  stage: test
  script:
    - echo "this is testing"
    - hostname
    - test -f builds/data.txt
    - grep "true" builds/data.txt
</code></pre>

<p>Commit and push to master:</p>

<pre><code class="bash">$ git add .gitlab-ci.yml
$ git commit -m "change content in script"
$ git push origin master
</code></pre>

<p>When you head over to Pipelines, you will see that the pipeline is busy running, and on the right the commit that we just made:</p>

<p><img src="https://user-images.githubusercontent.com/567298/50217143-91ee5380-0390-11e9-8b08-08626984f176.png" alt="" /></p>

<h2>Great Success</h2>

<p>Select the Pipeline ID, then select Jobs, you should see both jobs succeeded:</p>

<p><img src="https://user-images.githubusercontent.com/567298/50217299-f9a49e80-0390-11e9-871d-78423f0651c7.png" alt="" /></p>

<p>Select the Job ID of the test job, and from the output you will see that the job succeeded:</p>

<p><img src="https://user-images.githubusercontent.com/567298/50217268-eb568280-0390-11e9-972c-58f23ce39741.png" alt="" /></p>

<p>From this output you can also confirm from both jobs, that each job ran in a different runner as the hostnames that was returned to stdout was different.</p>

<h2>Resources</h2>

<p>This was a really basic example to demonstrate Gitlab CI. Some relevant resources to this post:</p>

<ul>
<li><a href="https://docs.gitlab.com/ee/ci/">Gitlab CI/CD Docs</a></li>
<li><a href="https://hackernoon.com/setting-up-ci-cd-on-gitlab-step-by-step-guide-part-1-826385728223">Full CI/CD Example with Gitlab and Heroku</a></li>
</ul>


<h2>Thank You</h2>

<p>Please feel free to show support by, <strong>sharing</strong> this post, making a <strong>donation</strong>, <strong>subscribing</strong> or <strong>reach out to me</strong> if you want me to demo and write up on any specific tech topic.</p>

<center>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick" />
<input type="hidden" name="hosted_button_id" value="W7CBGYTCWGANQ" />
<input type="image" src="https://user-images.githubusercontent.com/567298/49853901-461c3700-fdf1-11e8-9d80-8a424a3173af.png" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
</form>
</center>


<p><br></p>

<p>Ad space:</p>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>




<p><p></p>

<p>Thanks for reading!</p>
]]></content>
  </entry>
  
</feed>
