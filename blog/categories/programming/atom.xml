<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2018-11-21T16:35:41-05:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang: Building a Basic Web Server in Go]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/11/21/golang-building-a-basic-web-server-in-go/"/>
    <updated>2018-11-21T00:57:54-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/11/21/golang-building-a-basic-web-server-in-go</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/golang-web-server.png" alt="" /></p>

<p>Continuing with our <a href="https://blog.ruanbekker.com/blog/categories/golang-tutorial/">#golang-tutorial</a> blog series, in this post we will setup a Basic HTTP Server in Go.</p>

<h2>Our Web Server</h2>

<p>Our Web Server will respond on 2 Request Paths:</p>

<pre><code>- / -&gt; returns "Hello, Wolrd!"
- /cheers -&gt; returns "Goodbye!"
</code></pre>

<h2>Application Code</h2>

<p>If you have not setup your golang environment, you can do so by visiting <a href="https://medium.com/@AkyunaAkish/setting-up-a-golang-development-environment-mac-os-x-d58e5a7ea24f">@AkyunaAkish&rsquo;s Post on Setting up a Golang Development Enviornment on MacOSX</a>.</p>

<p>Create the <code>server.go</code> or any filename of your choice:</p>

<pre><code class="golang">package main

import (
    "io"
        "log"
    "net/http"
)

func hello(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/plain; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    io.WriteString(w, "Hello, World!" + "\n")
    log.Println("hello function handler was executed")
}

func goodbye(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/plain; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    io.WriteString(w, "Cheers!" + "\n")
    log.Println("goodbye function handler was executed")
}

func main() {
    http.HandleFunc("/", hello)
    http.HandleFunc("/cheers", goodbye)
    http.ListenAndServe(":8000", nil)
}
</code></pre>

<p>Explanation of what we are doing:</p>

<ul>
<li>Programs runs in the package <code>main</code></li>
<li>We are importing 3 packages: <code>io</code>, <code>log</code> and <code>net/http</code></li>
<li>HandleFunc registers the handler function for the given pattern in the DefaultServeMux, in this case the HandleFunc registers <code>/</code> to the <code>hello</code> handler function and <code>/cheers</code> to the goodbye handler function.</li>
<li>In our 2 handler functions, we have two arguments:

<ul>
<li>The first one is <code>http.ResponseWriter</code> and its corresponding response stream, which is actually an interface type.</li>
<li>The second is <code>*http.Request</code> and its corresponding HTTP request. <code>io.WriteString</code> is a helper function to let you write a string into a given writable stream, this is named the <code>io.Writer</code> interface in Golang.</li>
</ul>
</li>
<li>ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux</li>
<li>The logging is not a requirement, but used it for debugging/verbosity</li>
</ul>


<h2>Running our Server:</h2>

<p>Run the http server:</p>

<pre><code class="bash">$ go run server.go
</code></pre>

<h2>Client Side Requests:</h2>

<p>Run client side http requests to your golang web server:</p>

<pre><code class="bash">$ curl -i http://localhost:8000/
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Date: Wed, 21 Nov 2018 21:33:42 GMT
Content-Length: 14

Hello, World!
</code></pre>

<p>And another request to <code>/cheers</code>:</p>

<pre><code class="bash">$ curl -i http://localhost:8000/cheers
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Date: Wed, 21 Nov 2018 21:29:46 GMT
Content-Length: 8

Cheers!
</code></pre>

<h2>Server Side Output:</h2>

<p>As we used the log package, the logging gets returned to stdout:</p>

<pre><code class="bash">$ go run server.go
2018/11/21 23:29:36 hello function handler was executed
2018/11/21 23:29:46 goodbye function handler was executed
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://golang.org/doc/code.html">https://golang.org/doc/code.html</a></li>
<li><a href="https://gowalker.org/net/http#HandleFunc">https://gowalker.org/net/http#HandleFunc</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Tutorial Series Setup and Variables]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/08/09/ruby-tutorial-series-setup-and-variables/"/>
    <updated>2018-08-09T21:11:52-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/08/09/ruby-tutorial-series-setup-and-variables</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/ruby-variables-logo.png" alt="" /></p>

<p>In this post we will setup our Ruby environment, then start printing out values to the console and will also be touching on variables.</p>

<h2>Ruby Environment:</h2>

<p>I have a Docker image built on Alpine, the resources can be found via:</p>

<ul>
<li><a href="https://hub.docker.com/r/rbekker87/alpine-ruby">DockerHub</a></li>
<li><a href="https://github.com/ruanbekker/dockerhub-sources/blob/master/alpine-ruby/Dockerfile">GitHub</a></li>
</ul>


<p>To setup a Ruby environment on your workstation, I would recommend using <a href="https://github.com/rbenv/rbenv">https://github.com/rbenv/rbenv</a>.</p>

<h2>Drop into a Ruby Shell:</h2>

<p>I will be using Docker to drop into a ruby container:</p>

<pre><code class="bash">$ docker run -it rbekker87/alpine-ruby:2.5 sh

       ______       _____
______ ___  /__________(_)___________
_  __ `/_  /___  __ \_  /__  __ \  _ \
/ /_/ /_  / __  /_/ /  / _  / / /  __/
\__,_/ /_/  _  .___//_/  /_/ /_/\___/
            /_/

Alpine Build:
Container Hostname: 8a4dfc590dd0
Checkout my Docker Blogs:
- https://sysadmins.co.za/tag/docker
- http://blog.ruanbekker.com/blog/categories/docker

$ irb
irb(main):001:0&gt;
</code></pre>

<p>If you have the <code>irb</code> output, you should be good to go.</p>

<h2>Strings and Integers</h2>

<p>You will find when you enter a string, which is represented as one or more characters enclosed within quotation marks:</p>

<pre><code class="bash">irb(main):001:0&gt; "hello"
=&gt; "hello"
</code></pre>

<p>The integers will be without the quotation marks, when we introduce anything within quotation marks, ruby will read it as a string. So for a integer, lets provide ruby with a number and the number will be returned to the shell:</p>

<pre><code class="bash">irb(main):002:0&gt; 1
=&gt; 1
</code></pre>

<p>Using mathematical symbols like the <code>+</code> will either sum the two values when they are integers, or concatenate when they are strings.</p>

<p>Let&rsquo;s start with strings: we will add the string <code>hello</code> and <code>world</code></p>

<pre><code class="bash">irb(main):003:0&gt; "hello" + "world"
=&gt; "helloworld"
</code></pre>

<p>Now let&rsquo;s add two numbers together, <code>10</code> and <code>20</code>:</p>

<pre><code class="bash">irb(main):004:0&gt; 10 + 20
=&gt; 30
</code></pre>

<p>As you can see, it did a calculation on the two numbers as they were treated as integeres. But what happens when we add them as strings?</p>

<pre><code class="bash">irb(main):005:0&gt; "10" + "20"
=&gt; "1020"
</code></pre>

<p>Adding them as strings, will concatenate them.</p>

<h2>String Methods</h2>

<p>Ruby&rsquo;s strings has many built in methods, which makes it convenient manipulating data, let me go through a couple that I am working with:</p>

<p>Getting the length of the string:</p>

<pre><code class="bash">irb(main):006:0&gt; "hello".length
5
</code></pre>

<p>Is the string empty?</p>

<pre><code class="bash">irb(main):007:0&gt; "hello".empty?
=&gt; false
</code></pre>

<p>Getting the index position of 0 of the string:</p>

<pre><code class="bash">irb(main):008:0&gt; "hello"[0]
=&gt; "h"
</code></pre>

<p>Getting a array of your string:</p>

<pre><code class="bash">irb(main):009:0&gt; "hello".chars
=&gt; ["h", "e", "l", "l", "o"]
</code></pre>

<p>Returning your string in Uppercase:</p>

<pre><code class="bash">irb(main):010:0&gt; "hello".upcase
=&gt; "HELLO"
</code></pre>

<p>Returning your string in Lowercase:</p>

<pre><code class="bash">irb(main):011:0&gt; "HELLO".downcase
=&gt; "hello"
</code></pre>

<p>Capitalize your String:</p>

<pre><code class="bash">irb(main):012:0&gt; "hello".capitalize
=&gt; "Hello"
</code></pre>

<p>Swap the case of your string:</p>

<pre><code class="bash">irb(main):013:0&gt; "Hello".swapcase
=&gt; "hELLO"
</code></pre>

<h2>Variables</h2>

<p>Let&rsquo;s define variables to the static content that we used above.</p>

<p>Let&rsquo;s define our key: <code>word</code> to the value: of <code>hello, world</code>:</p>

<pre><code class="bash">irb(main):019:0&gt; word = "hello, world"
=&gt; "hello, world"
</code></pre>

<p>Accessing the variables value:</p>

<pre><code class="bash">irb(main):020:0&gt; word
=&gt; "hello, world"
</code></pre>

<p>We can also use <code>puts</code>, which stands for <code>put string</code>, which prints out the value to the terminal:</p>

<pre><code class="bash">irb(main):021:0&gt; puts word
hello, world
</code></pre>

<p>We can also, format our variable so that we can add something like a exclamation mark:</p>

<pre><code class="bash">irb(main):022:0&gt; puts "#{word}!"
hello, world!
</code></pre>

<p>Let&rsquo;s do the same with integers:</p>

<pre><code class="bash">irb(main):023:0&gt; num_1 = 10
=&gt; 10
irb(main):024:0&gt; num_2 = 20
=&gt; 20
</code></pre>

<p>Now when we calculate the numbers using variables, you will find the expected result of 30:</p>

<pre><code class="bash">irb(main):025:0&gt; num_1 + num_2
=&gt; 30
</code></pre>

<p>or:</p>

<pre><code class="bash">irb(main):026:0&gt; num_1 + num_2
puts "#{num_1 + num_2}"
30
</code></pre>

<h2>Variables are Mutable:</h2>

<p>Remember that variables are mutable, so they can be changed after they have been set, lets take age for example:</p>

<pre><code class="bash">irb(main):027:0&gt; age = 20
irb(main):028:0&gt; puts age
20

irb(main):029:0&gt; age = 22
irb(main):030:0&gt; puts age
22
</code></pre>

<h2>Strings and Integers:</h2>

<p>What happens when we add strings and integers together in one line:</p>

<pre><code class="bash">irb(main):038:0&gt; name = "ruan"
=&gt; "ruan"
irb(main):039:0&gt; id = 120398
=&gt; 120398
irb(main):040:0&gt; puts "#{name + id}"
Traceback (most recent call last):
        3: from /usr/bin/irb:11:in `&lt;main&gt;'
        2: from (irb):40
        1: from (irb):40:in `+'
TypeError (no implicit conversion of Integer into String)
</code></pre>

<p>That is because we cant concatenate strings with integers, so we will need to convert the integer to a string, we do that with the <code>to_s</code> method:</p>

<pre><code class="bash">irb(main):041:0&gt; puts "#{name + id.to_s}"
ruan120398
</code></pre>

<p>And if we want to define that to a variable:</p>

<pre><code class="bash">irb(main):042:0&gt; userid = "#{name + id.to_s}"
irb(main):043:0&gt; userid
=&gt; "ruan120398"
</code></pre>

<h2>Working with rb files:</h2>

<p>We can add this together in a file with a <code>.rb</code> extension and call the file as an argument with ruby, as a script:</p>

<p>Create the file, in my case <code>test.rb</code></p>

<pre><code class="bash">$ vim test.rb
</code></pre>

<pre><code class="ruby">user = "ruan"
idnumber = 23049823
userid = "#{user + idnumber}"

puts "#{userid}"
</code></pre>

<p>Running the ruby file:</p>

<pre><code class="bash">$ ruby test.rb
ruan23049823
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-work-with-string-methods-in-ruby">1</a></li>
<li><a href="https://learnrubythehardway.org/book/ex3.html">2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Programming Tutorial Series]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/08/09/ruby-programming-tutorial-series/"/>
    <updated>2018-08-09T20:59:34-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/08/09/ruby-programming-tutorial-series</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/ruby-tutorial-logo.png" alt="" /></p>

<p>Welcome! This will be a multi post ruby tutorial programming series, as I am on a mission learning ruby.</p>

<h2>Outline of the Series:</h2>

<p>This may change, but the path will look like this:</p>

<ul>
<li>Setup, The Terminal and Variables</li>
<li>Arrays</li>
<li>Data Types</li>
<li>Objects, Classes and Methods</li>
</ul>


<p>All posts associated to this tutorial series will be tagged as <a href="http://blog.ruanbekker.com/blog/tags/ruby-tutorial-series">#ruby-tutorial-series</a></p>

<p>Resources:</p>

<ul>
<li><a href="http://ruby-for-beginners.rubymonstas.org/index.html">RFB</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang: Reading From Files and Writing to Disk With Arguments]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/03/02/golang-reading-from-files-and-writing-to-disk-with-arguments/"/>
    <updated>2018-03-02T07:11:13-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/03/02/golang-reading-from-files-and-writing-to-disk-with-arguments</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/VJmUZz.jpg" alt="" /></p>

<p>From our <a href="https://goo.gl/ih43uv">Previous Post</a> we wrote a basic golang app that reads the contents of a file and writes it back to disk, but in a static way as we defined the source and destination filenames in the code.</p>

<p>Today we will use arguments to specify what the source and destination filenames should be instead of hardcoding it.</p>

<h2>Our Golang Application:</h2>

<p>We will be using if statements to determine if the number of arguments provided is as expected, if not, then a usage string should be returned to stdout. Then we will loop through the list of arguments to determine what the values for our source and destination file should be.</p>

<p>Once it completes, it prints out the coice of filenames that was used:</p>

<pre><code class="go app.go">package main

import (
    "io/ioutil"
    "os"
    "fmt"
)

var (
    input_filename string
    output_filename string
)

func main() {

    if len(os.Args) &lt; 5 {
        fmt.Printf("Usage: (-i/--input) 'input_filename' (-o/--output) 'output_filename' \n")
        os.Exit(0)
    }

    for i, arg := range os.Args {
        if arg == "-i" || arg == "--input" {
            input_filename = os.Args[i+1]
            }
        if arg == "-o" || arg == "--output" {
            output_filename = os.Args[i+1]
            }
        }

    input_file_content, error := ioutil.ReadFile(input_filename)

    if error != nil {
        panic(error)
    }

    fmt.Println("File used for reading:", input_filename)

    ioutil.WriteFile(output_filename, input_file_content, 0644)
    fmt.Println("File used for writing:", output_filename)
}
</code></pre>

<p>Build your application:</p>

<pre><code class="bash">$ go build app.go
</code></pre>

<p>Run your application with no additional arguments to determine the expected behaviour:</p>

<pre><code class="bash">$ ./app
Usage: (-i/--input) 'input_filename' (-o/--output) 'output_file-to-write'
</code></pre>

<p>It works as expected, now create a source file, then run the application:</p>

<pre><code class="bash">$ echo $RANDOM &gt; myfile.txt
</code></pre>

<p>Run the application, and in this run, we will set the destination file as newfile.txt:</p>

<pre><code class="bash">$ ./app -i myfile.txt -o newfile.txt
File used for reading: myfile.txt
File used for writing: newfile.txt
</code></pre>

<p>Checking out the new file:</p>

<pre><code>$ cat newfile.txt
8568
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang: Reading From Files and Writing to Disk With Golang]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/03/02/golang-reading-from-files-and-writing-to-disk-with-golang/"/>
    <updated>2018-03-02T06:44:59-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/03/02/golang-reading-from-files-and-writing-to-disk-with-golang</id>
    <content type="html"><![CDATA[<p><img src="![](https://i.snag.gy/VJmUZz.jpg" alt="" />)</p>

<p>Today we will create a very basic application to read content from a file, and write the content from the file back to disk, but to another filename.</p>

<p>Basically, doing a copy of the file to another filename.</p>

<h2>Golang Environment: Golang Docker Image</h2>

<p>Dropping into a Golang Environment using Docker:</p>

<pre><code class="bash">$ docker run -it golang:alpine sh
</code></pre>

<h2>Our Golang Application</h2>

<p>After we are in our container, lets write our app:</p>

<pre><code class="go app.go">package main

import (
    "io/ioutil"
)

func main() {

    content, error := ioutil.ReadFile("source-data.txt")
    if error != nil {
        panic(error)
    }

    error = ioutil.WriteFile("destination-data.txt", content, 0644)
    if error != nil {
        panic(error)
    }
}
</code></pre>

<p>Building our application to a binary:</p>

<pre><code class="bash">$ go build app.go
</code></pre>

<p>Creating our <code>source-data.txt</code> :</p>

<pre><code class="bash">$ echo "foo" &gt; source-data.txt
</code></pre>

<h2>Running the Golang App:</h2>

<p>When we run this app, it will read the content of <code>source-data.txt</code> and write it to <code>destination-data.txt</code>:</p>

<pre><code class="bash">$ ./app.go
</code></pre>

<p>We can see that the file has been written to disk:</p>

<pre><code class="bash">$ ls | grep data
destination-data.txt
source-data.txt
</code></pre>

<p>Making sure the data is the same, we can do a <code>md5sum hash</code> function on them:</p>

<pre><code class="bash">$ md5sum source-data.txt
d3b07384d113edec49eaa6238ad5ff00  source-data.txt

$ md5sum destination-data.txt
d3b07384d113edec49eaa6238ad5ff00  destination-data.txt
</code></pre>

<h2>Next:</h2>

<p>This was a very static way of doing it, as you need to hardcode the filenames. In the <a href="https://goo.gl/t8fasN">next post</a> I will show how to use arguments to make it more dynamic.</p>
]]></content>
  </entry>
  
</feed>
