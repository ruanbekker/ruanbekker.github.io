<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2018-11-30T09:40:38-05:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Setup a Serverless URL Shortener With API Gateway Lambda and DynamoDB on AWS]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/11/30/how-to-setup-a-serverless-url-shortener-with-api-gateway-lambda-and-dynamodb-on-aws/"/>
    <updated>2018-11-30T02:51:24-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/11/30/how-to-setup-a-serverless-url-shortener-with-api-gateway-lambda-and-dynamodb-on-aws</id>
    <content type="html"><![CDATA[<p>!
<a href="https://objects.ruanbekker.com/assets/images/aws-logo.png"></a></p>

<p>Today we will set a Serverless URL Shortener using API Gateway, Lambda with Python and DynamoDB.</p>

<h2>Overview</h2>

<p>The service that we will be creating, will shorten URLs via our API which will create an entry on DynamoDB. When a GET method is performed on the shortened URL, a GetItem is executed on DynamoDB to get the Long URL and a 301 Redirect is performed to redirect the client to intended destination URL.</p>

<h2>The Setup</h2>

<p>The following services will be used to create a URL Shortener:</p>

<ul>
<li>AWS API Gateway: ( <code>/create</code>: to create a shortened url and <code>/t/{id}</code> to redirect to long url)</li>
<li>AWS IAM: (Role and Policy for Permissions to call DynamoDB from Lambda)</li>
<li>AWS Lambda: (Application Logic)</li>
<li>AWS DynamoDB: (Persistent Store to save our Data)</li>
<li>AWS ACM: (Optional: Certificate for your Domain)</li>
<li>AWS Route53: (Optional: DNS for the domain that you want to associate to your API)</li>
</ul>


<p>The flow will be like the following:</p>

<ul>
<li>POST Request gets made to the <code>/create</code> request path with the <code>long_url</code> data in the payload</li>
<li>This data is then used by the Lambda function to create a short url and create a entry in DynamoDB</li>
<li>In DynamoDB the entry is created with the short id as the hash key and the long url as one of the attributes</li>
<li>The response to the client will be the short url</li>
<li>When a GET method is performed on the id eg <code>/t/{short_id}</code>, a lookup gets done on the DynamoDB table, retrieves the long url from the table</li>
<li>A 301 redirect gets performed on API Gateway and the client gets redirected to the intended url</li>
</ul>


<h2>Creating the URL Shortener</h2>

<p>After completing this tutorial you will have your own Serverless URL Shortener using API Gateway, Lambda and DynamoDB.</p>

<h2>IAM Permissions</h2>

<p>On AWS IAM, create a IAM Policy, in my case the policy name is <code>lambda-dynamodb-url-shortener</code> and note that I masked out my account number:</p>

<pre><code class="json">{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "dynamodb:PutItem",
                "dynamodb:DeleteItem",
                "dynamodb:GetItem",
                "dynamodb:Query",
                "dynamodb:UpdateItem"
            ],
            "Resource": "arn:aws:dynamodb:eu-west-1:xxxxxxxxxxxx:table/url-shortener-table"
        }
    ]
}
</code></pre>

<p>Head over to <a href="https://console.aws.amazon.com/iam/home?region=eu-west-1#/roles">IAM Roles</a>, select Create Role, Select Lambda as the Trusted Entitiy from the AWS Service section, go ahead with the permissions and select your IAM Policy that was created, in my case <code>lambda-dynamodb-url-shortener</code> and <code>AWSLambdaBasicExecution</code> role. Give your Role a name, in my case <code>lambda-dynamodb-url-shortener-role</code>.</p>

<h2>DynamoDB Table</h2>

<p>Next, head over to <a href="https://eu-west-1.console.aws.amazon.com/dynamodb/home?region=eu-west-1#create-table:">DynamoDB</a> create a table, in my case the table name: <code>url-shortener-table</code> and the primary key <code>short_id</code> set to string:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-02.png" alt="" /></p>

<h2>Lambda Functions</h2>

<p>Once the table is created, head over to <a href="https://eu-west-1.console.aws.amazon.com/lambda/home?region=eu-west-1#/create?firstrun=true">Lambda</a> and create a Lambda function, in my case using Python 3.6 and provide a name, where I used: <code>url-shortener-create</code> and select the IAM role from the previous role that we created, this function will be the lambda function that will create the shortened urls:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-03-large.png" alt="" /></p>

<p>The code for your lambda function which will take care of creating the short urls and save them to dynamodb, take note on the region and table name to ensure that it matches your setup:</p>

<pre><code class="python">import os
import json
import boto3
from string import ascii_letters, digits
from random import choice, randint
from time import strftime, time
from urllib import parse

app_url = os.getenv('APP_URL')
min_char = int(os.getenv('MIN_CHAR'))
max_char = int(os.getenv('MAX_CHAR'))
string_format = ascii_letters + digits

ddb = boto3.resource('dynamodb', region_name = 'eu-west-1').Table('url-shortener-table')

def generate_timestamp():
    response = strftime("%Y-%m-%dT%H:%M:%S")
    return response

def expiry_date():
    response = int(time()) + int(604800)
    return response

def check_id(short_id):
    if 'Item' in ddb.get_item(Key={'short_id': short_id}):
        response = generate_id()
    else:
        return short_id

def generate_id():
    short_id = "".join(choice(string_format) for x in range(randint(min_char, max_char)))
    print(short_id)
    response = check_id(short_id)
    return response

def lambda_handler(event, context):
    analytics = {}
    print(event)
    short_id = generate_id()
    short_url = app_url + short_id
    long_url = json.loads(event.get('body')).get('long_url')
    timestamp = generate_timestamp()
    ttl_value = expiry_date()

    analytics['user_agent'] = event.get('headers').get('User-Agent')
    analytics['source_ip'] = event.get('headers').get('X-Forwarded-For')
    analytics['xray_trace_id'] = event.get('headers').get('X-Amzn-Trace-Id')

    if len(parse.urlsplit(long_url).query) &gt; 0:
        url_params = dict(parse.parse_qsl(parse.urlsplit(long_url).query))
        for k in url_params:
            analytics[k] = url_params[k]

    response = ddb.put_item(
        Item={
            'short_id': short_id,
            'created_at': timestamp,
            'ttl': int(ttl_value),
            'short_url': short_url,
            'long_url': long_url,
            'analytics': analytics,
            'hits': int(0)
        }
    )

    return {
        "statusCode": 200,
        "body": short_url
    }
</code></pre>

<p>Set a couple of environment variables that will be used in our function, min and max chars from the screenshot below is the amount of characters that will be used in a random manner to make the short id unique. The app_url will be your domain name, as this will be returned to the client with the short id eg. <code>https://tiny.myserverlessapp.net/t/3f8Hf38n398t</code> :</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-04-lambda.png" alt="" /></p>

<p>While you are on Lambda, create the function that will retrieve the long url, in my case <code>url-shortener-retrieve</code>:</p>

<pre><code class="python">import os
import json
import boto3

ddb = boto3.resource('dynamodb', region_name = 'eu-west-1').Table('eng-url-shortener')

def lambda_handler(event, context):
    short_id = event.get('short_id')

    try:
        item = ddb.get_item(Key={'short_id': short_id})
        long_url = item.get('Item').get('long_url')
        # increase the hit number on the db entry of the url (analytics?)
        ddb.update_item(
            Key={'short_id': short_id},
            UpdateExpression='set hits = hits + :val',
            ExpressionAttributeValues={':val': 1}
        )

    except:
        return {
            'statusCode': 301,
            'location': 'https://objects.ruanbekker.com/assets/images/404-blue.jpg'
        }

    return {
        "statusCode": 301,
        "location": long_url
    }
</code></pre>

<h2>API Gateway</h2>

<p>Head over to <a href="https://console.aws.amazon.com/apigateway/home?region=us-east-1#/apis">API Gateway</a> and create your API, in my case <code>url-shortener-api</code></p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-05-api-gateway.png" alt="" /></p>

<p>Head over to Resources:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-06-api-gateway.png" alt="" /></p>

<p>and create a new resource called <code>/create</code>:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-07-api-gateway.png" alt="" /></p>

<p>Once the resource is created, create a post method on the <code>create</code> resource and select Lambda as the integration type and lambda proxy integration as seen below:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-09-api-gateway.png" alt="" /></p>

<p>Once you save it, it will ask to give api gateway permission to invoike your lambda function wich you can accept by hitting ok as below:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-10-iam-permission.png" alt="" /></p>

<p>When you look at the POST method on your create resource, it should look like this:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-12-api-gateway.png" alt="" /></p>

<p>Select the root resource <code>/</code> and from Actions create a new resource <code>/t</code>:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-13-api-gateway.png" alt="" /></p>

<p>Select the <code>/t</code> resource and create a new resource named <code>shortid</code> and provide <code>{shortid}</code> in the resource path as this will be the data that will be proxied through to our lambda function:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-14-api-gateway.png" alt="" /></p>

<p>Create a GET method on the <code>/t/{shortid}</code> resource and select <code>url-shortener-retrieve</code> lambda function as the function from the lambda integration selection as seen below:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-17-api-gateway.png" alt="" /></p>

<p>Again, grant api gateway permission to invoke your function:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-18-iam-permission.png" alt="" /></p>

<p>When you select the GET method, it should look like this:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-19-api-gateway.png" alt="" /></p>

<p>Select the Integration Request and head over to Mapping Templates:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-20-api-gateway.png" alt="" /></p>

<p>from the Request body passtrhough, add a mapping template <code>application/json</code> and provide the following mapping template:</p>

<pre><code>{
    "short_id": "$input.params('shortid')"
}
</code></pre>

<p>On the Method Response:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-21-api-gateway.png" alt="" /></p>

<p>Delete the 200 HTTP Status Response and create a new response by &ldquo;Add Response&rdquo;, add <code>301</code> HTTP Status, add <code>Location</code> Header to the response.</p>

<p>Navigate to the Integration Response from the <code>/{shortid}</code> GET method:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-21-api-gateway.png" alt="" /></p>

<p>delete the 200 HTTP Response, add &ldquo;integration response&rdquo;, set method response status to 301 and add header mapping for location to integration.response.body.location as below:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-23-api-gateway.png" alt="" /></p>

<p>make sure to select the integration response to - so that the method response reflects to 301:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-24-api-gateway.png" alt="" /></p>

<p>Navigate to Actions and select &ldquo;Deploy API&rdquo;, select your stage, in my case <code>test</code> and deploy:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-25-api-gateway.png" alt="" /></p>

<p>Go to stages, select your stage, select the post request to reveal the API URL:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-26-api-gateway.png" alt="" /></p>

<p>Time to test out the URL Shortener:</p>

<pre><code class="bash">curl -XPOST -H "Content-Type: application/json" https://xxxxxx.execute-api.eu-west-1.amazonaws.com/test/create -d '{"long_url": "https://www.google.com/search?q=helloworld"}'
https://tiny.myserverlessapp.net/t/pcnWoCGCr2ad1x
</code></pre>

<h2>ACM Certificates</h2>

<p>At this moment we dont have our domain connected with our API Gateway, and we would also want a certificate on our application, which we can use ACM to request a certificate that can be associated to our domain. So in order to do that, first request a certificate on <a href="https://eu-west-1.console.aws.amazon.com/acm/home?region=eu-west-1#/privatewizard/">ACM</a>. Select Request a certificate, create a wildcard entry: <code>*.yourdomain.com</code>, select DNS Validation (If you host with Route53, they allow you the option to create the record).</p>

<p>Head back to API Gateway to associate the Domain and ACM Certificate to our API:</p>

<p>From the &ldquo;Custom Domain Names&rdquo; section, create a custom domain name, once you selected regional, it will ask for the target domain name, which will be the resolved to your API Endpoint that was created, and from the &ldquo;Base Path Mappings&rdquo; section, select <code>/</code> as the path to your API stage, in my case <code>url-shortener-api:test</code>:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-28-api-gateway.png" alt="" /></p>

<h2>Route 53</h2>

<p>Last part is to create a Route53 entry for tiny.yourdomain.com to resolve to the CNAME value of the target domain name that was provided in the custom domain names section:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/tiny-url-setup-29-route53.png" alt="" /></p>

<h2>Demo the URL Shortener Service:</h2>

<p>Once everything is setup we can test, by creating a Shortened URL:</p>

<pre><code class="bash">$ curl -XPOST -H "Content-Type: application/json" https://tiny.myserverlessapp.net/create -d '{"long_url": "https://www.google.com/search?q=helloworld"}'
https://tiny.myserverlessapp.net/t/p7ISNcxTByXhN
</code></pre>

<p>Testing out the Short URL to redirect to the Destination URL:</p>

<pre><code class="bash">$ curl -ivL https://tiny.myserverlessapp.net/t/p7ISNcxTByXhN
*   Trying 34.226.10.0...
* TCP_NODELAY set
* Connected to tiny.myserverlessapp.net (34.226.10.0) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate: *.myserverlessapp.net
* Server certificate: Amazon
* Server certificate: Amazon Root CA 1
* Server certificate: Starfield Services Root Certificate Authority - G2
&gt; GET /t/p7ISNcxTByXhN HTTP/1.1
&gt; Host: tiny.myserverlessapp.net
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 301 Moved Permanently
HTTP/1.1 301 Moved Permanently
&lt; Date: Tue, 29 Nov 2018 00:05:02 GMT
Date: Tue, 29 Nov 2018 00:05:02 GMT
&lt; Content-Type: application/json
Content-Type: application/json
&lt; Content-Length: 77
Content-Length: 77
&lt; Connection: keep-alive
Connection: keep-alive
&lt; x-amzn-RequestId: f79048c8-cb56-41e8-b21d-b45fac47453a
x-amzn-RequestId: f79048c8-cb56-41e8-b21d-b45fac47453a
&lt; x-amz-apigw-id: OeKPHH7_DoEFdjg=
x-amz-apigw-id: OeKPHH7_DoEFdjg=
&lt; Location: https://www.google.com/search?q=helloworld
Location: https://www.google.com/search?q=helloworld
</code></pre>

<p>At this moment our API is open to the world, which is probably not the best as everyone will be able to Shorten URL&rsquo;s. You can check out <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-setup-api-key-with-console.html">Set Up API Keys Using the API Gateway Console</a> documentation on how to secure your application by utilizing a api key which can be included in your request headers when Shortening URLs.</p>

<p>For a bit of housekeeping, you can implement TTL on DynamoDB so that old items expire, which can help you to refrain your dynamodb table from growing into large amounts of storage, you can have a look at a post on <a href="https://blog.ruanbekker.com/blog/2017/11/22/delete-old-items-with-amazons-dynamodb-ttl-feature/">Delete Old Items with Amazons DynamoDB TTL Feature</a> to implement that.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Flask Tutorial Series: Create a Hello World App]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/11/27/python-flask-tutorial-series-create-a-hello-world-app-p1/"/>
    <updated>2018-11-27T08:36:20-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/11/27/python-flask-tutorial-series-create-a-hello-world-app-p1</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/python-flask.png" alt="" /></p>

<p>This is post 1 of the <a href="http://blog.ruanbekker.com/blog/categories/flask-tutorial/">Python Flask Tutorial Series</a></p>

<h2>What is Python Flask</h2>

<p>Flask is a Micro Web Framework which is written in Python and is based on the Werkzeug Toolkit and the Jinja2 Template Engine.</p>

<p>Flask is super lightweight, and you import the modules as you need them, from some research some say that Flask is more designed for smaller applications whereas Django is designed for your larger applications.</p>

<p>a Good read on the [Differences and Performance Comparison]. With that being said, if you are planning with scale I am pretty sure that Flask can handle big applications, but it probably depends what your application is doing. More <a href="https://www.reddit.com/r/Python/comments/2jja20/is_flask_good_enough_to_develop_large_applications/">Detailed Discussion</a> on Reddit.</p>

<h2>Hello World in Python Flask</h2>

<p>In this post we will be creating a &ldquo;Hello, World&rdquo; application to demonstrate how easy it is to run a Flask Appliation.</p>

<p>The only requirement you need to run this app, would be to to have <code>python</code> and <code>pip</code> installed so that we can install the <code>Flask</code> package which is needed.</p>

<h2>Creating your Traditional Hello World App</h2>

<p>We will install flask globally, but will write up a <a href="https://sysadmins.co.za/python-flask-series-environment-setup-p3/">future post</a> on how to setup a virtual environment for you application. Install the flask package:</p>

<pre><code class="bash">$ pip install flask
</code></pre>

<p>The code for the Hello World Flask Application:</p>

<pre><code class="python">from flask import Flask 

app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello, World!'

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=5000, debug=True)
</code></pre>

<p>Save the above code as <code>app.py</code> and then run the application as follows:</p>

<pre><code>$ python app.py
 * Debug mode: on
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 282-492-812
</code></pre>

<h2>It&rsquo;s Running What Now?</h2>

<p>We can see that our application is running on 127.0.0.1 and listening on port: 5000, if you point your browser to this URL, you will be returned with: Hello, World!</p>

<pre><code class="bash">$ curl -i -XGET http://127.0.0.1:5000/
HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 13
Server: Werkzeug/0.12.1 Python/2.7.12
Date: Thu, 27 Nov 2018 13:51:15 GMT

Hello, World!
</code></pre>

<h2>Explaining the Application Code</h2>

<ul>
<li>First, we imported the <code>Flask</code> class from the flask module, using: <code>from flask import Flask</code></li>
<li>Then we instantiate our application from the Flask class: <code>app = Flask(__name__)</code> using our module&rsquo;s name as a parameter, where our app object will use this to resolve resources. We are using <code>__name__</code> , which links our module to our app object.</li>
<li>Next up we have the <code>@app.route('/')</code> decorator. Flask uses decorators for URL Routing.</li>
<li>Below our decorator, we have a <code>view function</code>, this function will be executed when the <code>/</code> route gets matched, in this case returning <code>Hello, World!</code></li>
<li>The last line starts our server, and from this example it runs locally on <code>127.0.0.1</code> on port: <code>5000</code> and <code>debug is enabled</code>, so any error details will be logged directly in the browser. This is only recommended for test/dev and not for production as you can make your service vulnerable for hackers.</li>
</ul>


<h2>Let&rsquo;s Extend our Hello World App</h2>

<p>We would like to add the route &lsquo;/movie&rsquo; which will return a random movie name:</p>

<pre><code class="python">import random
from flask import Flask

app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello, World!'

@app.route('/movie')
def movie():
    movies = ['godfather', 'deadpool', 'toy story', 'top gun', 'forrest gump']
    return random.choice(movies)

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=5000, debug=True)
</code></pre>

<p>Making a GET Request on the &lsquo;/movie&rsquo; route:</p>

<pre><code class="bash">$ curl -XGET http://127.0.0.1/movie
forrest gump
</code></pre>

<p>This was just a basic example and will be covering more topics in detail at a further stage.</p>

<p>Next up, setting up our Python Environment, with Virtual Environment (virtualenv)</p>

<h2>Related Content</h2>

<p>All posts related to this tutorial series will be listed under <a href="http://blog.ruanbekker.com/blog/categories/flask-tutorial/">Python Flask Tutorial Series</a> tag.</p>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Python Flask: Tutorial Series]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/11/27/introduction-to-python-flask-tutorial-series/"/>
    <updated>2018-11-27T08:28:33-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/11/27/introduction-to-python-flask-tutorial-series</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/python-flask.png" alt="" /></p>

<p>This post is the index for all the posts that will be covered in our Python Flask Tutorial Series:</p>

<h2>What will be covered</h2>

<p>This is intended for people starting out with Python Flask and the basics will be covered on using Flask so that you can get familliar with the framework.</p>

<p>The following will be covered:</p>

<ul>
<li>Hello World Basic App</li>
<li>Routing in Flask</li>
<li>Jinja Templating</li>
<li>Static Files</li>
<li>etc</li>
</ul>


<p>More will be posted</p>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IAM Policy to Allow Team Wide and User Level Permissions on AWS Secrets Manager]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/11/12/iam-policy-to-allow-team-wide-and-user-level-permissions-on-aws-secrets-manager/"/>
    <updated>2018-11-12T16:32:24-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/11/12/iam-policy-to-allow-team-wide-and-user-level-permissions-on-aws-secrets-manager</id>
    <content type="html"><![CDATA[<p>In this post we will simulate a scenario where a team would like to have access to create secrets under a team path name like <code>/security-team/prod/*</code> and <code>/security-team/dev/*</code> and allow all the users from that team to be able to write and read secrets from that path. Then have individual users create and read secrets from their own isolated path: <code>/security-team/personal/aws-username/*</code> so they can create their personal secrets.</p>

<script id="mNCC" language="javascript">
    medianet_width = "728";
    medianet_height = "90";
    medianet_crid = "218284798";
    medianet_versionId = "3111299";
  </script>


<script src="//contextual.media.net/nmedianet.js?cid=8CUD78FSV"></script>


<h2>Our Scenario:</h2>

<ul>
<li>Create IAM Policy</li>
<li>Create 2 IAM Users: <code>jack.smith</code> and <code>steve.adams</code></li>
<li>Create IAM Group, Associate IAM Policy to the Group</li>
<li>Attach 2 Users to the Group</li>
</ul>


<p>The IAM Policy:</p>

<pre><code>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "Stmt1541597166491",
            "Action": [
                "secretsmanager:CreateSecret",
                "secretsmanager:DeleteSecret",
                "secretsmanager:DescribeSecret",
                "secretsmanager:GetRandomPassword",
                "secretsmanager:GetSecretValue",
                "secretsmanager:ListSecretVersionIds",
                "secretsmanager:ListSecrets",
                "secretsmanager:PutSecretValue",
                "secretsmanager:TagResource",
                "secretsmanager:UpdateSecret"
            ],
            "Effect": "Allow",
            "Resource": [
                "arn:aws:secretsmanager:eu-west-1:123456789012:secret:/security-team/prod/*",
                "arn:aws:secretsmanager:eu-west-1:123456789012:secret:/security-team/dev/*",
                "arn:aws:secretsmanager:eu-west-1:123456789012:secret:/security-team/personal/${aws:username}/*"
            ]
        }
    ]
}
</code></pre>

<p>Either configure the access keys and secret keys into the credential provider using aws cli, or for this demonstration I will use them inside the code. But never hardcode your credentials.</p>

<h2>Create Secrets with Secrets Manager in AWS using Python Boto3</h2>

<p>Instantiate user1 and user2:</p>

<pre><code class="python">&gt;&gt;&gt; import boto3
&gt;&gt;&gt; jack = boto3.Session(aws_access_key_id='ya', aws_secret_access_key='xx', region_name='eu-west-1').client('secretsmanager')
&gt;&gt;&gt; steve = boto3.Session(aws_access_key_id='yb', aws_secret_access_key='xx', region_name='eu-west-1').client('secretsmanager')
</code></pre>

<p>Create a team wide secret with jack:</p>

<pre><code class="python">&gt;&gt;&gt; jack.create_secret(Name='/security-team/prod/app1/username', SecretString='appreader')
{'ResponseMetadata': {'RetryAttempts': 0, 'HTTPStatusCode': 200, 'RequestId': 'x', 'HTTPHeaders': {'date': 'Thu, 08 Nov 2018 07:50:35 GMT', 'x-amzn-requestid': 'x', 'content-length': '193', 'content-type': 'application/x-amz-json-1.1', 'connection': 'keep-alive'}}, u'VersionId': u'x', u'Name': u'/security-team/prod/app1/username', u'ARN': u'arn:aws:secretsmanager:eu-west-1:123456789012:secret:/security-team/prod/app1/username-12ABC00'}
</code></pre>

<p>Let jack and steve try to read the secret:</p>

<pre><code class="python">&gt;&gt;&gt; jack.get_secret_value(SecretId='/security-team/prod/app1/username')['SecretString']
'appreader'
&gt;&gt;&gt; steve.get_secret_value(SecretId='/security-team/prod/app1/username')['SecretString']
'appreader'
</code></pre>

<p>Now let jack create a personal secret, let him read it:</p>

<pre><code class="python">&gt;&gt;&gt; jack.create_secret(Name='/security-team/personal/jack.smith/svc1/password', SecretString='secret')
&gt;&gt;&gt; jack.get_secret_value(SecretId='/security-team/personal/jack.smith/svc1/password')['SecretString']
'secret'
</code></pre>

<p>Now let steve try to read the secret and you will see that access is denied:</p>

<pre><code class="python">&gt;&gt;&gt; steve.get_secret_value(SecretId='/security-team/personal/jack.smith/username')['SecretString']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
...
    raise error_class(parsed_response, operation_name)
botocore.exceptions.ClientError: An error occurred (AccessDeniedException) when calling the GetSecretValue operation: User: arn:aws:iam::123456789012:user/steve.adams is not authorized to perform: secretsmanager:GetSecretValue on resource: arn:aws:secretsmanager:eu-west-1:123456789012:secret:/security-team/personal/jack.smith/svc1/password-a1234b
</code></pre>

<p>Thats it for this post</p>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"rbekker87","width":728,"height":90,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>


<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Query 24 Hours Worth of Data Using BatchGet on Amazon DynamoDB Using Scan and Filter Without a GSI]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/10/30/query-24-hours-worth-of-data-using-batchget-on-amazon-dynamodb-using-scan-and-filter-without-a-gsi/"/>
    <updated>2018-10-30T14:53:43-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/10/30/query-24-hours-worth-of-data-using-batchget-on-amazon-dynamodb-using-scan-and-filter-without-a-gsi</id>
    <content type="html"><![CDATA[<p>I&rsquo;m testing how to query data in DynamoDB which will always be the retrieval of yesterdays data, without using a Global Secondary Index.</p>

<p>This is done just to see what other ways you can use to query data based on a specific timeframe.</p>

<script id="mNCC" language="javascript">
    medianet_width = "728";
    medianet_height = "90";
    medianet_crid = "218284798";
    medianet_versionId = "3111299"; 
  </script>


<script src="//contextual.media.net/nmedianet.js?cid=8CUD78FSV"></script>


<h2>Use-Case:</h2>

<p>Data from DynamoDB needs to be batch processed (daily for the last 24-hours), into a external datasource. Data will be written into DynamoDB, the HK (uuid) and RK (timestamp) will be duplicated to the daily table. But only uuid and timestamp will be duplicated to the daily table, and only data for that day will be written into that datestamp formatted table name.</p>

<p>Let&rsquo;s say data for 2018-10-30 needs to be written into our external data source, we will do a scan on table <code>tbl-test_20181030</code>, then from our response we will have a list of HashKeys (uuid) which we will use to do a BatchGet Item on our base table: <code>tbl-test_base</code>, which essentially grabs all the data for that day.</p>

<p>If deeper filtering needs to be done on that day, the FilterExpression can be used to do a deeper filtering which leads to grabbing only the filtered down data from the base table.</p>

<p><em>Note:</em> The base table might have millions of items, so a Scan operation on the Base table would be really expensive, as it reads all the items in the table.</p>

<p>Once the data has been processed, the daily or metadata table can be removed.</p>

<h2>DynamoDB Table Design</h2>

<p>The base table: <code>tbl-test_base</code> will have:</p>

<ul>
<li>HashKey: uuid (string)</li>
<li>RangeKey: timestamp (number)</li>
<li>Attributes: city, stream, transaction_date, name, metric_uri</li>
<li>Item will look like:</li>
</ul>


<pre><code class="python">{
  u'uuid': u'fb4ddeb9-3b5e-47b3-bbab-1aa1d8e8f47b', 
  u'timestamp': 1540891276, 
  u'city': u'sydney', 
  u'stream': u'NONE', 
  u'transaction_date': u'2018-10-30 11:21:16', 
  u'metric_uri': u'some-dummy-metric-uri', 
  u'name': u'frank'
}
</code></pre>

<p>he Daily Table: <code>tbl-test_20181030</code> will look like:</p>

<ul>
<li>HashKey: <code>uuid</code></li>
<li>Attributes: <code>timestamp</code></li>
<li>Item will look like:</li>
</ul>


<pre><code class="python">{
  u'uuid': u'fb4ddeb9-3b5e-47b3-bbab-1aa1d8e8f47b', 
  u'timestamp': 1540891276
}
</code></pre>

<h2>Demonstration using Python</h2>

<p>Creating the Metadata table:</p>

<pre><code class="python">import boto3, time, uuid, random

session = boto3.Session(region_name='eu-west-1', profile_name='dev')
resource = session.resource('dynamodb')
client = session.client('dynamodb')

def create_table():
    table_name = "tbl-test_{0}".format(time.strftime("%Y%m%d"))
    response = resource.create_table(
        TableName=table_name,
        KeySchema=[{
            'AttributeName': 'uuid',
            'KeyType': 'HASH'
        }],
        AttributeDefinitions=[{
            'AttributeName': 'uuid',
            'AttributeType': 'S'
        }],
        ProvisionedThroughput={
            'ReadCapacityUnits': 1,
            'WriteCapacityUnits': 1
        }
    )

    resource.Table(table_name).wait_until_exists()

    arn = client.describe_table(TableName=table_name)['Table']['TableArn']
    client.tag_resource(
        ResourceArn=arn,
        Tags=[
            {'Key': 'Name','Value': 'dynamo_table'},
            {'Key': 'Environment','Value': 'Dev'},
            {'Key': 'CreatedBy','Value': 'Ruan'}
        ]
    )

    return resource.Table(table_name).table_status

print(create_table())
</code></pre>

<p>Write 400 Items to DynamoDB:</p>

<pre><code class="python">import boto3, time, uuid, random

session = boto3.Session(region_name='eu-west-1', profile_name='dev')
resource = session.resource('dynamodb')
client = session.client('dynamodb')

base_table = 'tbl-test_base'
meta_table = 'tbl-test_{0}'.format(time.strftime("%Y%m%d"))

people = ['james', 'john', 'frank', 'paul', 'nathan', 'kevin']
cities = ['ireland', 'cape town', 'pretoria', 'paris', 'amsterdam', 'auckland', 'sydney']

def write_dynamo(uuid, timestamp):
    resource.Table(base_table).put_item(
        Item={
            'uuid': uuid, 
            'timestamp': timestamp, 
            'metric_uri': 'some-dummy-metric-uri', 
            'transaction_date': time.strftime("%Y-%m-%d %H:%M:%S"), 
            'name': random.choice(people), 
            'stream': 'NONE', 
            'city': random.choice(cities)
        }
    )

    resource.Table(meta_table).put_item(
        Item={
            'uuid': uuid, 
            'timestamp': timestamp
        }
    )

    return 'Written'

for x in xrange(400):
    time.sleep(1)
    write_dynamo(str(uuid.uuid4()), int(time.time()))
    print(x)
</code></pre>

<p>Getting Data for 20181030 but also filter data greater than the timestamp attribute, greater than <code>1540841144</code> in epoch time (which will give us about 254 items).</p>

<p>The BatchGet Item supports up to 100 items per call, we will limit the scans on 100 items per call, then paginate using the ExlusiveStartKey with the value of our LastEvaluatedKey that we will get from our response:</p>

<pre><code class="python">import boto3,time
from boto3.dynamodb.conditions import Key

base_table = 'tbl-test_base'
meta_table = 'tbl-test_20181030'

session = boto3.Session(region_name='eu-west-1', profile_name='dev')
resource = session.resource('dynamodb')
table = resource.Table(meta_table)
filtering_expression = Key('timestamp').gt(1540841144)

response = table.scan(FilterExpression=filtering_expression, Limit=100)

finished=False
while finished != True:
    if 'LastEvaluatedKey' in response.keys():
        print("Getting {} Items".format(response['Count']))
        items = resource.batch_get_item(RequestItems={base_table: {'Keys': response['Items']}})
        print(items['Responses'][base_table])
        time.sleep(2)
        response = table.scan(FilterExpression=filtering_expression, Limit=100, ExclusiveStartKey=response['LastEvaluatedKey'])
    else:
        print("Getting {} Items".format(response['Count']))
        items = resource.batch_get_item(RequestItems={base_table: {'Keys': response['Items']}})
        print(items['Responses'][base_table])
        finished=True
</code></pre>

<p>Running it:</p>

<pre><code class="bash">$ python dynamodb-batch-get.py
Getting 100 Items
[{u'city': u'pretoria', u'uuid': u'e8bc0d1c-2b57-4de2-b0e1-35ef1fe0edf1', u'stream': u'NONE', u'timestamp': Decimal('1540846990'), u'transaction_date': u'2018-10-29 23:03:10', u'metric_uri': u'some-dummy-metric-uri', u'name': u'frank'}, {u'city': u'amsterdam', u'uuid':
...
Getting 100 Items
[{u'city': u'sydney', u'uuid': u'5bc51ce9-2809-46c9-a3f2-ff8180086d92', u'stream': u'NONE', u'timestamp': Decimal('1540848599'), u'transaction_date': u'2018-10-29 23:29:59', u'metric_uri': u'some-dummy-metric-uri', u'name': u'frank'}
...
Getting 54 Items
[{u'city': u'cape town', u'uuid': u'5e069f34-0e97-4a49-9ca9-da2213edb689'...
</code></pre>

<p>Verifying that each call only scans 100 at a time:</p>

<pre><code class="python">&gt;&gt;&gt; response = table.scan(FilterExpression=filtering_expression, Limit=100)
&gt;&gt;&gt; response.keys()
[u'Count', u'Items', u'LastEvaluatedKey', u'ScannedCount', 'ResponseMetadata']
&gt;&gt;&gt; response.get('LastEvaluatedKey')
{u'uuid': u'e8c52a55-ca9e-4718-83d2-1b44a90f43e6'}
&gt;&gt;&gt; response.get('Count')
100
&gt;&gt;&gt; response.get('ScannedCount')
100
</code></pre>

<h2>Other Thoughts:</h2>

<p>Querying data is a lot easier using a Global Secondary Index where you could similarly have the metric_uri as the HashKey and transaction_date as the RangeKey:</p>

<pre><code class="python">&gt;&gt;&gt; response = table.query(
    IndexName='metric_uri-transaction_date-index', 
    KeyConditionExpression=Key('metric_uri').eq('some-dummy-metric-uri') &amp; Key('transaction_date').begins_with('2018-10-30')
)
&gt;&gt;&gt; response['Count']
400
</code></pre>

<p>Also note that depending on how you setup your GSI, in most cases its a exact duplicate in storage from your base table, so could potentially be double the costs.</p>
]]></content>
  </entry>
  
</feed>
