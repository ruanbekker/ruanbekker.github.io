<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Security | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/security/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2018-08-09T21:08:23-04:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Add a Authentication Header to Your Python Flask App]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/06/01/add-a-authentication-header-to-your-python-flask-app/"/>
    <updated>2018-06-01T03:28:05-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/06/01/add-a-authentication-header-to-your-python-flask-app</id>
    <content type="html"><![CDATA[<p><img src="http://obj-cache.cloud.ruanbekker.com/flask.png" alt="" /></p>

<p>We will write a simple Python Flask application that requires authentication in order to respond with a 200 HTTP Status code.</p>

<h2>Python Flask Application:</h2>

<p>Our Python Flask application will require the Header <code>x-api-key dhuejso2dj3d0</code> in the HTTP Request, to give us a 200 HTTP Status code, if not, we will respond with a 401 Unauthorized Response:</p>

<pre><code class="python">from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/')
def index():
    headers = request.headers
    auth = headers.get("X-Api-Key")
    if auth == 'asoidewfoef':
        return jsonify({"message": "OK: Authorized"}), 200
    else:
        return jsonify({"message": "ERROR: Unauthorized"}), 401

if __name__ == '__main__':
    app.run()
</code></pre>

<p>To get the headers, you can use <code>headers.get("X-Api-Key")</code> or <code>headers["X-Api-Key"]</code></p>

<p>Create a virtual environment, install flask and run the app:</p>

<pre><code class="bash">$ virtualenv .venv
$ source .venv/bin/activate
$ python app.py
 * Serving Flask app "app" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
</code></pre>

<h2>Requests to our App:</h2>

<p>Let&rsquo;s first make a request with no headers, which should then give us a 401 Unautorhized response:</p>

<pre><code class="bash">$ curl -i http://localhost:5000

HTTP/1.0 401 UNAUTHORIZED
Content-Type: application/json
Content-Length: 33
Server: Werkzeug/0.14.1 Python/3.6.5
Date: Fri, 01 Jun 2018 07:26:25 GMT

{"message":"ERROR: Unauthorized"}
</code></pre>

<p>Now let&rsquo;s include the authentication token in our headers. If the string is the same as the one in the code, we should see a 200 HTTP Response:</p>

<pre><code class="bash">$ curl -i -H 'x-api-key: asoidewfoef' http://localhost:5000

HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 29
Server: Werkzeug/0.14.1 Python/3.6.5
Date: Fri, 01 Jun 2018 07:27:03 GMT

{"message":"OK: Authorized"}
</code></pre>

<h2>Note:</h2>

<p>From a best practice, its not a good decision to hard code sensitive details in your code, but rather read that from an encrypted database and store that in your applications environment variables, and let your application read from the environment variables, something like that :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Temporary IAM Credentials From EC2 Instance Metadata Using Python]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/05/09/temporary-iam-credentials-from-ec2-instance-metadata-using-python/"/>
    <updated>2018-05-09T12:14:11-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/05/09/temporary-iam-credentials-from-ec2-instance-metadata-using-python</id>
    <content type="html"><![CDATA[<p>From a Best Practice Perspective its good not having to pass sensitive information around, and especially not hard coding them.</p>

<h2>Best Practice: Security</h2>

<p>One good way is to use SSM with KMS to Encrypt/Decrypt them, but since EC2 has a <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html">Metadata Service</a> available, we can make use of that to retrieve <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html">temporary credentials</a>. One requirement though, is that the instance will require an IAM Role where the code will be executed on. The IAM Role also needs to have sufficient privileges to be able to execute, whatever you need to do.</p>

<p>The <a href="https://12factor.net/">12 Factor</a> Methodology however states to use config in your environment variables, but from the application logic, its easy to save it in our environment.</p>

<h2>Scenario: Applications on AWS EC2</h2>

<p>When you run applications on Amazon EC2 the nodes has access to the EC2 Metadata Service, so in this case our IAM Role has a Policy that authorizes GetItem on our DynamoDB table, therefore we can define our code with no sensitive information, as the code will do all the work to get the credentials and use the credentials to access DynamoDB.</p>

<h2>Use Temporary Credentials to Read from DynamoDB</h2>

<p>In this example we will get the temporary credentials from the metadata service, then define the temporary credentials in our session to authorize our request against dynamodb to read from our table:</p>

<pre><code class="python">&gt;&gt;&gt; import boto3
&gt;&gt;&gt; from botocore.utils import InstanceMetadataFetcher
&gt;&gt;&gt; from botocore.credentials import InstanceMetadataProvider
&gt;&gt;&gt; provider = InstanceMetadataProvider(iam_role_fetcher=InstanceMetadataFetcher(timeout=1000, num_attempts=2))
&gt;&gt;&gt; creds = provider.load()

&gt;&gt;&gt; session = boto3.Session(
    aws_access_key_id=creds.access_key,
    aws_secret_access_key=creds.secret_key,
    aws_session_token=creds.token
)

&gt;&gt;&gt; ddb = session.client('dynamodb')

&gt;&gt;&gt; response = ddb.get_item(
    TableName='my-dynamodb-table',
    Key={
        'node_type': {
            'S': 'primary_manager'
        }
    }
)

&gt;&gt;&gt; print(response['Item']['ip']['S'])
'10.0.0.32
</code></pre>

<p>Also, when you are logged onto the EC2 instance, you can use curl to see the temporary credentials information:</p>

<pre><code class="bash">$ iam_role_name=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/)
$ curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/${iam_role_name}
{
  "Code" : "Success",
  "LastUpdated" : "2018-05-09T14:25:48Z",
  "Type" : "AWS-HMAC",
  "AccessKeyId" : "",
  "SecretAccessKey" : "",
  "Token" : "",
  "Expiration" : "2018-05-09T20:46:55Z"
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Encryption and Decryption With the PyCrypto Module Using the AES Cipher in Python]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/04/30/encryption-and-decryption-with-the-pycrypto-module-using-the-aes-cipher-in-python/"/>
    <updated>2018-04-30T01:43:26-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/04/30/encryption-and-decryption-with-the-pycrypto-module-using-the-aes-cipher-in-python</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/0MaLsx.jpg" alt="" /></p>

<p>While I&rsquo;m learning a lot about encryption at the moment, I wanted to test out encryption with the PyCrypto module in Python using the <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Advanced Encryption Standard (AES)</a> Symmetric Block Cipher.</p>

<h2>Installing PyCrypto:</h2>

<pre><code class="bash">$ pip install pycrypto --user
</code></pre>

<h2>PyCrypto Example:</h2>

<p>Our AES Key needs to be either 16, 24 or 32 bytes long and our Initialization Vector needs to be 16 Bytes long. That will be generated using the random and string modules.</p>

<p>Encrypting:</p>

<pre><code class="python">&gt;&gt;&gt; from Crypto.Cipher import AES
&gt;&gt;&gt; import random, string, base64

&gt;&gt;&gt; key = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for x in range(32))
&gt;&gt;&gt; iv = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for x in range(16))

&gt;&gt;&gt; print(key, len(key))
('BLhgpCL81fdLBk23HkZp8BgbT913cqt0', 32)
&gt;&gt;&gt; print(iv, len(iv))
('OWFJATh1Zowac2xr', 16)

&gt;&gt;&gt; enc_s = AES.new(key, AES.MODE_CFB, iv)
&gt;&gt;&gt; cipher_text = enc_s.encrypt('this is a super important message')
&gt;&gt;&gt; encoded_cipher_text = base64.b64encode(cipher_text)
&gt;&gt;&gt; print(encoded_cipher_text)
'AtBa6zVB0UQ3U/50ogOb6g09FlyPdpmJB7UzoCqxhsQ6'
</code></pre>

<p>Decrypting:</p>

<pre><code class="python">&gt;&gt;&gt; from Crypto.Cipher import AES
&gt;&gt;&gt; import base64
&gt;&gt;&gt; key = 'BLhgpCL81fdLBk23HkZp8BgbT913cqt0'
&gt;&gt;&gt; iv = 'OWFJATh1Zowac2xr'

&gt;&gt;&gt; decryption_suite = AES.new(key, AES.MODE_CFB, iv)
&gt;&gt;&gt; plain_text = decryption_suite.decrypt(base64.b64decode(encoded_cipher_text))
&gt;&gt;&gt; print(plain_text)
this is a super important message
</code></pre>

<p>It&rsquo;s not needed to use base64, but to have the ability to stay away from strange characters I decided to encode them with base64 :D</p>

<h2>References:</h2>

<ul>
<li><a href="http://docs.python-guide.org/en/latest/scenarios/crypto/">PyCrypto</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Wiki - AES</a></li>
<li><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Feedback_(CFB">Wiki - CFB Mode</a>)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Script to Decrypt Encrypted Data With AWS KMS]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/10/20/python-script-to-decrypt-encrypted-data-with-aws-kms/"/>
    <updated>2017-10-20T04:54:51-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/10/20/python-script-to-decrypt-encrypted-data-with-aws-kms</id>
    <content type="html"><![CDATA[<p>Quick script to decrypt data that was encrypted with your KMS key:</p>

<h2>The Script:</h2>

<p>The script requires the encrypted scring as an argument:</p>

<pre><code class="python">#!/usr/bin/env python

import boto3
import sys
from base64 import b64decode

try:
    encrypted_value = sys.argv[1]
except IndexError:
    print("Usage: {} {}".format(sys.argv[0], 'the-encrypted-string'))
    exit(1)

session = boto3.Session(
        region_name='eu-west-1',
        profile_name='default'
    )

kms = session.client('kms')

response = kms.decrypt(CiphertextBlob=b64decode(encrypted_value))['Plaintext']
print("Decrypted Value: {}".format(response))
</code></pre>

<p>Change the permissions so that the file is executable:</p>

<pre><code class="bash">$ chmod +x decrypt.py
</code></pre>

<h2>Usage:</h2>

<pre><code class="bash">$ ./decrypt.py asdlaskjdasidausd09q3uoijad09ujd38u309
Decrypted Value: thisIsMyDecryptedValue
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx Reverse Proxy for Elasticsearch and Kibana 5 on AWS]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/09/16/nginx-reverse-proxy-for-elasticsearch-and-kibana-5-on-aws/"/>
    <updated>2017-09-16T17:24:32-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/09/16/nginx-reverse-proxy-for-elasticsearch-and-kibana-5-on-aws</id>
    <content type="html"><![CDATA[<p>As up untill today, there&rsquo;s currently no VPC Support for Amazon&rsquo;s Elasticsearch Service.</p>

<p>So for scenarios where you would like to allow private network traffic to Elasticsearch is impossible straight out of the box as Amazon&rsquo;s Elasticsearch Services, only sees Public Internet Traffic.</p>

<p>We will setup 2 configs, one for Kibana and one for Elasticsearch, each one having its own FQDN:</p>

<ul>
<li>Kibana: <code>http://kibana.domain.com</code></li>
<li>Elasticsearch: <code>http://elasticsearch.domain.com</code></li>
</ul>


<h2>Workaround:</h2>

<p>There&rsquo;s a couple of workarounds, which includes:</p>

<ul>
<li>Nginx Reverse Proxy</li>
<li>NAT Gateway</li>
<li>Allow IAM Users/Roles</li>
</ul>


<p>Today we will tackle the Nginx Reverse Proxy Route.</p>

<p>The benefit of this, would be to associate an EIP to the Nginx EC2 Instnace, then whitelist your EIP with Elasticsearch, so the only traffic that will be accepted will be the traffic that is coming from the Nginx Instance. We will also apply an additional layer of security, in this case we will use HTTP Basic Authentication, then also authorize network sources on a Security Group level.</p>

<h2>Installing Nginx:</h2>

<p>In this case I am using Ubuntu 16.04, so we will need to install <code>nginx</code> and <code>apache2-utils</code> for creating the Basic HTTP Auth accounts.</p>

<pre><code class="bash">$ apt update &amp;&amp; apt upgrade -y
$ apt install nginx apache2-utils -y
</code></pre>

<h2>Configure Nginx:</h2>

<p>Our main config: <code>/etc/nginx/nginx.conf</code>:</p>

<pre><code class="bash /etc/nginx/nginx.conf">user www-data;
worker_processes auto;
pid /run/nginx.pid;
error_log /var/log/nginx/error.log;

events {
    worker_connections 1024;
}

http {

    # Basic Settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    server_names_hash_bucket_size 128;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging Settings
        log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    # Gzip Settings
    gzip on;
    gzip_disable "msie6";

    # Elasticsearch and Kibana Configs
    include /etc/nginx/conf.d/elasticsearch.conf;
    include /etc/nginx/conf.d/kibana.conf;
}
</code></pre>

<p>Our <code>/etc/nginx/conf.d/elasticsearch.conf</code> configuration:</p>

<pre><code class="bash /etc/nginx/conf.d/elasticsearch.conf">server {

  listen 80;
  server_name elasticsearch.domain.com;

  # error logging
  error_log /var/log/nginx/elasticsearch_error.log;

  # authentication: elasticsearch
  auth_basic "Elasticsearch Auth";
  auth_basic_user_file /etc/nginx/.secrets_elasticsearch;

  location / {

    proxy_http_version 1.1;
    proxy_set_header Host https://search-elasticsearch-name.eu-west-1.es.amazonaws.com;
    proxy_set_header X-Real-IP &lt;ELASTIC-IP&gt;;
    proxy_set_header Connection "Keep-Alive";
    proxy_set_header Proxy-Connection "Keep-Alive";
    proxy_set_header Authorization "";

    proxy_pass https://search-elasticsearch-name.eu-west-1.es.amazonaws.com/;
    proxy_redirect https://search-elasticsearch-name.eu-west-1.es.amazonaws.com/ http://&lt;ELASTIC-IP&gt;/;

  }

  # ELB Health Checks
  location /status {
    root /usr/share/nginx/html/;
  }

}
</code></pre>

<p>Our <code>/etc/nginx/conf.d/kibana.conf</code> configuration:</p>

<pre><code class="bash /etc/nginx/conf.d/kibana.conf">server {

  listen 80;
  server_name kibana.domain.com;

  # error logging
  error_log /var/log/nginx/kibana_error.log;

  # authentication: kibana
  auth_basic "Kibana Auth";
  auth_basic_user_file /etc/nginx/.secrets_kibana;

  location / {

    proxy_http_version 1.1;
    proxy_set_header Host https://search.elasticsearch-name.eu-west-1.es.amazonaws.com;
    proxy_set_header X-Real-IP &lt;ELASTIC-IP&gt;;
    proxy_set_header Connection "Keep-Alive";
    proxy_set_header Proxy-Connection "Keep-Alive";
    proxy_set_header Authorization "";

    proxy_pass https://search.elasticsearch-name.eu-west-1.es.amazonaws.com/_plugin/kibana/;
    proxy_redirect https://search.elasticsearch-name.eu-west-1.es.amazonaws.com/_plugin/kibana/ http://&lt;ELASTIC-IP&gt;/kibana/;

  }

      location ~ (/app/kibana|/app/timelion|/bundles|/es_admin|/plugins|/api|/ui|/elasticsearch) {
         proxy_pass              https://search.elasticsearch-name.eu-west-1.es.amazonaws.com;
         proxy_set_header        Host $host;
         proxy_set_header        X-Real-IP $remote_addr;
         proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
         proxy_set_header        X-Forwarded-Proto $scheme;
         proxy_set_header        X-Forwarded-Host $http_host;
         proxy_set_header    Authorization  "";
    }
}
</code></pre>

<p>Once you have replaced the elasticsearch endpoint and your EPI values, we can go ahead and create the auth accounts.</p>

<h2>Create User Accounts for HTTP Basic Auth</h2>

<p>Create the 2 accounts for authentication on kibana and elasticsearch:</p>

<pre><code class="bash">$ htpasswd -c /etc/nginx/.secrets_elasticsearch elasticsearch-admin
$ htpasswd -c /etc/nginx/.secrets_kibana kibana-admin
</code></pre>

<h2>Restart Nginx:</h2>

<p>Restart and enable Nginx on boot:</p>

<pre><code class="bash">$ systemctl enable nginx
$ systemctl restart nginx
</code></pre>

<p>Once your Nginx Service is running, you should be able to access Kibana and Elasticsearch using the credentials that you created.</p>

<h2>Resources:</h2>

<ul>
<li><a href="https://www.nginx.com/blog/tcp-load-balancing-udp-load-balancing-nginx-tips-tricks/">https://www.nginx.com/blog/tcp-load-balancing-udp-load-balancing-nginx-tips-tricks/</a></li>
<li><a href="https://www.elastic.co/blog/playing-http-tricks-nginx">https://www.elastic.co/blog/playing-http-tricks-nginx</a></li>
<li><a href="https://sysadmins.co.za/aws-access-kibana-5-behind-elb-via-nginx-reverse-proxy-on-custom-dns/">https://sysadmins.co.za/aws-access-kibana-5-behind-elb-via-nginx-reverse-proxy-on-custom-dns/</a></li>
</ul>


<center>
<script type='text/javascript' src='https://ko-fi.com/widgets/widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Buy Me a Coffee', '#46b798', 'A6423ZIQ');kofiwidget2.draw();</script> 
</center>

]]></content>
  </entry>
  
</feed>
