<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Security | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/security/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2018-08-29T15:46:34-04:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Review and Secure Your Facebook Account]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/08/29/review-and-secure-your-facebook-account/"/>
    <updated>2018-08-29T15:03:10-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/08/29/review-and-secure-your-facebook-account</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/fb-security-logo.png" alt="" /></p>

<p>This post is a bit different from my other posts, but I feel it&rsquo;s a important one: Facebook Security.</p>

<p>Facebook, everyone loves it right? Yeah, but what happens when you get locked out of your account, or an attacker gains access to your account and start doing things that you dont want to, and especially all the photos / messages that needs to remain private, can potentially end up in the wrong hands.</p>

<p>Facebook usually detects strange behavior, but being able to be pro-active on security on this can help a lot.</p>

<p>There&rsquo;s a couple of ways how attackers can gain access to your account, but I won&rsquo;t go into that, google will be your friend if you are curious how they do it.</p>

<h2>Scenario: Something suspicious is up / weird behavior / getting unusual messages from groups etc</h2>

<p>Usually Facebook will detect this, but if not you can and should do the following:</p>

<ul>
<li>Reset your password</li>
<li>Enable Two-Factor Authentication</li>
<li>Terminate or Logout all sessions from your account, if you find unknown sessions, report it to facebook and log them out.</li>
<li>Review your account&rsquo;s activity</li>
<li>Review Group Activity, if you are subscribed to groups, unsubscribe</li>
<li>Reach out to facebook support</li>
</ul>


<h2>Head over to your Facebook Accounts Settings Page:</h2>

<p>Head over to <a href="https://www.facebook.com/settings">https://www.facebook.com/settings</a> , this will be the main view where you are able to configure/review your account. It should look like this:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-1.png" alt="" /></p>

<p>When you select the &ldquo;Security and Login&rdquo; tab: <a href="https://www.facebook.com/settings?tab=security">https://www.facebook.com/settings?tab=security</a> , you will be presented with a couple of login options:</p>

<h2>Security and Login Info:</h2>

<p>The list of your devices that is currently logged on:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-2.png" alt="" /></p>

<p>Hit the <code>See More</code> dropdown to review all your devices, which is currently logged onto Facebook, if you are not aware of the sessions, hit the <code>Log Out</code> button to terminate that session, or select <code>Not You</code> if you are not aware of that session, then continue to report the activity to Facebook, so that they can look into it.</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-3.png" alt="" /></p>

<p>You can follow up on your incident via <a href="https://www.facebook.com/support/">https://www.facebook.com/support/</a> .</p>

<h2>Password and Two Factor Authentication:</h2>

<p>This is actually the first thing that I would do, is to change your password. If someone did manage to gain access to your password and you are still logged on, change it immediately. If they reset your password before you do, game over. Well kind of..</p>

<p>From the same page, change your password:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-4.png" alt="" /></p>

<p>Enable <code>"Two-Factor Authentication"</code>, when you are logged out, or trying to logon from a new device, a notification will be sent to your device where Facebook is installed, or alternatively, you will receive a code sent to you which you will need to enter after you have logged on, just to provide you with a extra layer of security.</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-5.png" alt="" /></p>

<p>Enable <code>"Get alerts about unrecognized logins"</code>, which allows you to set up to 5 friends that can help you unlock your account, if your account has been locked out.</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-6.png" alt="" /></p>

<h2>Review your Activity Log</h2>

<p>From <a href="https://www.facebook.com/settings?tab=your_facebook_information">https://www.facebook.com/settings?tab=your_facebook_information</a> , head over to <code>"Activity Log"</code>:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-7.png" alt="" /></p>

<p>Select <code>"Activity Log"</code>, to review your recent activity:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-8.png" alt="" /></p>

<p>Below <code>Comments</code>, select <code>more</code>, then <code>Security and Login Information</code>:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-9.png" alt="" /></p>

<p>Then we will be presented with the <code>Active Sessions</code>, <code>Login and Logouts</code> and <code>Recognized Devices</code>.</p>

<p>First look at <code>Active Sessions</code>:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-10.png" alt="" /></p>

<p>Then <code>Logins and Logouts</code>:</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-11.png" alt="" /></p>

<p>From this same page you can review other activity like <code>Search History</code>, <code>Groups</code>. etc.</p>

<p><img src="https://objects.ruanbekker.com/assets/images/fb-12.png" alt="" /></p>

<p>If someone had to access/subscribed to groups, you will be able to review the activity, within 3 different views:</p>

<ul>
<li>Groups: any interaction with groups, such as likes, comments etc.</li>
<li>Membership Activity: Any group memberships</li>
<li>Posts and Comments: Self explanatory.</li>
</ul>


<h2>Final Note:</h2>

<p>People try to access accounts all the time, watch out for the following:</p>

<ul>
<li>Friend Requests: people have a lot of private information on facebook, keep it private</li>
<li>Watch out for strange applications that wants your permission, review the permission levels closely</li>
<li>Reset your password time to time, use unique passwords, and not the same password as the password that your main email account is associated with</li>
<li>Watch out for links, some of them can end you up in a bad spot.</li>
<li>When you see weird activity from your friends account, report it, so that facebook can investigate it. It happened to a friend and Facebook sorted it out within 20 minutes.</li>
</ul>


<h2>Resources:</h2>

<ul>
<li><a href="https://www.facebook.com/security/">https://www.facebook.com/security/</a></li>
<li><a href="https://www.facebook.com/support">https://www.facebook.com/support</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distributing a Shared Secret Amongst a Group of Participants Using Shamirs Secret Sharing Scheme Aka Ssss]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/08/27/distributing-a-shared-secret-amongst-a-group-of-participants-using-shamirs-secret-sharing-scheme-aka-ssss/"/>
    <updated>2018-08-27T18:29:48-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/08/27/distributing-a-shared-secret-amongst-a-group-of-participants-using-shamirs-secret-sharing-scheme-aka-ssss</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/cryptography-word-logo.png" alt="" /></p>

<p>In situations where a group of participants join together to split up a secret in a form of secret sharing, where the secret is devided into parts, giving each participant their own unique part. Together contributing to reconstruct the initial secret. We can achieve this with Shamir&rsquo;s Secret Sharing which is an algorithm in cryptography created by <a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">Adi Shamir</a>.</p>

<h2>More info on Secret Sharing</h2>

<p>Referenced from <a href="https://en.wikipedia.org/wiki/Secret_sharing">Wikipedia: Secret Sharing</a>:</p>

<p>&ldquo;Secret sharing (also called secret splitting) refers to methods for distributing a secret amongst a group of participants, each of whom is allocated a share of the secret. The secret can be reconstructed only when a sufficient number, of possibly different types, of shares are combined together; individual shares are of no use on their own.&rdquo;</p>

<h2>Installing ssss</h2>

<p>On Mac OSX:</p>

<pre><code>$ brew install ssss
</code></pre>

<p>On Debian:</p>

<pre><code>$ apt install ssss -y
</code></pre>

<h2>Creating a Secret:</h2>

<p>Generate a Secret where we will distribute 5 shares, where each participant will have their own unique share, and to reconstruct the secret, we will need 3 participants to rebuild the secret. In our case our shares will be distributed to the following example users:</p>

<pre><code>- Share 1: James
- Share 2: John
- Share 3: Frank
- Share 4: Paul
- Share 5: Ryan
</code></pre>

<p>For this demonstration our secret&rsquo;s value will be <code>SuperSecret@123!</code>, which we will split into 5 shares, but to reconstruct, we need 3 parts / shares:</p>

<pre><code class="bash">$ ssss-split -t 3 -n 5
Generating shares using a (3,5) scheme with dynamic security level.
Enter the secret, at most 128 ASCII characters: Using a 128 bit security level.
1-41ac84013bf568d1cc88b751539f1ff5
2-7d9ca3ca26442bfcca35e0ad205e5659
3-519038837bbf1b7ceefde331ad1ae40f
4-6d4f4e0f086af5be033f516bb3e227d2
5-4143d5465591c53e27f752f73ea69596
</code></pre>

<p>In this case, each share will be distributed to each user to save in a secure location.</p>

<h2>Reconstructing the Secret:</h2>

<p>Let&rsquo;s reconstruct the secret, and as we need 3 participants, we will ask <code>John</code>, <code>Paul</code> and <code>Ryan</code> for their shares, so that we can reconstruct the secret:</p>

<pre><code class="bash">$ ssss-combine -t 3
Enter 3 shares separated by newlines:
Share [1/3]: 2-7d9ca3ca26442bfcca35e0ad205e5659
Share [2/3]: 4-6d4f4e0f086af5be033f516bb3e227d2
Share [3/3]: 5-4143d5465591c53e27f752f73ea69596
Resulting secret: SuperSecret@123!
</code></pre>

<p>As you can see the secret is verified the same as the initial secret.</p>

<h2>Using ssss and qrencode for MFA Codes</h2>

<p>This can be useful for Multi Factor Authentication as well. Setup a Virtual MFA with a Identity that supports MFA Authentication, copy or make note of the &ldquo;Secret Key / Secret Configuration Key&rdquo;, go ahead and setup the MFA Device on your MFA Device to complete the setup.</p>

<p>Once verified and able to logon, logout and delete the MFA Account from your Device.</p>

<p>Generate the same share scheme for the MFA Secret Key, for this example: <code>ABCDEXAMPLE1029384756</code>:</p>

<pre><code class="bash">$ ssss-split -t 3 -n 5
Generating shares using a (3,5) scheme with dynamic security level.
Enter the secret, at most 128 ASCII characters: Using a 168 bit security level.
1-8d2cf979fb346297cab47ff691bddc1c5a5f34af37
2-4d0f2cdcfff653cc60a4f293c15805f7e84b0a956d
3-dadb6d2cbe42772c9a9042273f0b71dd71422f19cb
4-546bcef428151ceb01fdc6007ac2e5e4f1516670ca
5-c3bf8f0469a1380bfbc976b4849191ce685843fc7e
</code></pre>

<p>Distribute the Shares, and when the MFA Device needs to be restored on a Device, reconstruct the secret to get the Secret Key for the MFA Device:</p>

<pre><code class="bash">$ ssss-combine -t 3
Enter 3 shares separated by newlines:
Share [1/3]: 1-8d2cf979fb346297cab47ff691bddc1c5a5f34af37
Share [2/3]: 2-4d0f2cdcfff653cc60a4f293c15805f7e84b0a956d
Share [3/3]: 3-dadb6d2cbe42772c9a9042273f0b71dd71422f19cb
Resulting secret: ABCDEXAMPLE1029384756
</code></pre>

<p>Now that we have the Secret Key for our MFA Device, let&rsquo;s Generate a QRCode that we can scan in from our device, which will save us from typing a lot of characters. We will need <code>qrencode</code> for this:</p>

<p>For Mac OSX:</p>

<pre><code>$ brew install qrencode
</code></pre>

<p>for Debian:</p>

<pre><code class="bash">$ apt install qrencode -y
</code></pre>

<p>To generate the QRCode, we will pass the filename: <code>myqrcode.png</code>, the name that will appear on our device: <code>MyNewMFADevice</code>, and the Secret: <code>ABCDEXAMPLE1029384756</code>:</p>

<pre><code>$ qrencode -o myqrcode.png -d 300 -s 10 "otpauth://totp/MyNewMFADevice?secret=ABCDEXAMPLE1029384756"
</code></pre>

<p>You will find the <code>myqrcode.png</code> in your current working directory, open the file scan the barcode and your MFA device will be setup and enabled to use.</p>

<h2>Resources:</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Secret_sharing">https://en.wikipedia.org/wiki/Secret_sharing</a></li>
<li><a href="http://point-at-infinity.org/ssss/">http://point-at-infinity.org/ssss/</a></li>
<li><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_enable_virtual.html#enable-virt-mfa-for-iam-user">https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_enable_virtual.html#enable-virt-mfa-for-iam-user</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using IAM Authentication With Amazon Elasticsearch Service]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/08/20/using-iam-authentication-with-amazon-elasticsearch-service/"/>
    <updated>2018-08-20T04:12:21-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/08/20/using-iam-authentication-with-amazon-elasticsearch-service</id>
    <content type="html"><![CDATA[<p><img src="https://objects.ruanbekker.com/assets/images/aws-logo.png" alt="" /></p>

<p>Today I will demonstrate how to allow access to Amazons Elasticsearch Service using IAM Authenticationi using AWS Signature Version4.</p>

<h2>Elasticsearch Service Authentication Support:</h2>

<p>When it comes to security, Amazons Elasticsearch Service supports three types of access policies:</p>

<ul>
<li>Resource Based</li>
<li>Identity Based</li>
<li>IP Access Based</li>
</ul>


<p>More information on this can be found below:
- <a href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-ac.html">https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-ac.html</a></p>

<h2>Securing your Amazon Elasticsearch Search Domain:</h2>

<p>To secure your domain with IAM Based Authentication, the following steps will be neeed:</p>

<ul>
<li>Create IAM Policy to be associated with a IAM User or Role</li>
<li>On Elasticsearch Access Policy, associate the ARN to the Resource</li>
<li>Use the AWS4Auth package to sign the requests as AWS supports Signature Version 4</li>
</ul>


<pre><code class="json">{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "es:*"
            ],
            "Resource": "arn:aws:es:eu-west-1:&lt;ACCOUNT-ID&gt;:domain/&lt;ES-DOMAIN&gt;"
        }
    ]
}
</code></pre>

<p>Create the IAM Role with EC2 Identity Provider as a Trusted Relationship eg. es-role and associate the IAM Policy es-policy to the role.</p>

<p>Create/Moodify the Elasticsearch Access Policy, in this example we will be using a combination of IAM Role, IAM User and IP Based access:</p>

<ul>
<li>IAM Role for EC2 Role Based Services</li>
<li>IAM User for User/System Account</li>
<li>IP Based for cients that needs to be whitelisted via IP (ip-based just for demonstration, as the tests will be used only for IAM)</li>
</ul>


<pre><code class="json">{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": [
          "arn:aws:iam::&lt;ACCOUNT-ID&gt;:role/&lt;IAM-ROLE-NAME&gt;",
          "arn:aws:iam::&lt;ACCOUNT-ID&gt;:user/&lt;IAM-USER-NAME&gt;"
        ]
      },
      "Action": "es:*",
      "Resource": "arn:aws:es:eu-west-1:&lt;ACCOUNT-ID&gt;:domain/&lt;ES-DOMAIN&gt;/*"
    },
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "*"
      },
      "Action": "es:*",
      "Resource": "arn:aws:es:eu-west-1:&lt;ACCOUNT-ID&gt;:domain/&lt;ES-DOMAIN&gt;/*",
      "Condition": {
        "IpAddress": {
          "aws:SourceIp": [
            "x.x.x.x",
            "x.x.x.x"
          ]
        }
      }
    }
  ]
}
</code></pre>

<p>After the Access Policy has been updated, the Elasticsearch Domain Status will show <code>Active</code></p>

<h2>Testing from EC2 using IAM Instance Profile:</h2>

<p>Launch a EC2 Instance with the IAM Role eg. es-role, then using Python, we will make a request to our Elasticsearch Domain using boto3, aws4auth and the native elasticsearch client for python via our IAM Role, which we will get the temporary credentials from boto3.Session.</p>

<p>Installing the dependencies:</p>

<pre><code class="bash">$ pip install virtualenv
$ virtualenv .venv
$ source .venv/bin/activate
$ pip install boto3 elasticsearch requests_aws4auth
</code></pre>

<p>Our code:</p>

<pre><code class="python">import boto3, json
from elasticsearch import Elasticsearch, RequestsHttpConnection
from requests_aws4auth import AWS4Auth

my_region = 'eu-west-1'
my_service = 'es'
my_eshost = 'search-replaceme.eu-west-1.es.amazonaws.com'

session = boto3.Session(region_name=my_region) # thanks Leon
credentials = session.get_credentials()
credentials = credentials.get_frozen_credentials()
access_key = credentials.access_key
secret_key = credentials.secret_key
token = credentials.token

aws_auth = AWS4Auth(
    access_key,
    secret_key,
    my_region,
    my_service,
    session_token=token
)

es = Elasticsearch(
    hosts = [{'host': my_eshost, 'port': 443}],
    http_auth=aws_auth,
    use_ssl=True,
    verify_certs=True,
    connection_class=RequestsHttpConnection
)

print(json.dumps(es.info(), indent=2))
</code></pre>

<p>Running our piece of code, will result in this:</p>

<pre><code class="bash">$ python get-info-from-role.py
{
  "cluster_name": "&lt;ACCOUNT-ID&gt;:&lt;ES-DOMAIN&gt;",
  "cluster_uuid": "sLUnqFSsQdCMlBLrn7BTUA",
  "version": {
    "lucene_version": "6.6.0",
    "build_hash": "Unknown",
    "build_snapshot": false,
    "number": "5.5.2",
    "build_date": "2017-10-18T04:35:01.381Z"
  },
  "name": "KXSwBvT",
  "tagline": "You Know, for Search"
}
</code></pre>

<h2>Testing using IAM Credentials from Credentials Provider:</h2>

<p>Configure your credentials provider:</p>

<pre><code class="bash">$ pip install awscli
$ aws configure --profile ruan
AWS Access Key ID [None]: xxxxxxxxx
AWS Secret Access Key [None]: xxxxxx
Default region name [None]: eu-west-1
Default output format [None]: json
</code></pre>

<p>Using Python, we will get the credentials from the Credential Provider, using our profile name:</p>

<pre><code class="python">import boto3, json
from elasticsearch import Elasticsearch, RequestsHttpConnection
from requests_aws4auth import AWS4Auth

my_service = 'es'
my_region = 'eu-west-1'
my_eshost = 'search-replaceme.eu-west-1.es.amazonaws.com'

session = boto3.Session(
    region_name=my_region,
    profile_name='ruan'
)

credentials = session.get_credentials()
access_key = credentials.access_key
secret_key = credentials.secret_key

aws_auth = AWS4Auth(
    access_key,
    secret_key,
    my_region,
    my_service
)

es = Elasticsearch(
    hosts = [{'host': my_eshost, 'port': 443}],
    http_auth=aws_auth,
    use_ssl=True,
    verify_certs=True,
    connection_class=RequestsHttpConnection
)

print(json.dumps(es.info(), indent=2))
</code></pre>

<p>Running it will result in:</p>

<pre><code class="bash">$ python get-info-from-user.py
{
  "cluster_name": "&lt;ACCOUNT-ID&gt;:&lt;ES-DOMAIN&gt;",
  "cluster_uuid": "sLUnqFSsQdCMlBLrn7BTUA",
  "version": {
    "lucene_version": "6.6.0",
    "build_hash": "Unknown",
    "build_snapshot": false,
    "number": "5.5.2",
    "build_date": "2017-10-18T04:37:21.381Z"
  },
  "name": "KXSwBvT",
  "tagline": "You Know, for Search"
}
</code></pre>

<p>For more blog posts on Elasticsearch have a look at:
- <a href="http://blog.ruanbekker.com/blog/categories/elasticsearch">blog.ruanbekker.com:elasticsearch</a>
- <a href="https://sysadmins.co.za/tags/elasticsearch">sysadmins.co.za:elasticsearch</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add a Authentication Header to Your Python Flask App]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/06/01/add-a-authentication-header-to-your-python-flask-app/"/>
    <updated>2018-06-01T03:28:05-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/06/01/add-a-authentication-header-to-your-python-flask-app</id>
    <content type="html"><![CDATA[<p><img src="http://obj-cache.cloud.ruanbekker.com/flask.png" alt="" /></p>

<p>We will write a simple Python Flask application that requires authentication in order to respond with a 200 HTTP Status code.</p>

<h2>Python Flask Application:</h2>

<p>Our Python Flask application will require the Header <code>x-api-key dhuejso2dj3d0</code> in the HTTP Request, to give us a 200 HTTP Status code, if not, we will respond with a 401 Unauthorized Response:</p>

<pre><code class="python">from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/')
def index():
    headers = request.headers
    auth = headers.get("X-Api-Key")
    if auth == 'asoidewfoef':
        return jsonify({"message": "OK: Authorized"}), 200
    else:
        return jsonify({"message": "ERROR: Unauthorized"}), 401

if __name__ == '__main__':
    app.run()
</code></pre>

<p>To get the headers, you can use <code>headers.get("X-Api-Key")</code> or <code>headers["X-Api-Key"]</code></p>

<p>Create a virtual environment, install flask and run the app:</p>

<pre><code class="bash">$ virtualenv .venv
$ source .venv/bin/activate
$ python app.py
 * Serving Flask app "app" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
</code></pre>

<h2>Requests to our App:</h2>

<p>Let&rsquo;s first make a request with no headers, which should then give us a 401 Unautorhized response:</p>

<pre><code class="bash">$ curl -i http://localhost:5000

HTTP/1.0 401 UNAUTHORIZED
Content-Type: application/json
Content-Length: 33
Server: Werkzeug/0.14.1 Python/3.6.5
Date: Fri, 01 Jun 2018 07:26:25 GMT

{"message":"ERROR: Unauthorized"}
</code></pre>

<p>Now let&rsquo;s include the authentication token in our headers. If the string is the same as the one in the code, we should see a 200 HTTP Response:</p>

<pre><code class="bash">$ curl -i -H 'x-api-key: asoidewfoef' http://localhost:5000

HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 29
Server: Werkzeug/0.14.1 Python/3.6.5
Date: Fri, 01 Jun 2018 07:27:03 GMT

{"message":"OK: Authorized"}
</code></pre>

<h2>Note:</h2>

<p>From a best practice, its not a good decision to hard code sensitive details in your code, but rather read that from an encrypted database and store that in your applications environment variables, and let your application read from the environment variables, something like that :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Temporary IAM Credentials From EC2 Instance Metadata Using Python]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/05/09/temporary-iam-credentials-from-ec2-instance-metadata-using-python/"/>
    <updated>2018-05-09T12:14:11-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/05/09/temporary-iam-credentials-from-ec2-instance-metadata-using-python</id>
    <content type="html"><![CDATA[<p>From a Best Practice Perspective its good not having to pass sensitive information around, and especially not hard coding them.</p>

<h2>Best Practice: Security</h2>

<p>One good way is to use SSM with KMS to Encrypt/Decrypt them, but since EC2 has a <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html">Metadata Service</a> available, we can make use of that to retrieve <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html">temporary credentials</a>. One requirement though, is that the instance will require an IAM Role where the code will be executed on. The IAM Role also needs to have sufficient privileges to be able to execute, whatever you need to do.</p>

<p>The <a href="https://12factor.net/">12 Factor</a> Methodology however states to use config in your environment variables, but from the application logic, its easy to save it in our environment.</p>

<h2>Scenario: Applications on AWS EC2</h2>

<p>When you run applications on Amazon EC2 the nodes has access to the EC2 Metadata Service, so in this case our IAM Role has a Policy that authorizes GetItem on our DynamoDB table, therefore we can define our code with no sensitive information, as the code will do all the work to get the credentials and use the credentials to access DynamoDB.</p>

<h2>Use Temporary Credentials to Read from DynamoDB using botocore</h2>

<p>In this example we will get the temporary credentials from the metadata service, then define the temporary credentials in our session to authorize our request against dynamodb to read from our table:</p>

<pre><code class="python">&gt;&gt;&gt; import boto3
&gt;&gt;&gt; from botocore.utils import InstanceMetadataFetcher
&gt;&gt;&gt; from botocore.credentials import InstanceMetadataProvider
&gt;&gt;&gt; provider = InstanceMetadataProvider(iam_role_fetcher=InstanceMetadataFetcher(timeout=1000, num_attempts=2))
&gt;&gt;&gt; creds = provider.load()

&gt;&gt;&gt; session = boto3.Session(
    aws_access_key_id=creds.access_key,
    aws_secret_access_key=creds.secret_key,
    aws_session_token=creds.token
)

&gt;&gt;&gt; ddb = session.client('dynamodb')

&gt;&gt;&gt; response = ddb.get_item(
    TableName='my-dynamodb-table',
    Key={
        'node_type': {
            'S': 'primary_manager'
        }
    }
)

&gt;&gt;&gt; print(response['Item']['ip']['S'])
'10.0.0.32
</code></pre>

<p>Also, when you are logged onto the EC2 instance, you can use curl to see the temporary credentials information:</p>

<pre><code class="bash">$ iam_role_name=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/)
$ curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/${iam_role_name}
{
  "Code" : "Success",
  "LastUpdated" : "2018-05-09T14:25:48Z",
  "Type" : "AWS-HMAC",
  "AccessKeyId" : "",
  "SecretAccessKey" : "",
  "Token" : "",
  "Expiration" : "2018-05-09T20:46:55Z"
}
</code></pre>

<h2>Another method is boto3 Session:</h2>

<p>You can also use boto3.Session to achieve this:</p>

<pre><code class="bash">&gt;&gt;&gt; session = boto3.Session(region_name='eu-west-1')
&gt;&gt;&gt; credentials = session.get_credentials()
&gt;&gt;&gt; credentials = credentials.get_frozen_credentials()
&gt;&gt;&gt; credentials.access_key
u'ABC...'
&gt;&gt;&gt; credentials.secret_key
u'DEF...'
&gt;&gt;&gt; credentials.token
u'ZXC...'
&gt;&gt;&gt; access_key = credentials.access_key
&gt;&gt;&gt; secret_key = credentials.secret_key
&gt;&gt;&gt; ddb = session.client('dynamodb')
</code></pre>
]]></content>
  </entry>
  
</feed>
