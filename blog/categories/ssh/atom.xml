<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ssh | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/ssh/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2018-05-29T10:13:17-04:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Forwarding the Docker Socket via a SSH Tunnel to Execute Docker Commands Locally]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/04/30/forwarding-the-docker-socket-via-a-ssh-tunnel-to-execute-docker-commands-locally/"/>
    <updated>2018-04-30T08:30:23-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/04/30/forwarding-the-docker-socket-via-a-ssh-tunnel-to-execute-docker-commands-locally</id>
    <content type="html"><![CDATA[<p>With automation in mind, when you want to execute docker commands remotely, you want to do it in a secure manner, as you don&rsquo;t want to expose your Docker port to the whole world.</p>

<p>One way in doing that, is forwarding the remote docker socket via a local port over a SSH Tunnel. With this way, you can execute docker commands locally on your workstation, as if the swarm is running on your workstation/laptop/node/bastion host etc.</p>

<p>Without the tunnel, I have a swarm on my laptop with no running services:</p>

<pre><code class="bash">$ docker service ls
ID                  NAME                   MODE                REPLICAS            IMAGE                                                               PORTS
</code></pre>

<p>As you can see, we have no services running, but the remote swarm has a couple, so after forwarding the connection, we should see our remote services.</p>

<h2>Setting up the SSH Tunnel:</h2>

<p>Here we will forward the remote docker socket: <code>/var/run/docker.sock</code> to a local port bound to localhost: <code>localhost:2377</code>:</p>

<pre><code class="bash">$ screen -S docker
$ ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -i ~/path/to/key.pem -NL localhost:2377:/var/run/docker.sock root@docker-managers.mydomain.com
</code></pre>

<p>Now the SSH Tunnel will be established, and you can detach your screen session, or open a new shell session. To detach your screen session: <code>'ctrl + a' then d</code></p>

<h2>Verifying that the tunnel is established:</h2>

<p>You can use netstat to verify that the port is listening:</p>

<pre><code class="bash">$ netstat -ant | grep 2377
tcp4       0      0  127.0.0.1.2377         *.*                    LISTEN
</code></pre>

<h2>Inform the Docker Client to use the Port:</h2>

<p>Now we need to inform the docker client, to use the new port to talk to the docker daemon. We do that by setting the <code>DOCKER_HOST</code> environment variable to point to <code>localhost:2377</code>:</p>

<pre><code class="bash">$ export DOCKER_HOST="localhost:2377"
</code></pre>

<p>This will remain for the lifetime of the shell session.</p>

<h2>Testing it Out:</h2>

<p>Now we can run our commands locally, and we should see the output of our remote swarm:</p>

<pre><code class="bash">$ docker service ls
ID                  NAME                   MODE                REPLICAS            IMAGE                                                               PORTS
xjta8e3ek2u2        apps_flask_reminders   replicated          3/3                 rbekker87/flask-reminders:debian
0l7ruktbqj99        apps_kibana            replicated          1/1                 kibana:latest
...
</code></pre>

<h2>Terminating our SSH Tunnel:</h2>

<p>To terminate our SSH Tunnel, reconnect to your shell session, and hit <code>ctrl + c</code>:</p>

<pre><code class="bash">$ screen -ls 
There is a screen on:
    50413.docker    (Detached)
$ screen -r 50413
</code></pre>

<p>Hit <code>ctrl + c</code> :</p>

<pre><code class="bash">CKilled by signal 2.
</code></pre>

<p>And exit the screen session:</p>

<pre><code class="bash">$ exit
</code></pre>

<p>With this way, you can do lots of automation with docker swarm, not limited to swarm, but one of them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Paramiko Module in Python to Execute Remote Bash Commands]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/04/23/using-paramiko-module-in-python-to-execute-remote-bash-commands/"/>
    <updated>2018-04-23T12:16:59-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/04/23/using-paramiko-module-in-python-to-execute-remote-bash-commands</id>
    <content type="html"><![CDATA[<p>Paramiko is a python implementation of the sshv2 protocol.</p>

<h2>Paramiko to execute Remote Commands:</h2>

<p>We will use paramiko module in python to execute a command on our remote server.</p>

<p>Client side will be referenced as (side-a) and Server side will be referenced as (side-b)</p>

<h2>Getting the Dependencies:</h2>

<p>Install Paramiko via pip on side-a:</p>

<pre><code class="bash">$ pip install paramiko --user
</code></pre>

<h2>Using Paramiko in our Code:</h2>

<p>Our Python Code:</p>

<pre><code class="python">import paramiko

ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect(hostname='192.168.10.10', username='ubuntu', key_filename='/home/ubuntu/.ssh/mykey.pem')

stdin, stdout, stderr = ssh.exec_command('lsb_release -a')

for line in stdout.read().splitlines():
    print(line)

ssh.close()
</code></pre>

<h2>Execute our Command Remotely:</h2>

<p>Now we will attempt to establish the ssh connection from side-a, then run <code>lsb_release -a</code> on our remote server, side-b:</p>

<pre><code class="bash">$ python execute.py

Distributor ID: Ubuntu
Description:    Ubuntu 16.04.4 LTS
Release:    16.04
Codename:   xenial
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a SSH Tunnel With the Sshtunnel Module in Python]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/04/23/setup-a-ssh-tunnel-with-the-sshtunnel-module-in-python/"/>
    <updated>2018-04-23T11:56:46-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/04/23/setup-a-ssh-tunnel-with-the-sshtunnel-module-in-python</id>
    <content type="html"><![CDATA[<p>Sometimes we need to restrict access to a port, where a port should listen on localhost, but you want to access that port from a remote source. One secure way of doing that, is to establish a SSH Tunnel to the remote side, and forward to port via the SSH Tunnel.</p>

<p>Today we will setup a Flask Web Service on our Remote Server (Side B) which will be listening on <code>127.0.0.1:5000</code> and setup the SSH Tunnel with the <code>sshtunnel</code> module in Python from our client side (Side A). Then we will make a GET request on our client side to the port that we are forwarding via the tunnel to our remote side.</p>

<h2>Remote Side:</h2>

<p>Our Demo Python Flask Application:</p>

<pre><code class="python">from flask import Flask

app = Flask(__name__)

@app.route('/')
def index():
    return 'OK'

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=5000)
</code></pre>

<p>Run the server:</p>

<pre><code class="bash">$ python app.py
Listening on 127.0.0.1:5000
</code></pre>

<h2>Client Side:</h2>

<p>From our client side we first need to install sshtunnel via pip:</p>

<pre><code class="bash">$ pip install sshtunnel requests --user
</code></pre>

<p>Our code for our client that will establish the tunnel and do the GET request:</p>

<pre><code class="python">from sshtunnel import SSHTunnelForwarder
import requests

remote_user = 'ubuntu'
remote_host = '192.168.10.10'
remote_port = 22
local_host = '127.0.0.1'
local_port = 5000

server = SSHTunnelForwarder(
   (remote_host, remote_port),
   ssh_username=remote_user,
   ssh_private_key='/home/ubuntu/.ssh/mykey.pem',
   remote_bind_address=(local_host, local_port),
   local_bind_address=(local_host, local_port),
   )

server.start()

headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.0; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0'}
r = requests.get('http://127.0.0.1:5000', headers=headers).content
print(r)
server.stop()
</code></pre>

<p>Running our app:</p>

<pre><code class="bash">$ python ssh_tunnel.py
OK
</code></pre>

<p>So we have sucessfully established our ssh tunnel to our remote side, and able to access the network restricted port via the tunnel.</p>

<h2>Resources:</h2>

<ul>
<li><a href="https://pypi.org/project/sshtunnel/">SSHTunnel</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH Host Key Warnings With Strict Checking Enabled]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/12/13/ssh-host-key-warnings-with-strict-checking-enabled/"/>
    <updated>2017-12-13T02:07:29-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/12/13/ssh-host-key-warnings-with-strict-checking-enabled</id>
    <content type="html"><![CDATA[<p>When you format / reload a server and the host gets the same IP, when you try to SSH to that host, you might get a warning like this:</p>

<pre><code class="bash">$ ssh 192.168.1.104
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
a1:a2:a3:a4:a5:a6:a7:a8:a9:b0:b1:b2:b3:b4:b5:b6.
Please contact your system administrator.
Add correct host key in /home/pi/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/pi/.ssh/known_hosts:10
ECDSA host key for 192.168.1.104 has changed and you have requested strict checking.
Host key verification failed.
</code></pre>

<p>This is because we have <code>StrictMode</code> enabled in our SSH Configuration:</p>

<pre><code class="bash">$ cat /etc/ssh/sshd_config | grep -i stric
StrictModes yes
</code></pre>

<p>To remove the offending key from your <code>known_hosts</code> file, without opening it, you can use <code>ssh-keygen</code> to remove it:</p>

<pre><code class="bash">$ ssh-keygen -f .ssh/known_hosts -R 192.168.1.104
# Host 192.168.1.104 found: line 10 type ECDSA
.ssh/known_hosts updated.
Original contents retained as .ssh/known_hosts.old
</code></pre>

<p>Now when you SSH the warning should be removed.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Routing Web Traffic With a SOCKS Tunnel]]></title>
    <link href="http://blog.ruanbekker.com/blog/2017/11/14/routing-web-traffic-with-a-socks-tunnel/"/>
    <updated>2017-11-14T10:17:07-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2017/11/14/routing-web-traffic-with-a-socks-tunnel</id>
    <content type="html"><![CDATA[<p>I wanted to access a Non Standard HTTP Port on one of my RaspberryPi Hosts, which was not directly available to the Internet, so I have chosen to establish a SOCKS Tunnel to achieve that.</p>

<h2>Web Application on my LAN</h2>

<p>Getting my RaspberryPi&rsquo;s Private IP Address:</p>

<pre><code class="bash">$ ifconfig eth0 | grep 'inet 192' | awk '{print $2}'
192.168.1.118
</code></pre>

<p>For demonstration purposes, I will use Python&rsquo;s SimpleHTTPServer:</p>

<pre><code class="bash">$ mkdir web
$ cd web
$ echo 'yeehaa' &gt; index.html
$ python -m SimpleHTTPServer 5050
Serving HTTP on 0.0.0.0 port 5050 ...
</code></pre>

<h2>Establish the SOCKS Tunnel</h2>

<p>From my laptop, establishing the SOCKS Tunnel with SSH, you can use <code>-f</code> to fork it in the background:</p>

<pre><code class="bash">$ ssh -D 8157 -CqN user@home.domain.com
</code></pre>

<h2>Configure your Browser:</h2>

<p>Configure your browser to Proxy via:</p>

<ul>
<li>Host: localhost</li>
<li>Port: 8157</li>
</ul>


<p>Now when you access the destined host&rsquo;s private ip, you will get a response:</p>

<pre><code class="bash">Browse to http://192.168.1.118:5050/ and in my case my response is:
-&gt; yeehaa
</code></pre>
]]></content>
  </entry>
  
</feed>
