<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Terraform | Ruan Bekker's Blog]]></title>
  <link href="https://blog.ruanbekker.com/blog/categories/terraform/atom.xml" rel="self"/>
  <link href="https://blog.ruanbekker.com/"/>
  <updated>2024-03-10T01:13:45-05:00</updated>
  <id>https://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Creating a Python Lambda Function With Terraform on AWS]]></title>
    <link href="https://blog.ruanbekker.com/blog/2023/08/03/creating-a-python-lambda-function-with-terraform-on-aws/"/>
    <updated>2023-08-03T11:29:35-04:00</updated>
    <id>https://blog.ruanbekker.com/blog/2023/08/03/creating-a-python-lambda-function-with-terraform-on-aws</id>
    <content type="html"><![CDATA[<p>In this tutorial I will explain how to deploy a AWS Lambda Function with Terraform using the Python runtime. It will include the permissions it needs to write its logs to AWS CloudWatch as well as to get information from the AWS API&rsquo;s as a boilerplate for you to expand on it.</p>

<p>We will also use CloudWatch Events to trigger this lambda function every two hours.</p>

<h2>Pre-Requisites</h2>

<p>First you will need to have <a href="https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli">Terraform</a> installed as well as authentication for Terraform to interact with your AWS account, I have written a post about it and you can follow that on &ldquo;<a href="https://blog.ruanbekker.com/blog/2023/07/15/how-to-use-the-aws-terraform-provider/">How to use the AWS Terraform Provider</a>&rdquo;.</p>

<h2>Project Structure</h2>

<p>The following code will be available on my <a href="https://github.com/ruanbekker/terraformfiles/tree/master/modules/aws-lambda-function">github repository</a>, but if you would like to follow along we will create everything step by step.</p>

<p>First create the project directory:</p>

<pre><code class="bash">mkdir -p ~/workspace/aws-lambda-terraform
</code></pre>

<p>Then change into the directory:</p>

<pre><code class="bash">cd ~/workspace/aws-lambda-terraform
</code></pre>

<p>First we want to create our modules directory:</p>

<pre><code class="bash">mkdir -p modules/lambda-function
</code></pre>

<p>Then our environment directory:</p>

<pre><code class="bash">mkdir -p environment/test
</code></pre>

<p>We will also create the directory for our function code:</p>

<pre><code class="bash">mkdir -p modules/lambda-function/functions
</code></pre>

<p>And we can create the file for our python function:</p>

<pre><code class="bash">touch modules/lambda-function/functions/demo.py
</code></pre>

<p>Now we will create our files inside our modules directory:</p>

<pre><code class="bash">touch modules/lambda-function/{main,versions,outputs,variables}.tf
</code></pre>

<p>Then create the files inside our environments directory:</p>

<pre><code class="bash">touch environment/test/{main,provider,output}.tf
</code></pre>

<p>Then in summary our project structure should look more or less like this:</p>

<pre><code class="bash">tree .
.
├── environment
│   └── test
│       ├── main.tf
│       ├── output.tf
│       └── provider.tf
└── modules
    └── lambda-function
        ├── functions
        │   └── demo.py
        ├── main.tf
        ├── outputs.tf
        ├── variables.tf
        └── versions.tf

5 directories, 8 files
</code></pre>

<h2>Terraform Code</h2>

<p>We will first start populating the modules bit, and start with <code>modules/lambda-function/main.tf</code>:</p>

<pre><code>data "aws_iam_policy_document" "lambda" {
  statement {
    actions = ["sts:AssumeRole"]

    principals {
      type        = "Service"
      identifiers = ["lambda.amazonaws.com"]
    }
  }
}

data "aws_iam_policy_document" "lambda_execution" {
  count = var.logs_enabled ? 1 : 0

  statement {
    sid     = "GetCallerIdentity"
    effect  = "Allow"

    actions = [
      "sts:GetCallerIdentity"
    ]

    resources = ["*"]

  }

  statement {
    sid     = "DescribeFunctionsInRegion"
    effect  = "Allow"

    actions = [
      "lambda:GetFunction"
    ]

    resources = ["*"]

    condition {
      test     = "StringEquals"
      variable = "aws:RequestedRegion"
      values = [var.aws_region]
    }
  }

}

resource "aws_iam_role_policy" "lambda_execution_policy" {
  count  = var.logs_enabled ? 1 : 0
  name   = "${var.project_name}-lambda-function-execution-policy"
  role   = aws_iam_role.lambda_role[count.index].id
  policy = data.aws_iam_policy_document.lambda_execution[count.index].json
}

data "archive_file" "lambda_zip" {
  type        = "zip"
  source_file = "${path.module}/functions/demo.py"
  output_path = "${path.module}/lambda-archives/package.zip"
}

resource "aws_iam_role" "lambda_role" {
  count              = var.logs_enabled ? 1 : 0
  name               = "${var.project_name}-lambda-function-role"
  assume_role_policy = data.aws_iam_policy_document.lambda.json
}

resource "aws_lambda_function" "lambda" {
  count            = var.logs_enabled ? 1 : 0
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = "${var.project_name}-lambda-function"
  role             = aws_iam_role.lambda_role[count.index].arn
  handler          = "demo.lambda_handler"
  source_code_hash = filebase64sha256(data.archive_file.lambda_zip.output_path)
  runtime          = "python3.8"
  timeout          = 30

  environment {
    variables = {
      PROJECT_NAME  = var.project_name
      FUNCTION_NAME = "${var.project_name}-lambda-function"
    }
  }

  depends_on = [
    data.archive_file.lambda_zip
  ]

}

resource "aws_cloudwatch_event_rule" "every_two_hours" {
  count               = var.logs_enabled ? 1 : 0
  name                = "${var.project_name}-every-two-hours"
  description         = "Fires every 2 hours"
  schedule_expression = "rate(2 hours)"
}

resource "aws_lambda_permission" "allow_cloudwatch" {
  count         = var.logs_enabled ? 1 : 0
  statement_id  = "AllowExecutionFromCloudWatch"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.lambda[count.index].function_name
  principal     = "events.amazonaws.com"
  source_arn    = aws_cloudwatch_event_rule.every_two_hours[count.index].arn
}

resource "aws_cloudwatch_event_target" "cloudwatch_event" {
  count     = var.logs_enabled ? 1 : 0
  rule      = aws_cloudwatch_event_rule.every_two_hours[count.index].name
  target_id = "${var.project_name}-snapshot-retention-target"
  arn       = aws_lambda_function.lambda[count.index].arn
}

// CloudWatch Logs
resource "aws_cloudwatch_log_group" "cloudwatch_log_group" {
  count     = var.logs_enabled ? 1 : 0
  name      = "/aws/lambda/${aws_lambda_function.lambda[count.index].function_name}"
  retention_in_days = 5
}

resource "aws_iam_role_policy_attachment" "lambda_exec_policy" {
  count      = var.logs_enabled ? 1 : 0
  role       = aws_iam_role.lambda_role[count.index].name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}
</code></pre>

<p>The next one will be the <code>modules/lambda-function/variables.tf</code>:</p>

<pre><code>variable "aws_region" {
  default = "eu-west-1"
  type    = string
}

variable "project_name" {
  default = "example"
  type    = string
}

variable "logs_enabled" {
  default = false
  type    = bool
}
</code></pre>

<p>Then define the modules output in <code>modules/lambda-function/outputs.tf</code>:</p>

<pre><code>output "arn_string" {
  value = aws_lambda_function.lambda[*].arn
}
</code></pre>

<p>Then we define our python function code in <code>modules/lambda-function/functions/demo.py</code>:</p>

<pre><code class="python">import os
import json
import logging
import boto3

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    client = boto3.client('lambda')
    logger.info(event)

    response = client.get_function(
        FunctionName=os.environ['FUNCTION_NAME']
    )

    logger.info(response)

    return {
        'statusCode' : 200,
        'body': response
    }
</code></pre>

<p>For our environment we want to specify the source as our module in <code>environment/test/main.tf</code>:</p>

<pre><code>module "myfunction" {
  source       = "../../modules/lambda-function"
  project_name = "test"
  logs_enabled = true
}
</code></pre>

<p>Our outputs in <code>environment/test/output.tf</code>:</p>

<pre><code>output "arn_string" {
  value = module.myfunction.arn_string
}
</code></pre>

<p>And since we are using AWS, we need to define our providers and the profile that we will use to authenticate against AWS, in my case, im using the default profile in <code>environment/test/provider.tf</code>:</p>

<pre><code>terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
      version = "4.23.0"
    }
  }
}

provider "aws" {
  region                   = "eu-west-1"
  profile                  = "default"
  shared_credentials_files = ["~/.aws/credentials"]
}
</code></pre>

<h2>Terraform Plan</h2>

<p>Now that we have defined our terraform code we can run:</p>

<pre><code class="bash">terraform plan
</code></pre>

<p>And it should return something more or less like the following:</p>

<pre><code class="bash">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # module.myfunction.aws_cloudwatch_event_rule.every_two_hours[0] will be created
  + resource "aws_cloudwatch_event_rule" "every_two_hours" {
      + arn                 = (known after apply)
      + description         = "Fires every 2 hours"
      + event_bus_name      = "default"
      + id                  = (known after apply)
      + is_enabled          = true
      + name                = "test-every-two-hours"
      + name_prefix         = (known after apply)
      + schedule_expression = "rate(2 hours)"
      + tags_all            = (known after apply)
    }

  # module.myfunction.aws_cloudwatch_event_target.cloudwatch_event[0] will be created
  + resource "aws_cloudwatch_event_target" "cloudwatch_event" {
      + arn            = (known after apply)
      + event_bus_name = "default"
      + id             = (known after apply)
      + rule           = "test-every-two-hours"
      + target_id      = "test-snapshot-retention-target"
    }

  # module.myfunction.aws_cloudwatch_log_group.cloudwatch_log_group[0] will be created
  + resource "aws_cloudwatch_log_group" "cloudwatch_log_group" {
      + arn               = (known after apply)
      + id                = (known after apply)
      + name              = "/aws/lambda/test-lambda-function"
      + retention_in_days = 5
      + tags_all          = (known after apply)
    }

  # module.myfunction.aws_iam_role.lambda_role[0] will be created
  + resource "aws_iam_role" "lambda_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = "sts:GetCallerIdentity"
                      + Effect   = "Allow"
                      + Resource = "*"
                      + Sid      = "GetCallerIdentity"
                    },
                  + {
                      + Action    = "lambda:GetFunction"
                      + Condition = {
                          + StringEquals = {
                              + "aws:RequestedRegion" = "eu-west-1"
                            }
                        }
                      + Effect    = "Allow"
                      + Resource  = "*"
                      + Sid       = "DescribeFunctionsInRegion"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "test-lambda-function-role"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)
    }

  # module.myfunction.aws_iam_role_policy.lambda_execution_policy[0] will be created
  + resource "aws_iam_role_policy" "lambda_execution_policy" {
      + id     = (known after apply)
      + name   = "test-lambda-function-execution-policy"
      + policy = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = "sts:GetCallerIdentity"
                      + Effect   = "Allow"
                      + Resource = "*"
                      + Sid      = "GetCallerIdentity"
                    },
                  + {
                      + Action    = "lambda:GetFunction"
                      + Condition = {
                          + StringEquals = {
                              + "aws:RequestedRegion" = "eu-west-1"
                            }
                        }
                      + Effect    = "Allow"
                      + Resource  = "*"
                      + Sid       = "DescribeFunctionsInRegion"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + role   = (known after apply)
    }

  # module.myfunction.aws_iam_role_policy_attachment.lambda_exec_policy[0] will be created
  + resource "aws_iam_role_policy_attachment" "lambda_exec_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      + role       = "test-lambda-function-role"
    }

  # module.myfunction.aws_lambda_function.lambda[0] will be created
  + resource "aws_lambda_function" "lambda" {
      + architectures                  = (known after apply)
      + arn                            = (known after apply)
      + filename                       = "../../modules/lambda-function/lambda-archives/package.zip"
      + function_name                  = "test-lambda-function"
      + handler                        = "demo.lambda_handler"
      + id                             = (known after apply)
      + invoke_arn                     = (known after apply)
      + last_modified                  = (known after apply)
      + memory_size                    = 128
      + package_type                   = "Zip"
      + publish                        = false
      + qualified_arn                  = (known after apply)
      + reserved_concurrent_executions = -1
      + role                           = (known after apply)
      + runtime                        = "python3.8"
      + signing_job_arn                = (known after apply)
      + signing_profile_version_arn    = (known after apply)
      + source_code_hash               = "MI7FD/KHgxRFh7cmPjzxg+w494pmyRGgQIr9Ls8Yups="
      + source_code_size               = (known after apply)
      + tags_all                       = (known after apply)
      + timeout                        = 30
      + version                        = (known after apply)

      + environment {
          + variables = {
              + "FUNCTION_NAME" = "test-lambda-function"
              + "PROJECT_NAME"  = "test"
            }
        }
    }

  # module.myfunction.aws_lambda_permission.allow_cloudwatch[0] will be created
  + resource "aws_lambda_permission" "allow_cloudwatch" {
      + action              = "lambda:InvokeFunction"
      + function_name       = "test-lambda-function"
      + id                  = (known after apply)
      + principal           = "events.amazonaws.com"
      + source_arn          = (known after apply)
      + statement_id        = "AllowExecutionFromCloudWatch"
      + statement_id_prefix = (known after apply)
    }

Plan: 8 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + arn_string = [
      + (known after apply),
    ]
</code></pre>

<h2>Create Resources</h2>

<p>If you are happy with the plan you can go ahead and run:</p>

<pre><code>terraform apply
</code></pre>

<p>Which will create the resources in AWS. Upon creation we should see something like this:</p>

<pre><code>Apply complete! Resources: 0 added, 1 changed, 0 destroyed.

Outputs:

arn_string = [
  "arn:aws:lambda:eu-west-1:000000000000:function:test-lambda-function",
]
</code></pre>

<p>Since we have our aws cli configured with a profile we can also test our lambda function:</p>

<pre><code class="bash">$ aws --profile default lambda invoke --function-name test-lambda-function --cli-binary-format raw-in-base64-out --payload '{"name": "ruan"}' out.log
{
    "StatusCode": 200,
    "ExecutedVersion": "$LATEST"
}
</code></pre>

<p>And the response from the invocation can be seen in the file we defined:</p>

<pre><code class="bash">$ cat out.log
{"statusCode": 200, "body": {"ResponseMetadata": {"RequestId": "5171x", "HTTPStatusCode": 200, "HTTPHeaders": {"date": "Thu, 21 Dec 2023 06:34:13 GMT", "content-type": "application/json", "content-length": "3517", "connection": "keep-alive", "x-amzn-requestid": "5171x"}, "RetryAttempts": 0}, "Configuration": {"FunctionName": "test-lambda-function", "FunctionArn": "arn:aws:lambda:eu-west-1:000000000000:function:test-lambda-function", "Runtime": "python3.8", "Role": "arn:aws:iam::000000000000:role/test-lambda-function-role", "Handler": "demo.lambda_handler", "CodeSize": 401, "Description": "", "Timeout": 30, "MemorySize": 128, "LastModified": "2023-12-21T06:26:46.000+0000", "CodeSha256": "x", "Version": "$LATEST", "Environment": {"Variables": {"FUNCTION_NAME": "test-lambda-function", "PROJECT_NAME": "test"}}, "TracingConfig": {"Mode": "PassThrough"}, "RevisionId": "7faex", "State": "Active", "LastUpdateStatus": "Successful", "PackageType": "Zip", "Architectures": ["x86_64"], "EphemeralStorage": {"Size": 512}, "SnapStart": {"ApplyOn": "None", "OptimizationStatus": "Off"}, "RuntimeVersionConfig": {"RuntimeVersionArn": "arn:aws:lambda:eu-west-1::runtime:x"}}, "Code": {"RepositoryType": "S3", "Location": "https://awslambda-eu-west-1-tasks.s3.eu-west-1.amazonaws.com/snapshots/x/test-lambda-function-x?queryparameters"}}}
</code></pre>

<h2>Updating Lambda Function Code</h2>

<p>If we want to redeploy our function with updated code, we can change the content of <code>functions/demo.py</code> and then run:</p>

<pre><code>terraform apply
</code></pre>

<p>Since our terraform code defined that if the source has of the function code changes, it will trigger a redeploy, and from the computed plan we can see that it will redeploy our function code:</p>

<pre><code class="bash">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  ~ update in-place

Terraform will perform the following actions:

  # module.myfunction.aws_lambda_function.lambda[0] will be updated in-place
  ~ resource "aws_lambda_function" "lambda" {
        id                             = "test-lambda-function"
      ~ last_modified                  = "2023-12-21T06:26:46.000+0000" -&gt; (known after apply)
      ~ source_code_hash               = "8TLrm4GmTrfAxwfElmIjws1Vf9UDZ6k2w1+VEONJaCQ=" -&gt; "RIQ62KCcjlcHh5lLCOlrkB7GioBpLY1Y5vN4UZGyN+c="
        tags                           = {}
        # (18 unchanged attributes hidden)

        # (3 unchanged blocks hidden)
    }

Plan: 0 to add, 1 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value:
</code></pre>

<p>After entering &ldquo;yes&rdquo; we will update our function code</p>

<h2>Discover AWS Console</h2>

<p>If we logon to the AWS Console and head to Lambda we can inspect our function code:</p>

<p><img src="https://github.com/ruanbekker/ruanbekker/assets/567298/2326b074-fa5b-443c-8715-59451293ccb2" alt="image" /></p>

<p>If we manually want to trigger the function, select &ldquo;Test&rdquo;, then enter the &ldquo;Event name&rdquo; with something like &ldquo;testing&rdquo; then click &ldquo;Test&rdquo;:</p>

<p><img src="https://github.com/ruanbekker/ruanbekker/assets/567298/76bcde33-185f-47ed-a70c-4d967df80e92" alt="image" /></p>

<p>If we follow the CloudWatch log link we can view the logs in CloudWatch:</p>

<p><img src="https://github.com/ruanbekker/ruanbekker/assets/567298/f5483602-3144-48ce-98bf-d50f625cdd92" alt="image" /></p>

<h2>Destroy Infrastructure</h2>

<p>If you followed along and would like to destroy the created infrastructure:</p>

<pre><code class="bash">terraform destroy
</code></pre>

<h2>Resources</h2>

<p>Terraform Examples</p>

<ul>
<li><a href="https://github.com/ruanbekker/terraformfiles/tree/master/modules/aws-lambda-function">https://github.com/ruanbekker/terraformfiles/tree/master/modules/aws-lambda-function</a></li>
</ul>


<h2>Thank You</h2>

<p>Thanks for reading, feel free to check out my <a href="https://ruan.dev/">website</a>, feel free to subscribe to my <a href="http://digests.ruanbekker.com/?via=ruanbekker-blog">newsletter</a> or follow me at <a href="https://twitter.com/ruanbekker">@ruanbekker</a> on Twitter.</p>

<ul>
<li>Linktree: <a href="https://go.ruan.dev/links">https://go.ruan.dev/links</a></li>
<li>Patreon: <a href="https://go.ruan.dev/patreon">https://go.ruan.dev/patreon</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Use the MySQL Terraform Provider]]></title>
    <link href="https://blog.ruanbekker.com/blog/2023/07/15/how-to-use-the-mysql-terraform-provider/"/>
    <updated>2023-07-15T20:55:23-04:00</updated>
    <id>https://blog.ruanbekker.com/blog/2023/07/15/how-to-use-the-mysql-terraform-provider</id>
    <content type="html"><![CDATA[<p>In this tutorial we will provision a MySQL Server with Docker and then use Terraform to provision MySQL Users, Database Schemas and MySQL Grants with the MySQL Terraform Provider.</p>

<h2>About</h2>

<p>Terraform is super powerful and can do a lot of things. And it shines when it provisions Infrastructure. So in a scenario where we use Terraform to provision RDS MySQL Database Instances, we might still want to provision extra MySQL Users, or Database Schemas and the respective MySQL Grants.</p>

<p>Usually you will logon to the database and create them manually with sql syntax. But in this tutorial we want to make use of Docker to provision our MySQL Server and we would like to make use of Terraform to provision the MySQL Database Schemas, Grants and Users.</p>

<p>Instead of using AWS RDS, I will be provisioning a MySQL Server on Docker so that we can keep the costs free, for those who are following along.</p>

<p>We will also go through the steps on how to rotate the database password that we will be provisioning for our user.</p>

<h2>MySQL Server</h2>

<p>First we will provision a MySQL Server on Docker Containers, I have a <code>docker-compose.yaml</code> which is available in my <a href="https://github.com/ruanbekker/quick-starts/blob/main/docker/mysql/docker-compose.yaml">quick-starts</a> github repository:</p>

<pre><code class="yaml">version: "3.8"

services:
  mysql:
    image: mysql:8.0
    container_name: mysql
    ports:
      - 3306:3306
    environment:
      - MYSQL_DATABASE=sample
      - MYSQL_ROOT_PASSWORD=rootpassword
</code></pre>

<p>Once you have saved that in your current working directory, you can start the container with docker compose:</p>

<pre><code class="bash">docker-compose up -d
</code></pre>

<p>You can test the mysql container by logging onto the mysql server with the correct auth:</p>

<pre><code class="bash">docker exec -it mysql mysql -u root -prootpassword -e 'show databases;'
</code></pre>

<p>This should be more or less the output:</p>

<pre><code class="sql">+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sample             |
| sys                |
+--------------------+
</code></pre>

<h2>Terraform</h2>

<p>If you don&rsquo;t have Terraform installed, you can install it from their <a href="https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli">documentation</a>.</p>

<p>If you want the source code of this example, its available in my <a href="https://github.com/ruanbekker/quick-starts/tree/main/terraform/mysql/petoju-provider">terraform-mysql/petoju-provider</a> repository. Which you can clone and jump into the <code>terraform/mysql/petoju-provider</code> directory.</p>

<p>First we will define the <code>providers.tf</code>:</p>

<pre><code class="bash">terraform {
  required_providers {
    mysql = {
      source = "petoju/mysql"
      version = "3.0.37"
    }
  }
}

provider "mysql" {
  alias    = "local"
  endpoint = "127.0.0.1:3306"
  username = "root"
  password = "rootpassword"
}
</code></pre>

<p>Then the <code>main.tf</code>:</p>

<pre><code class="bash">resource "random_password" "user_password" {
  length           = 24
  special          = true
  min_special      = 2
  override_special = "!#$%^&amp;*()-_=+[]{}&lt;&gt;:?"
  keepers = {
    password_version = var.password_version
  }
}

resource "mysql_database" "user_db" {
  provider = mysql.local
  name = var.database_name
}

resource "mysql_user" "user_id" {
  provider = mysql.local
  user = var.database_username
  plaintext_password = random_password.user_password.result
  host = "%"
  tls_option = "NONE"
}

resource "mysql_grant" "user_id" {
  provider = mysql.local
  user = var.database_username
  host = "%"
  database = var.database_name
  privileges = ["SELECT", "UPDATE"]
  depends_on = [
    mysql_user.user_id
  ]
}
</code></pre>

<p>Then the <code>variables.tf</code>:</p>

<pre><code class="bash">variable "database_name" {
  description = "The name of the database that you want created."
  type        = string
  default     = null
}

variable "database_username" {
  description = "The name of the database username that you want created."
  type        = string
  default     = null
}

variable "password_version" {
  description = "The password rotates when this value gets updated."
  type        = number
  default     = 0
}
</code></pre>

<p>Then our <code>outputs.tf</code>:</p>

<pre><code class="bash">output "user" {
  value = mysql_user.user_id.user
}

output "password" {
  sensitive = true
  value = random_password.user_password.result
}
</code></pre>

<p>Our <code>terraform.tfvars</code> that defines the values of our variables:</p>

<pre><code class="bash">database_name     = "foobar"
database_username = "ruanb"
password_version  = 0
</code></pre>

<p>Now we are ready to run our terraform code, which will ultimately create a database, user and grants. Outputs the encrypted string of your password which was encrypted with your <code>keybase_username</code>.</p>

<p>Initialise Terraform:</p>

<pre><code class="bash">terraform init
</code></pre>

<p>Run the plan to see what terraform wants to provision:</p>

<pre><code class="bash">terraform plan
</code></pre>

<p>And we can see the following resources will be created:</p>

<pre><code class="bash">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # mysql_database.user_db will be created
  + resource "mysql_database" "user_db" {
      + default_character_set = "utf8mb4"
      + default_collation     = "utf8mb4_general_ci"
      + id                    = (known after apply)
      + name                  = "foobar"
    }

  # mysql_grant.user_id will be created
  + resource "mysql_grant" "user_id" {
      + database   = "foobar"
      + grant      = false
      + host       = "%"
      + id         = (known after apply)
      + privileges = [
          + "SELECT",
          + "UPDATE",
        ]
      + table      = "*"
      + tls_option = "NONE"
      + user       = "ruanb"
    }

  # mysql_user.user_id will be created
  + resource "mysql_user" "user_id" {
      + host               = "%"
      + id                 = (known after apply)
      + plaintext_password = (sensitive value)
      + tls_option         = "NONE"
      + user               = "ruanb"
    }

  # random_password.user_password will be created
  + resource "random_password" "user_password" {
      + bcrypt_hash      = (sensitive value)
      + id               = (known after apply)
      + keepers          = {
          + "password_version" = "0"
        }
      + length           = 24
      + lower            = true
      + min_lower        = 0
      + min_numeric      = 0
      + min_special      = 2
      + min_upper        = 0
      + number           = true
      + numeric          = true
      + override_special = "!#$%^&amp;*()-_=+[]{}&lt;&gt;:?"
      + result           = (sensitive value)
      + special          = true
      + upper            = true
    }

Plan: 4 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + password = (sensitive value)
  + user     = "ruanb"
</code></pre>

<p>Run the apply which will create the database, the user, sets the password and applies the grants:</p>

<pre><code class="bash">terraform apply
</code></pre>

<p>Then our returned output should show something like this:</p>

<pre><code class="bash">Apply complete! Resources: 4 added, 0 changed, 0 destroyed.

Outputs:

password = &lt;sensitive&gt;
user = "ruanb"
</code></pre>

<p>As our password is set as sensitive, we can access the value with <code>terraform output -raw password</code>, let&rsquo;s assign the password to a variable:</p>

<pre><code class="bash">DBPASS=$(terraform output -raw password)
</code></pre>

<p>Then we can exec into the mysql container and logon to the mysql server with our new credentials:</p>

<pre><code class="bash">docker exec -it mysql mysql -u ruanb -p$DBPASS
</code></pre>

<p>And we can see we are logged onto the mysql server:</p>

<pre><code class="bash">Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 14
Server version: 8.0.33 MySQL Community Server - GPL

mysql&gt;
</code></pre>

<p>If we run <code>show databases;</code> we should see the following:</p>

<pre><code class="sql">mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| foobar             |
| information_schema |
| performance_schema |
+--------------------+
3 rows in set (0.03 sec)
</code></pre>

<p>If we want to rotate the mysql password for the user, we can update the <code>password_version</code> variable either in our <code>terraform.tfvars</code> or via the cli. Let&rsquo;s pass the variable in the cli and do a <code>terraform plan</code> to verify the changes:</p>

<pre><code class="bash">terraform plan -var password_version=1
</code></pre>

<p>And due to our value for the random resource keepers parameter being updated, it will trigger the value of our password to be changed, and that will let terraform update our mysql user&rsquo;s password:</p>

<pre><code class="bash">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  ~ update in-place
-/+ destroy and then create replacement

Terraform will perform the following actions:

  # mysql_user.user_id will be updated in-place
  ~ resource "mysql_user" "user_id" {
        id                 = "ruanb@%"
      ~ plaintext_password = (sensitive value)
        # (5 unchanged attributes hidden)
    }

  # random_password.user_password must be replaced
-/+ resource "random_password" "user_password" {
      ~ bcrypt_hash      = (sensitive value)
      ~ id               = "none" -&gt; (known after apply)
      ~ keepers          = { # forces replacement
          ~ "password_version" = "0" -&gt; "1"
        }
      ~ result           = (sensitive value)
        # (11 unchanged attributes hidden)
    }

Plan: 1 to add, 1 to change, 1 to destroy.
</code></pre>

<p>Let&rsquo;s go ahead by updating our password:</p>

<pre><code class="bash">terraform apply -var password_version=1 -auto-approve
</code></pre>

<p>To validate that the password has changed, we can try to logon to mysql by using the password variable that was created initially:</p>

<pre><code class="bash">docker exec -it mysql mysql -u ruanb -p$DBPASS
</code></pre>

<p>And as you can see authentication failed:</p>

<pre><code class="bash">mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 1045 (28000): Access denied for user 'ruanb'@'localhost' (using password: YES)
</code></pre>

<p>Set the new password to the variable again:</p>

<pre><code class="bash">DBPASS=$(terraform output -raw password)
</code></pre>

<p>Then try to logon again:</p>

<pre><code class="bash">docker exec -it mysql mysql -u ruanb -p$DBPASS
</code></pre>

<p>And we can see we are logged on again:</p>

<pre><code class="bash">Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 22
Server version: 8.0.33 MySQL Community Server - GPL

mysql&gt;
</code></pre>

<h2>Resources</h2>

<p>The terraform mysql provider:
- <a href="https://registry.terraform.io/providers/petoju/mysql/latest/docs">https://registry.terraform.io/providers/petoju/mysql/latest/docs</a></p>

<p>The quick-starts repository:
- <a href="https://github.com/ruanbekker/quick-starts">https://github.com/ruanbekker/quick-starts</a></p>

<h2>Thank You</h2>

<p>Thanks for reading, feel free to check out my <a href="https://ruan.dev/">website</a>, feel free to subscribe to my <a href="http://digests.ruanbekker.com/?via=ruanbekker-blog">newsletter</a> or follow me at <a href="https://twitter.com/ruanbekker">@ruanbekker</a> on Twitter.</p>

<ul>
<li>Linktree: <a href="https://go.ruan.dev/links">https://go.ruan.dev/links</a></li>
<li>Patreon: <a href="https://go.ruan.dev/patreon">https://go.ruan.dev/patreon</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Use the AWS Terraform Provider]]></title>
    <link href="https://blog.ruanbekker.com/blog/2023/07/15/how-to-use-the-aws-terraform-provider/"/>
    <updated>2023-07-15T20:01:13-04:00</updated>
    <id>https://blog.ruanbekker.com/blog/2023/07/15/how-to-use-the-aws-terraform-provider</id>
    <content type="html"><![CDATA[<p>In this post we will be using the AWS Terraform provider, from how to install Terraform, create a AWS IAM User, configure the AWS Provider and deploy a EC2 instance using Terraform.</p>

<h2>AWS IAM User</h2>

<p>In order to authenticate against AWS’s APIs, we need to create a AWS IAM User and create Access Keys for Terraform to use to authenticate.</p>

<p>From <a href="https://aws.amazon.com/">https://aws.amazon.com/</a> logon to your account, then search for IAM:</p>

<p><img src="https://github.com/ruanbekker/ruanbekker.github.io/assets/567298/c53d15d3-1af2-4e15-aafb-229cc4274bf5" alt="aws-iam-search-result" /></p>

<p>Select IAM, then select “Users” on the left hand side and select “Create User”, then provide the username for your AWS IAM User:</p>

<p><img src="https://github.com/ruanbekker/ruanbekker.github.io/assets/567298/35f74a94-98d3-44c4-9651-a504780e5a6e" alt="aws-iam-user-creation-wizard" /></p>

<p>Now we need to assign permissions to our new AWS IAM User. For this scenario I will be assigning a IAM Policy directly to the user and I will be selecting the “AdministratorAccess” policy. Keep in mind that this allows admin access to your whole AWS account:</p>

<p><img src="https://github.com/ruanbekker/ruanbekker.github.io/assets/567298/779f2dac-0da9-4751-8e89-2ff33c088ae8" alt="permissions-for-your-aws-iam-user" /></p>

<p>Once you select the policy, select “Next” and select “Create User”. Once the user has been created, select “Users” on the left hand side, search for your user that we created, in my case “medium-terraform”.</p>

<p>Select the user and click on “Security credentials”. If you scroll down to the “Access keys” section, you will notice we don’t have any access keys for this user:</p>

<p><img src="https://github.com/ruanbekker/ruanbekker.github.io/assets/567298/45b5eb1f-999f-4e81-b439-9e8cd90f83a3" alt="aws-iam-access-keys" /></p>

<p>In order to allow Terraform access to our AWS Account, we need to create access keys that Terraform will use, and because we assigned full admin access to the user, Terraform will be able to manage resources in our AWS Account.</p>

<p>Click “Create access key”, then select the “CLI” option and select the confirmation at the bottom:</p>

<p><img src="https://github.com/ruanbekker/ruanbekker.github.io/assets/567298/22b13879-6256-4de8-ab5f-aecece3be432" alt="aws-iam-access-keys-wizard" /></p>

<p>Select “Next” and then select “Create access key”. I am providing a screenshot of the Access Key and Secret Access Key that has been provided, but by the time this post has been published, the key will be deleted.</p>

<p><img src="https://github.com/ruanbekker/ruanbekker.github.io/assets/567298/a7a4124f-dc9c-4700-b0ed-d21d7df4fa6c" alt="retrieve-aws-iam-access-keys" /></p>

<p>Store your Access Key and Secret Access Key in a secure place and treat this like your passwords. If someone gets access to these keys they can manage your whole AWS Account.</p>

<p>I will be using the <a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html">AWS CLI</a> to configure my Access Key and Secret Access Key, as I will configure Terraform later to read my Access Keys from the Credential Provider config.</p>

<p>First we need to configure the AWS CLI by passing the profile name, which I have chosen <code>medium</code> for this demonstration:</p>

<pre><code class="bash">aws --profile medium configure
</code></pre>

<p>We will be asked to provide the access key, secret access key, aws region and the default output:</p>

<pre><code class="bash">AWS Access Key ID [None]: AKIATPRT2G4SGXLAC3HJ
AWS Secret Access Key [None]: KODnR[............]nYTYbd
Default region name [None]: eu-west-1
Default output format [None]: json
</code></pre>

<p>To verify if everything works as expected we can use the following command to verify:</p>

<pre><code class="bash">aws --profile medium sts get-caller-identity
</code></pre>

<p>The response should look something similar to the following:</p>

<pre><code class="json">{
    "UserId": "AIDATPRT2G4SOAO5Y7S5Z",
    "Account": "000000000000",
    "Arn": "arn:aws:iam::000000000000:user/medium-terraform"
}
</code></pre>

<h2>Terraform</h2>

<p>Now that we have our AWS IAM User configured, we can install Terraform, if you don’t have Terraform installed yet, you can follow their <a href="https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli">Installation Documentation</a>.</p>

<p>Once you have Terraform installed, we can setup our workspace where we will ultimately deploy a EC2 instance, but before we get there we need to create our project directory and change to that directory:</p>

<pre><code class="bash">mkdir ~/terraform-demo
cd ~/terraform-demo
</code></pre>

<p>Then we will create 4 files with <code>.tf</code> extensions:</p>

<pre><code class="bash">touch main.tf
touch outputs.tf
touch providers.tf
touch variables.tf
</code></pre>

<p>We will define our Terraform definitions on how we want our desired infrastructure to look like. We will get to the content in the files soon.</p>

<p>I personally love Terraform’s documentation as they are rich in examples and really easy to use.</p>

<p>Head over to the <a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs">Terraform AWS Provider</a> documentation and you scroll a bit down, you can see the <a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs#authentication-and-configuration">Authentication and Configuration</a> section where they outline the order in how Terraform will look for credentials and we will be making use of the shared credentials file as that is where our access key and secret access key is stored.</p>

<p>If you look at the top right corner of the Terraform AWS Provider documentation, they show you how to use the AWS Provider:</p>

<p><img src="https://github.com/ruanbekker/ruanbekker.github.io/assets/567298/03a55c32-bb1c-4f48-a441-c09918c824db" alt="terraform-aws-provider-docs" /></p>

<p>We can copy that code snippet and paste it into our <code>providers.tf</code> file and configure the aws provider section with the <code>medium</code> profile that we’ve created earlier.</p>

<p>This will tell Terraform where to look for credentials in order to authenticate with AWS.</p>

<p>Open <code>providers.tf</code> with your editor of choice:</p>

<pre><code class="bash">terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
      version = "5.8.0"
    }
  }
}

provider "aws" {
  shared_credentials_files = ["~/.aws/credentials"]
  profile                  = "medium"
  region                   = "eu-west-1"
}
</code></pre>

<p>Then we can open <code>main.tf</code> and populate the following to define the EC2 instance that we want to provision:</p>

<pre><code class="bash">data "aws_ami" "latest_ubuntu" {
  most_recent = true
  owners = ["099720109477"]

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-*-server-*"]
  }

  filter {
    name   = "architecture"
    values = ["x86_64"]
  }
}

resource "aws_instance" "ec2" {
  ami           = data.aws_ami.latest_ubuntu.id
  instance_type = var.instance_type
  tags = {
    Name = "${var.instance_name}-ec2-instance"
  }
}
</code></pre>

<p>In the above example we are filtering for the latest Ubuntu 22.04 64bit AMI then we are defining a EC2 instance and specifying the AMI ID that we filtered from our data source.</p>

<p>Note that we haven’t specified a SSH Keypair, as we are just focusing on how to provision a EC2 instance.</p>

<p>As you can see we are also referencing variables, which we need to define in <code>variables.tf</code> :</p>

<pre><code class="bash">variable "instance_name" {
  description = "Instance Name for EC2."
  type        = string
  default     = "test"
}

variable "instance_type" {
  description = "Instance Type for EC2."
  type        = string
  default     = "t2.micro"
}
</code></pre>

<p>And then lastly we need to define our <code>outputs.tf</code> which will be used to output the instance id and ip address:</p>

<pre><code class="bash">output "instance_id" {
  value = aws_instance.ec2.id
}

output "ip" {
  value = aws_instance.ec2.public_ip
}
</code></pre>

<h2>Deploy our EC2 with Terraform</h2>

<p>Now that our infrastructure has been defined as code, we can first initialise terraform which will initialise the backend and download all the providers that has been defined:</p>

<pre><code class="bash">terraform init
</code></pre>

<p>Once that has done we can run a “plan” which will show us what Terraform will deploy:</p>

<pre><code class="bash">terraform plan
</code></pre>

<p>Now terraform will show us the difference in what we have defined, and what is actually in AWS, as we know its a new account with zero infrastructure, the diff should show us that it needs to create a EC2 instance.</p>

<p>The response from the <code>terraform plan</code> shows us the following:</p>

<pre><code class="bash">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_instance.ec2 will be created
  + resource "aws_instance" "ec2" {
      + ami                                  = "ami-0f56955469757e5aa"
      + arn                                  = (known after apply)
      + id                                   = (known after apply)
      + instance_type                        = "t2.micro"
      + key_name                             = (known after apply)
      + private_ip                           = (known after apply)
      + public_ip                            = (known after apply)
      + security_groups                      = (known after apply)
      + subnet_id                            = (known after apply)
      + tags                                 = {
          + "Name" = "test-ec2-instance"
        }
      + tags_all                             = {
          + "Name" = "test-ec2-instance"
        }
      + vpc_security_group_ids               = (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + instance_id = (known after apply)
  + ip          = (known after apply)
</code></pre>

<p>As you can see terraform has looked up the AMI ID using the data source, and we can see that terraform will provision 1 resource which is a EC2 instance. Once we hare happy with the plan, we can run a apply which will show us the same but this time prompt us if we want to proceed:</p>

<pre><code class="bash">Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_instance.ec2: Creating...
aws_instance.ec2: Still creating... [10s elapsed]
aws_instance.ec2: Still creating... [20s elapsed]
aws_instance.ec2: Still creating... [30s elapsed]
aws_instance.ec2: Creation complete after 35s [id=i-005c08b899229fff0]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.

Outputs:

instance_id = "i-005c08b899229fff0"
ip = "34.253.196.167"
</code></pre>

<p>And now we can see our EC2 instance was provisioned and our outputs returned the instance id as well as the public ip address.</p>

<p>We can also confirm this by looking at the AWS EC2 Console:</p>

<p><img src="https://github.com/ruanbekker/ruanbekker.github.io/assets/567298/82b4d742-1c45-4d21-8766-10a5c0d074a1" alt="aws-ec2-instances-in-console" /></p>

<p>Note that Terraform Configuration is idempotent, so when we run a terraform apply again, terraform will check what we have defined as what we want our desired infrastructure to be like, and what we actually have in our AWS Account, and since we haven’t made any changes there should be no changes.</p>

<p>We can run a terraform apply to validate that:</p>

<pre><code class="bash">terraform apply
</code></pre>

<p>And we can see the response shows:</p>

<pre><code class="bash">data.aws_vpc.selected: Reading...
data.aws_ami.latest_ubuntu: Reading...
data.aws_ami.latest_ubuntu: Read complete after 1s [id=ami-0f56955469757e5aa]
data.aws_vpc.selected: Read complete after 1s [id=vpc-063d7ac3124053dfa]
data.aws_subnet.selected: Reading...
data.aws_subnet.selected: Read complete after 1s [id=subnet-0b7acd7593611c1bb]
aws_instance.ec2: Refreshing state... [id=i-005c08b899229fff0]

Apply complete! Resources: 0 added, 0 changed, 0 destroyed.
</code></pre>

<h2>Cleanup</h2>

<p>Destroy the infrastructure that we provisioned:</p>

<pre><code class="bash">terraform destroy
</code></pre>

<p>It will show us what terraform will destroy, then upon confirming we should see the following output:</p>

<pre><code class="bash">Plan: 0 to add, 0 to change, 1 to destroy.

Changes to Outputs:
  - instance_id = "i-005c08b899229fff0" -&gt; null
  - ip          = "34.253.196.167" -&gt; null

Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only 'yes' will be accepted to confirm.

  Enter a value: yes

aws_instance.ec2: Destroying... [id=i-005c08b899229fff0]
aws_instance.ec2: Still destroying... [id=i-005c08b899229fff0, 10s elapsed]
aws_instance.ec2: Still destroying... [id=i-005c08b899229fff0, 20s elapsed]
aws_instance.ec2: Still destroying... [id=i-005c08b899229fff0, 30s elapsed]
aws_instance.ec2: Destruction complete after 31s

Destroy complete! Resources: 1 destroyed.
</code></pre>

<p>If you followed along and you also want to clean up the AWS IAM user, head over to the AWS IAM Console and delete the “medium-terraform” IAM User.</p>

<h2>Thank You</h2>

<p>I hope you enjoyed this post, I will be posting more terraform related content.</p>

<p>Should you want to reach out to me, you can follow me on Twitter at <a href="https://twitter.com/ruanbekker">@ruanbekker</a> or check out my website at <a href="https://ruan.dev">https://ruan.dev</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manage Helm Releases With Terraform]]></title>
    <link href="https://blog.ruanbekker.com/blog/2023/03/09/manage-helm-releases-with-terraform/"/>
    <updated>2023-03-09T16:15:47-05:00</updated>
    <id>https://blog.ruanbekker.com/blog/2023/03/09/manage-helm-releases-with-terraform</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/224163430-34e18f11-2182-4d2b-b7ab-f4683c187719.png" alt="helm-releases-with-terraform" /></p>

<p>In this post we will use terraform to deploy a helm release to kubernetes.</p>

<h2>Kubernetes</h2>

<p>For this demonstration I will be using <a href="https://kind.sigs.k8s.io/">kind</a> to deploy a local Kubernetes cluster to the operating system that I am running this on, which will be Ubuntu Linux. For a more in-depth tutorial on Kind, you can see my post on <a href="https://blog.ruanbekker.com/blog/2022/09/20/kind-for-local-kubernetes-clusters/">Kind for Local Kubernetes Clusters</a>.</p>

<h2>Installing the Pre-Requirements</h2>

<p>We will be installing terraform, docker, kind and kubectl on Linux.</p>

<p>Install terraform:</p>

<pre><code class="bash">wget https://releases.hashicorp.com/terraform/1.3.0/terraform_1.3.0_linux_amd64.zip
unzip terraform_1.3.0_linux_amd64.zip
rm terraform_1.3.0_linux_amd64.zip
mv terraform /usr/bin/terraform
</code></pre>

<p>Verify that terraform has been installed:</p>

<pre><code class="bash">terraform -version
</code></pre>

<p>Which in my case returns:</p>

<pre><code class="bash">Terraform v1.3.0
on linux_amd64
</code></pre>

<p>Install Docker on Linux (be careful to curl pipe bash - trust the scripts that you are running):</p>

<pre><code class="bash">curl https://get.docker.com | bash
</code></pre>

<p>Then running <code>docker ps</code> should return:</p>

<pre><code class="bash">CONTAINER ID   IMAGE        COMMAND         CREATED          STATUS          PORTS       NAMES
</code></pre>

<p>Install kind on Linux:</p>

<pre><code class="bash">apt update
curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.17.0/kind-linux-amd64
chmod +x ./kind
sudo mv ./kind /usr/local/bin/kind
</code></pre>

<p>Then to verify that kind was installed with <code>kind --version</code> should return:</p>

<pre><code class="bash">kind version 0.17.0
</code></pre>

<p>Create a kubernetes cluster using kind:</p>

<pre><code class="bash">kind create cluster --name rbkr --image kindest/node:v1.24.0
</code></pre>

<p>Now install <a href="https://kubernetes.io/docs/tasks/tools/">kubectl</a>:</p>

<pre><code class="bash">curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
</code></pre>

<p>Then to verify that kubectl was installed:</p>

<pre><code class="bash">kubectl version --client
</code></pre>

<p>Which in my case returns:</p>

<pre><code class="bash">Client Version: version.Info{Major:"1", Minor:"26", GitVersion:"v1.26.1", GitCommit:"8f94681cd294aa8cfd3407b8191f6c70214973a4", GitTreeState:"clean", BuildDate:"2023-01-18T15:58:16Z", GoVersion:"go1.19.5", Compiler:"gc", Platform:"linux/amd64"}
Kustomize Version: v4.5.7
</code></pre>

<p>Now we can test if kubectl can communicate with the kubernetes api server:</p>

<pre><code class="bash">kubectl get nodes
</code></pre>

<p>In my case it returns:</p>

<pre><code class="bash">NAME                 STATUS   ROLES           AGE     VERSION
rbkr-control-plane   Ready    control-plane   6m20s   v1.24.0
</code></pre>

<h2>Terraform</h2>

<p>Now that our pre-requirements are sorted we can configure terraform to communicate with kubernetes. For that to happen, we need to consult the <a href="https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs">terraform kubernetes provider</a>&rsquo;s documentation.</p>

<p>As per their documentation they provide us with this snippet:</p>

<pre><code>terraform {
  required_providers {
    kubernetes = {
      source = "hashicorp/kubernetes"
      version = "2.18.0"
    }
  }
}

provider "kubernetes" {
  # Configuration options
}
</code></pre>

<p>And from their <a href="https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs">main</a> page, it gives us a couple of options to configure the provider and the easiest is probably to read the <code>~/.kube/config</code> configuration file.</p>

<p>But in cases where you have multiple configurations in your kube config file, this might not be ideal, and I like to be precise, so I will extract the client certificate, client key and cluster ca certificate and endpoint from our <code>~/.kube/config</code> file.</p>

<p>If we run <code>cat ~/.kube/config</code> we will see something like this:</p>

<pre><code class="yaml">apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: LS0tLS1CRU......FURS0tLS0tCg==
    server: https://127.0.0.1:40305
  name: kind-rbkr
contexts:
- context:
    cluster: kind-rbkr
    user: kind-rbkr
  name: kind-rbkr
current-context: kind-rbkr
kind: Config
preferences: {}
users:
- name: kind-rbkr
  user:
    client-certificate-data: LS0tLS1CRX......FURS0tLS0tCg==
    client-key-data: LS0tLS1CRUejhKWUk2N2.....S0tCg==
</code></pre>

<p>First we will create a directory for our certificates:</p>

<pre><code class="bash">mkdir ~/certs
</code></pre>

<p>I have truncated my kube config for readability, but for our first file <code>certs/client-cert.pem</code> we will copy the value of <code>client-certificate-data:</code>, which will look something like this:</p>

<pre><code class="bash">cat certs/client-cert.pem
LS0tLS1CRX......FURS0tLS0tCg==
</code></pre>

<p>Then we will copy the contents of <code>client-key-data:</code> into <code>certs/client-key.pem</code> and then lastly the content of <code>certificate-authority-data:</code> into <code>certs/cluster-ca-cert.pem</code>.</p>

<p>So then we should have the following files inside our <code>certs/</code> directory:</p>

<pre><code class="bash">tree certs/
certs/
├── client-cert.pem
├── client-key.pem
└── cluster-ca-cert.pem

0 directories, 3 files
</code></pre>

<p>Now make them read only:</p>

<pre><code class="bash">chmod 400 ~/certs/*
</code></pre>

<p>Now that we have that we can start writing our terraform configuration. In <code>providers.tf</code>:</p>

<pre><code>terraform {
  required_providers {
    kubernetes = {
      source = "hashicorp/kubernetes"
      version = "2.18.0"
    }
  }
}

provider "kubernetes" {
  host                   = "https://127.0.0.1:40305"
  client_certificate     = base64decode(file("~/certs/client-cert.pem"))
  client_key             = base64decode(file("~/certs/client-key.pem"))
  cluster_ca_certificate = base64decode(file("~/certs/cluster-ca-cert.pem"))
}
</code></pre>

<p>Your host might look different to mine, but you can find your host endpoint in <code>~/.kube/config</code>.</p>

<p>For a simple test we can list all our namespaces to ensure that our configuration is working. In a file called <code>namespaces.tf</code>, we can populate the following:</p>

<pre><code>data "kubernetes_all_namespaces" "allns" {}

output "all-ns" {
  value = data.kubernetes_all_namespaces.allns.namespaces
}
</code></pre>

<p>Now we need to initialize terraform so that it can download the providers:</p>

<pre><code class="bash">terraform init
</code></pre>

<p>Then we can run a plan which will reveal our namespaces:</p>

<pre><code class="bash">terraform plan

data.kubernetes_all_namespaces.allns: Reading...
data.kubernetes_all_namespaces.allns: Read complete after 0s [id=a0ff7e83ffd7b2d9953abcac9f14370e842bdc8f126db1b65a18fd09faa3347b]

Changes to Outputs:
  + all-ns = [
      + "default",
      + "kube-node-lease",
      + "kube-public",
      + "kube-system",
      + "local-path-storage",
    ]
</code></pre>

<p>We can now remove our <code>namespaces.tf</code> as our test worked:</p>

<pre><code class="bash">rm namespaces.tf
</code></pre>

<h2>Helm Releases with Terraform</h2>

<p>We will need two things, we need to consult the <a href="https://registry.terraform.io/providers/hashicorp/helm/latest/docs/resources/release">terraform helm release provider</a> documentation and we also need to consult the helm chart documentation which we are interested in.</p>

<p>In my previous post I wrote about <a href="https://blog.ruanbekker.com/blog/2023/01/24/everything-you-need-to-know-about-helm/">Everything you need to know about Helm</a> and I used the <a href="https://artifacthub.io/packages/helm/bitnami/nginx">Bitnami Nginx Helm Chart</a>, so we will use that one again.</p>

<p>As we are working with helm releases, we need to configure the helm provider, I will just extend my configuration from my previous provider config in <code>providers.tf</code>:</p>

<pre><code>terraform {
  required_providers {
    kubernetes = {
      source = "hashicorp/kubernetes"
      version = "2.18.0"
    }
    helm = {
      source = "hashicorp/helm"
      version = "2.9.0"
    }
  }
}

provider "kubernetes" {
  host                   = "https://127.0.0.1:40305"
  client_certificate     = base64decode(file("~/certs/client-cert.pem"))
  client_key             = base64decode(file("~/certs/client-key.pem"))
  cluster_ca_certificate = base64decode(file("~/certs/cluster-ca-cert.pem"))
}

provider "helm" {
  kubernetes {
    host                   = "https://127.0.0.1:40305"
    client_certificate     = base64decode(file("~/certs/client-cert.pem"))
    client_key             = base64decode(file("~/certs/client-key.pem"))
    cluster_ca_certificate = base64decode(file("~/certs/cluster-ca-cert.pem"))
  }
}
</code></pre>

<p>We will create three terraform files:</p>

<pre><code class="bash">touch {main,outputs,variables}.tf
</code></pre>

<p>And our values yaml in <code>helm-chart/nginx/values.yaml</code>:</p>

<pre><code class="bash">mkdir -p helm-chart/nginx
</code></pre>

<p>Then you can copy the values file from <a href="https://artifacthub.io/packages/helm/bitnami/nginx?modal=values">https://artifacthub.io/packages/helm/bitnami/nginx?modal=values</a> into <code>helm-chart/nginx/values.yaml</code>.</p>

<p>In our <code>main.tf</code> I will use two ways to override values in our <code>values.yaml</code> using <code>set</code> and <code>templatefile</code>. The reason for the templatefile, is when we want to fetch a value and want to replace the content with our values file, it could be used when we retrieve a value from a data source as an example. In my example im just using a variable.</p>

<p>We will have the following:</p>

<pre><code>resource "helm_release" "nginx" {
  name             = var.release_name
  version          = var.chart_version
  namespace        = var.namespace
  create_namespace = var.create_namespace
  chart            = var.chart_name
  repository       = var.chart_repository_url
  dependency_update = true
  reuse_values      = true
  force_update      = true
  atomic              = var.atomic

  set {
    name  = "image.tag"
    value = "1.23.3-debian-11-r3"
  }

  set {
    name  = "service.type"
    value = "ClusterIP"
  }

  values = [
    templatefile("${path.module}/helm-chart/nginx/values.yaml", {
      NAME_OVERRIDE   = var.release_name
    }
  )]

}
</code></pre>

<p>As you can see we are referencing a <code>NAME_OVERRIDE</code> in our <code>values.yaml</code>, I have cleaned up the values file to the following:</p>

<pre><code class="yaml">nameOverride: "${NAME_OVERRIDE}"

## ref: https://hub.docker.com/r/bitnami/nginx/tags/
image:
  registry: docker.io
  repository: bitnami/nginx
  tag: 1.23.3-debian-11-r3
</code></pre>

<p>The <code>NAME_OVERRIDE</code> must be in a <code>${}</code> format.</p>

<p>In our <code>variables.tf</code> we will have the following:</p>

<pre><code>variable "release_name" {
  type        = string
  default     = "nginx"
  description = "The name of our release."
}

variable "chart_repository_url" {
  type        = string
  default     = "https://charts.bitnami.com/bitnami"
  description = "The chart repository url."
}

variable "chart_name" {
  type        = string
  default     = "nginx"
  description = "The name of of our chart that we want to install from the repository."
}

variable "chart_version" {
  type        = string
  default     = "13.2.20"
  description = "The version of our chart."
}

variable "namespace" {
  type        = string
  default     = "apps"
  description = "The namespace where our release should be deployed into."
}

variable "create_namespace" {
  type        = bool
  default     = true
  description = "If it should create the namespace if it doesnt exist."
}

variable "atomic" {
  type        = bool
  default     = false
  description = "If it should wait until release is deployed."
}
</code></pre>

<p>And lastly our <code>outputs.tf</code>:</p>

<pre><code>output "metadata" {
  value = helm_release.nginx.metadata
}
</code></pre>

<p>Now that we have all our configuration ready, we can initialize terraform:</p>

<pre><code class="bash">terraform init
</code></pre>

<p>Then we can run a plan to see what terraform wants to deploy:</p>

<pre><code class="bash">terraform plan
</code></pre>

<p>The plan output shows the following:</p>

<pre><code class="bash">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # helm_release.nginx will be created
  + resource "helm_release" "nginx" {
      + atomic                     = false
      + chart                      = "nginx"
      + cleanup_on_fail            = false
      + create_namespace           = true
      + dependency_update          = false
      + disable_crd_hooks          = false
      + disable_openapi_validation = false
      + disable_webhooks           = false
      + force_update               = false
      + id                         = (known after apply)
      + lint                       = false
      + manifest                   = (known after apply)
      + max_history                = 0
      + metadata                   = (known after apply)
      + name                       = "nginx"
      + namespace                  = "apps"
      + pass_credentials           = false
      + recreate_pods              = false
      + render_subchart_notes      = true
      + replace                    = false
      + repository                 = "https://charts.bitnami.com/bitnami"
      + reset_values               = false
      + reuse_values               = false
      + skip_crds                  = false
      + status                     = "deployed"
      + timeout                    = 300
      + values                     = [
          + &lt;&lt;-EOT
                nameOverride: "nginx"

                ## ref: https://hub.docker.com/r/bitnami/nginx/tags/
                image:
                  registry: docker.io
                  repository: bitnami/nginx
                  tag: 1.23.3-debian-11-r3
            EOT,
        ]
      + verify                     = false
      + version                    = "13.2.20"
      + wait                       = false
      + wait_for_jobs              = false

      + set {
          + name  = "image.tag"
          + value = "1.23.3-debian-11-r3"
        }
    }

Plan: 1 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + metadata = (known after apply)
</code></pre>

<p>Once we are happy with our plan, we can run a apply:</p>

<pre><code class="bash">terraform apply 

Plan: 1 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + metadata = (known after apply)

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

helm_release.nginx: Creating...
helm_release.nginx: Still creating... [10s elapsed]

metadata = tolist([
  {
    "app_version" = "1.23.3"
    "chart" = "nginx"
    "name" = "nginx"
    "namespace" = "apps"
    "revision" = 1
    "values" = "{\"image\":{\"registry\":\"docker.io\",\"repository\":\"bitnami/nginx\",\"tag\":\"1.23.3-debian-11-r3\"},\"nameOverride\":\"nginx\"}"
    "version" = "13.2.20"
  },
])
</code></pre>

<p>Then we can verify if the pod is running:</p>

<pre><code class="bash">kubectl get pods -n apps
NAME                    READY   STATUS    RESTARTS   AGE
nginx-59bdc6465-xdbfh   1/1     Running   0          2m35s
</code></pre>

<h2>Importing Helm Releases into Terraform State</h2>

<p>If you have an existing helm release that was deployed with helm and you want to transfer the ownership to terraform, you first need to write the terraform code, then import the resources into terraform state using:</p>

<pre><code class="bash">terraform import helm_release.nginx apps/nginx
</code></pre>

<p>Where the last argument is <code>&lt;namespace&gt;/&lt;release-name&gt;</code>. Once that is imported you can run terraform plan and apply.</p>

<p>If you want to discover all helm releases managed by helm you can use:</p>

<pre><code class="bash">kubectl get all -A -l app.kubernetes.io/managed-by=Helm
</code></pre>

<h2>Thank You</h2>

<p>Thanks for reading, feel free to check out my <a href="https://ruan.dev/">website</a>, feel free to subscribe to my <a href="http://digests.ruanbekker.com/?via=ruanbekker-blog">newsletter</a> or follow me at <a href="https://twitter.com/ruanbekker">@ruanbekker</a> on Twitter.</p>

<ul>
<li>Linktree: <a href="https://go.ruan.dev/links">https://go.ruan.dev/links</a></li>
<li>Patreon: <a href="https://go.ruan.dev/patreon">https://go.ruan.dev/patreon</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Persisting Terraform Remote State in Gitlab]]></title>
    <link href="https://blog.ruanbekker.com/blog/2023/03/05/persisting-terraform-remote-state-in-gitlab/"/>
    <updated>2023-03-05T01:43:54-05:00</updated>
    <id>https://blog.ruanbekker.com/blog/2023/03/05/persisting-terraform-remote-state-in-gitlab</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/567298/222946002-7cd88466-c584-4ea0-b190-54b1c3052865.png" alt="terraform-state-gitlab" /></p>

<p>In this tutorial we will demonstrate how to persist your terraform state in gitlab managed terraform state, using the terraform http backend.</p>

<p>For detailed information about this consult <a href="https://docs.gitlab.com/ee/user/infrastructure/iac/terraform_state.html">their documentation</a></p>

<h2>What are we doing?</h2>

<p>We will create a terraform pipeline which will run the plan step automatically and a manual step to run the apply step.</p>

<p>During these steps and different pipelines we need to persist our terraform state remotely so that new pipelines can read from our state what we last stored.</p>

<p>Gitlab offers a <a href="https://docs.gitlab.com/ee/user/infrastructure/iac/terraform_state.html">remote backend</a> for our terraform state which we can use, and we will use a basic example of using the random resource.</p>

<h2>Prerequisites</h2>

<p>If you don&rsquo;t see the &ldquo;Infrastructure&rdquo; menu on your left, you need to enable it at &ldquo;Settings&rdquo;, &ldquo;General&rdquo;, &ldquo;Visibility&rdquo;, &ldquo;Project features&rdquo;, &ldquo;Permissions&rdquo; and under &ldquo;Operations&rdquo;, turn on the toggle.</p>

<p>For more information on this see their <a href="https://docs.gitlab.com/ee/user/infrastructure/iac/terraform_state.html#prerequisites">documentation</a></p>

<h2>Authentication</h2>

<p>For this demonstration I created a token which is only scoped for this one project, for this we need a to create a token under, &ldquo;Settings&rdquo;, &ldquo;Access Tokens&rdquo;:</p>

<p><img src="https://user-images.githubusercontent.com/567298/222896148-6b0121fe-fceb-470e-a096-5db03ae0eab9.png" alt="image" /></p>

<p>Select the <code>api</code> under scope:</p>

<p><img src="https://user-images.githubusercontent.com/567298/222896298-fee26e1f-6bcf-4d7c-80eb-ed48ded33bf2.png" alt="image" /></p>

<p>Store the token name and token value as <code>TF_USERNAME</code> and <code>TF_PASSWORD</code> as a CICD variable under &ldquo;Settings&rdquo;, &ldquo;CI/CD&rdquo;, &ldquo;Variables&rdquo;.</p>

<h2>Terraform Code</h2>

<p>We will use a basic <code>random_uuid</code> resource for this demonstration, our <code>main.tf</code>:</p>

<pre><code>resource "random_uuid" "uuid" {}

output "uuid" {
  value       = random_uuid.uuid.result
  sensitive   = false
}
</code></pre>

<p>Our <code>providers.tf</code>, you will notice the <code>backend "http" {}</code> is what is required for our gitlab remote state:</p>

<pre><code>terraform {
  required_providers {
    random = {
      source = "hashicorp/random"
      version = "3.4.3"
    }
  }
  backend "http" {}
  required_version = "~&gt; 1.3.6"
}

provider "random" {}
</code></pre>

<p>Push that up to gitlab for now.</p>

<h2>Gitlab Pipeline</h2>

<p>Our <code>.gitlab-ci.yml</code> consists of a plan step and a apply step which is a manual step as we first want to review our plan step before we apply.</p>

<p>Our pipeline will only run on the default branch, which in my case is main:</p>

<pre><code class="yaml">image:
  name: hashicorp/terraform:1.3.6
  entrypoint: [""]

cache:
  paths:
    - .terraform

workflow:
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: never

variables:
  TF_ADDRESS: "https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/default-terraform.tfstate"

stages:
  - plan
  - apply

.terraform_init: &amp;terraform_init
  - terraform init
      -backend-config=address=${TF_ADDRESS}
      -backend-config=lock_address=${TF_ADDRESS}/lock
      -backend-config=unlock_address=${TF_ADDRESS}/lock
      -backend-config=username=${TF_USERNAME}
      -backend-config=password=${TF_PASSWORD}
      -backend-config=lock_method=POST
      -backend-config=unlock_method=DELETE
      -backend-config=retry_wait_min=5

terraform:plan:
  stage: plan
  artifacts:
    paths:
      - '**/*.tfplan'
      - '**/.terraform.lock.hcl'
  before_script:
    - *terraform_init
  script:
    - terraform validate
    - terraform plan -input=false -out default.tfplan

terraform:apply:
  stage: apply
  artifacts:
    paths:
      - '**/*.tfplan'
      - '**/.terraform.lock.hcl'
  before_script:
    - *terraform_init
  script:
    - terraform apply -input=false -auto-approve default.tfplan
  when: manual
</code></pre>

<p>Where the magic happens is in the <code>terraform init</code> step, that is where we will initialize the terraform state in gitlab, and as you can see we are taking the <code>TF_ADDRESS</code> variable to define the path of our state and in this case our state file will be named <code>default-terraform.tfstate</code>.</p>

<p>If it was a case where you are deploying multiple environments, you can use something like <code>${ENVIRONMENT}-terraform.tfstate</code>.</p>

<p>When we run our pipeline, we can look at our plan step:</p>

<p><img src="https://user-images.githubusercontent.com/567298/222947389-9d9d8d4f-a114-44b5-b183-a2b126ba82b8.png" alt="image" /></p>

<p>Once we are happy with this we can run the manual step and do the apply step, then our pipeline should look like this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/222930015-6445a5da-7887-47a6-989e-f33a33b9451a.png" alt="image" /></p>

<p>When we inspect our terraform state in the infrastructure menu, we can see the state file was created:</p>

<p><img src="https://user-images.githubusercontent.com/567298/222901200-2cd0a0f9-6e81-438f-bc74-286778b648d4.png" alt="image" /></p>

<h2>Thank You</h2>

<p>Thanks for reading, feel free to check out my <a href="https://ruan.dev/">website</a>, feel free to subscribe to my <a href="http://digests.ruanbekker.com/?via=ruanbekker-blog">newsletter</a> or follow me at <a href="https://twitter.com/ruanbekker">@ruanbekker</a> on Twitter.</p>

<ul>
<li>Linktree: <a href="https://go.ruan.dev/links">https://go.ruan.dev/links</a></li>
<li>Patreon: <a href="https://go.ruan.dev/patreon">https://go.ruan.dev/patreon</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
