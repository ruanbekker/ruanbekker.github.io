<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Traefik | Ruan Bekker's Blog]]></title>
  <link href="https://blog.ruanbekker.com/blog/categories/traefik/atom.xml" rel="self"/>
  <link href="https://blog.ruanbekker.com/"/>
  <updated>2023-12-21T17:02:56-05:00</updated>
  <id>https://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Run Docker Containers With Terraform]]></title>
    <link href="https://blog.ruanbekker.com/blog/2021/11/23/run-docker-containers-with-terraform/"/>
    <updated>2021-11-23T11:06:03-05:00</updated>
    <id>https://blog.ruanbekker.com/blog/2021/11/23/run-docker-containers-with-terraform</id>
    <content type="html"><![CDATA[<p>In this post I will demonstrate how to use the terraform <a href="https://registry.terraform.io/providers/kreuzwerker/docker/latest/docs/resources/container">docker_container</a> resource from the <a href="https://github.com/kreuzwerker/terraform-provider-docker">docker provider</a> to run two docker containers, traefik and nginx and use the random provider to generate a random url for us.</p>

<h2>Pre-Requisites</h2>

<p>You will require <a href="https://www.terraform.io/downloads.html">terraform</a> and <a href="https://docs.docker.com/get-docker/">docker</a> to be installed.</p>

<h2>Project Structure</h2>

<p>The source code for this post is available on my github repository, but the project structure will look like the following:</p>

<p><img src="https://user-images.githubusercontent.com/567298/143061769-c619e7eb-c5b1-42bc-9fa4-ed59c15448fa.png" alt="image" /></p>

<p>Our <code>providers.tf</code>:</p>

<pre><code>terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "2.15.0"
    }
    random = {
      version = "~&gt; 3.0"
    }
  }
}

provider "docker" {
  host = "unix:///var/run/docker.sock"
}

provider "random" {}
</code></pre>

<p>Our <code>variables.tf</code>:</p>

<pre><code>variable "domain" {
  type    = string
  default = "localdns.xyz"
}
</code></pre>

<p>Our <code>outputs.tf</code>:</p>

<pre><code>output "nginx_container_name" {
  value = docker_container.nginx.name
}

output "traefik_container_name" {
  value = docker_container.traefik.name
}

output "traefik_url" {
  value = "http://traefik.${var.domain}/"
}

output "nginx_url" {
  value = "http://www.${random_string.nginx.result}.${var.domain}/"
}
</code></pre>

<p>Our <code>main.tf</code>:</p>

<pre><code>resource "random_string" "nginx" {
  length  = 8
  upper   = false
  special = false
}

resource "docker_image" "nginx" {
  name = "nginx:stable-alpine"
}

resource "docker_image" "traefik" {
  name = "traefik:1.7.14"
}

resource "docker_network" "nginx" {
  name   = "docknet"
  driver = "bridge"
}

resource "docker_container" "traefik" {
  name  = "traefik"
  image = docker_image.traefik.name

  networks_advanced {
    name    = docker_network.nginx.name
    aliases = ["docknet"]
  }

  restart = "unless-stopped"
  destroy_grace_seconds = 30
  must_run = true
  memory = 256

  volumes {
    host_path      = "/var/run/docker.sock"
    container_path = "/var/run/docker.sock"
  }

  command = [
    "--api",
    "--docker",
    "--docker.watch",
    "--entrypoints=Name:http Address::80",
    "--logLevel=INFO"
  ]

  ports {
    internal = 80
    external = 80
    ip       = "0.0.0.0"
  }

  labels {
    label = "traefik.enable"
    value = true
  }

  labels {
    label = "traefik.docker.network"
    value = "docknet"
  }

  labels {
    label = "traefik.frontend.rule"
    value = "Host:traefik.${var.domain}"
  }

  labels {
    label = "traefik.port"
    value = 8080
  }

}

resource "docker_container" "nginx" {
  name  = "nginx"
  image = docker_image.nginx.name

  networks_advanced {
    name    = docker_network.nginx.name
    aliases = ["docknet"]
  }

  restart = "unless-stopped"
  destroy_grace_seconds = 30
  must_run = true
  memory = 256

  volumes {
    host_path      = "/Users/ruan/personal/terraform-playground/docker-containers/html"
    container_path = "/usr/share/nginx/html"
  }

  volumes {
    host_path      = "/Users/ruan/personal/terraform-playground/docker-containers/configs/nginx.conf"
    container_path = "/etc/nginx/nginx.conf"
  }

  volumes {
    host_path      = "/Users/ruan/personal/terraform-playground/docker-containers/configs/app.conf"
    container_path = "/etc/nginx/conf.d/app.conf"
  }

  env = [
    "PUID=501",
    "PGID=20"
  ]

  labels {
    label = "traefik.enable"
    value = true
  }

  labels {
    label = "traefik.docker.network"
    value = "docknet"
  }

  labels {
    label = "traefik.frontend.rule"
    value = "Host:www.${random_string.nginx.result}.${var.domain}"
  }

  labels {
    label = "traefik.port"
    value = 80
  }

  depends_on = [
    docker_container.traefik,
    random_string.nginx
  ]

}
</code></pre>

<p>Our <code>html/index.html</code>:</p>

<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;

        &lt;title&gt;Welcome&lt;/title&gt;

        &lt;!-- Fonts --&gt;
        &lt;link href="https://fonts.googleapis.com/css?family=Nunito:200,600" rel="stylesheet"&gt;

        &lt;!-- Styles --&gt;
        &lt;style&gt;
            html, body {
                background-color: #fff;
                color: #636b6f;
                font-family: 'Nunito', sans-serif;
                font-weight: 200;
                height: 100vh;
                margin: 0;
            }

            .full-height {
                height: 100vh;
            }

            .flex-center {
                align-items: center;
                display: flex;
                justify-content: center;
            }

            .position-ref {
                position: relative;
            }

            .top-right {
                position: absolute;
                right: 10px;
                top: 18px;
            }

            .content {
                text-align: center;
            }

            .title {
                font-size: 84px;
            }

            .links &gt; a {
                color: #636b6f;
                padding: 0 25px;
                font-size: 13px;
                font-weight: 600;
                letter-spacing: .1rem;
                text-decoration: none;
                text-transform: uppercase;
            }

            .m-b-md {
                margin-bottom: 30px;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="flex-center position-ref full-height"&gt;
            &lt;div class="content"&gt;
                &lt;div class="title m-b-md"&gt;
                    Welcome
                &lt;/div&gt;

                &lt;div class="links"&gt;
                    &lt;a href="https://ruan.dev" target="_blank"&gt;About Me&lt;/a&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Our <code>configs/nginx.conf</code>:</p>

<pre><code>user  nginx;
worker_processes  auto;
error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;
    sendfile        on;
    keepalive_timeout  65;

    include /etc/nginx/conf.d/app.conf;
}
</code></pre>

<p>And lastly, our <code>configs/app.conf</code>:</p>

<pre><code>server {
  listen 80;
  server_name _;

  location / {
    root   /usr/share/nginx/html;
    index  index.html;
  }

  location /healthz {
    return 200 'up';
  }
}
</code></pre>

<h2>Deployment</h2>

<p>Once everything is in place, or if you want to clone my repository, you can do that by:</p>

<pre><code>git clone https://github.com/ruanbekker/terraform-docker-container-example
cd terraform-docker-container-example
</code></pre>

<p>Then we can initialize terraform by fetching the required plugins:</p>

<pre><code>terraform init
</code></pre>

<p>Once that completes we can run a plan:</p>

<pre><code>terraform plan
</code></pre>

<p>And that should output something more or less like:</p>

<pre><code>Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with
the following symbols:
  + create

Terraform will perform the following actions:

  # docker_container.nginx will be created
  + resource "docker_container" "nginx" {
      + attach                = false
      + bridge                = (known after apply)
      + command               = (known after apply)
      + container_logs        = (known after apply)
      + destroy_grace_seconds = 30
      + entrypoint            = (known after apply)
      + env                   = [
          + "PGID=20",
          + "PUID=501",
        ]
      + exit_code             = (known after apply)
      + gateway               = (known after apply)
      + hostname              = (known after apply)
      + id                    = (known after apply)
      + image                 = "nginx:stable-alpine"
      + init                  = (known after apply)
      + ip_address            = (known after apply)
      + ip_prefix_length      = (known after apply)
      + ipc_mode              = (known after apply)
      + log_driver            = "json-file"
      + logs                  = false
      + memory                = 256
      + must_run              = true
      + name                  = "nginx"
      + network_data          = (known after apply)
      + read_only             = false
      + remove_volumes        = true
      + restart               = "unless-stopped"
      + rm                    = false
      + security_opts         = (known after apply)
      + shm_size              = (known after apply)
      + start                 = true
      + stdin_open            = false
      + tty                   = false

      + healthcheck {
          + interval     = (known after apply)
          + retries      = (known after apply)
          + start_period = (known after apply)
          + test         = (known after apply)
          + timeout      = (known after apply)
        }

      + labels {
          + label = "traefik.docker.network"
          + value = "docknet"
        }
      + labels {
          + label = "traefik.enable"
          + value = "true"
        }
      + labels {
          + label = "traefik.frontend.rule"
          + value = (known after apply)
        }
      + labels {
          + label = "traefik.port"
          + value = "80"
        }

      + networks_advanced {
          + aliases = [
              + "docknet",
            ]
          + name    = "docknet"
        }

      + volumes {
          + container_path = "/etc/nginx/conf.d/app.conf"
          + host_path      = "/Users/ruan/personal/terraform-playground/docker-containers/configs/app.conf"
        }
      + volumes {
          + container_path = "/etc/nginx/nginx.conf"
          + host_path      = "/Users/ruan/personal/terraform-playground/docker-containers/configs/nginx.conf"
        }
      + volumes {
          + container_path = "/usr/share/nginx/html"
          + host_path      = "/Users/ruan/personal/terraform-playground/docker-containers/html"
        }
    }

  # docker_container.traefik will be created
  + resource "docker_container" "traefik" {
      + attach                = false
      + bridge                = (known after apply)
      + command               = [
          + "--api",
          + "--docker",
          + "--docker.watch",
          + "--entrypoints=Name:http Address::80",
          + "--logLevel=INFO",
        ]
      + container_logs        = (known after apply)
      + destroy_grace_seconds = 30
      + entrypoint            = (known after apply)
      + env                   = (known after apply)
      + exit_code             = (known after apply)
      + gateway               = (known after apply)
      + hostname              = (known after apply)
      + id                    = (known after apply)
      + image                 = "traefik:1.7.14"
      + init                  = (known after apply)
      + ip_address            = (known after apply)
      + ip_prefix_length      = (known after apply)
      + ipc_mode              = (known after apply)
      + log_driver            = "json-file"
      + logs                  = false
      + memory                = 256
      + must_run              = true
      + name                  = "traefik"
      + network_data          = (known after apply)
      + read_only             = false
      + remove_volumes        = true
      + restart               = "unless-stopped"
      + rm                    = false
      + security_opts         = (known after apply)
      + shm_size              = (known after apply)
      + start                 = true
      + stdin_open            = false
      + tty                   = false

      + healthcheck {
          + interval     = (known after apply)
          + retries      = (known after apply)
          + start_period = (known after apply)
          + test         = (known after apply)
          + timeout      = (known after apply)
        }

      + labels {
          + label = "traefik.docker.network"
          + value = "docknet"
        }
      + labels {
          + label = "traefik.enable"
          + value = "true"
        }
      + labels {
          + label = "traefik.frontend.rule"
          + value = "Host:traefik.localdns.xyz"
        }
      + labels {
          + label = "traefik.port"
          + value = "8080"
        }

      + networks_advanced {
          + aliases = [
              + "docknet",
            ]
          + name    = "docknet"
        }

      + ports {
          + external = 80
          + internal = 80
          + ip       = "0.0.0.0"
          + protocol = "tcp"
        }

      + volumes {
          + container_path = "/var/run/docker.sock"
          + host_path      = "/var/run/docker.sock"
        }
    }

  # docker_image.nginx will be created
  + resource "docker_image" "nginx" {
      + id          = (known after apply)
      + latest      = (known after apply)
      + name        = "nginx:stable-alpine"
      + output      = (known after apply)
      + repo_digest = (known after apply)
    }

  # docker_image.traefik will be created
  + resource "docker_image" "traefik" {
      + id          = (known after apply)
      + latest      = (known after apply)
      + name        = "traefik:1.7.14"
      + output      = (known after apply)
      + repo_digest = (known after apply)
    }

  # docker_network.nginx will be created
  + resource "docker_network" "nginx" {
      + driver      = "bridge"
      + id          = (known after apply)
      + internal    = (known after apply)
      + ipam_driver = "default"
      + name        = "docknet"
      + options     = (known after apply)
      + scope       = (known after apply)

      + ipam_config {
          + aux_address = (known after apply)
          + gateway     = (known after apply)
          + ip_range    = (known after apply)
          + subnet      = (known after apply)
        }
    }

  # random_string.nginx will be created
  + resource "random_string" "nginx" {
      + id          = (known after apply)
      + length      = 8
      + lower       = true
      + min_lower   = 0
      + min_numeric = 0
      + min_special = 0
      + min_upper   = 0
      + number      = true
      + result      = (known after apply)
      + special     = false
      + upper       = false
    }

Plan: 6 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + nginx_container_name   = "nginx"
  + nginx_url              = (known after apply)
  + traefik_container_name = "traefik"
  + traefik_url            = "http://traefik.localdns.xyz/"
</code></pre>

<p>Which we can see will create 2 containers, traefik and then nginx, map the configs and html in place and also sets the traefik hostname in the labels for our respective containers so that we can reach them via the specific host headers.</p>

<p>The we can deploy our containers:</p>

<pre><code>terraform apply -auto-approve
</code></pre>

<p>Which will provide us the output detail defined from our <code>outputs.tf</code>:</p>

<pre><code>Apply complete! Resources: 6 added, 0 changed, 0 destroyed.

Outputs:

nginx_container_name = "nginx"
nginx_url = "http://www.5igjdfq9.localdns.xyz/"
traefik_container_name = "traefik"
traefik_url = "http://traefik.localdns.xyz/"
</code></pre>

<h2>Access our Containers</h2>

<p>We can access our Traefik Dashboard on <a href="http://traefik.localdns.xyz">http://traefik.localdns.xyz</a> and should look something like this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/143064031-23e9dbe4-522b-4f11-96f9-f30a2104ee44.png" alt="image" /></p>

<p>And when we access our Nginx container on <a href="http://www.5igjdfq9.localdns.xyz">http://www.5igjdfq9.localdns.xyz</a> it should look more or less like this:</p>

<p><img src="https://user-images.githubusercontent.com/567298/143064228-88107b75-31fc-41eb-aee0-f26ff976c42a.png" alt="image" /></p>

<p>Running a <code>docker ps</code> will show our running containers:</p>

<pre><code>docker ps
CONTAINER ID   IMAGE                  COMMAND                  CREATED         STATUS                PORTS                NAMES
e45158ae8cba   nginx:stable-alpine    "/docker-entrypoint   3 minutes ago   Up 3 minutes          80/tcp               nginx
ebdbe42a0fcb   traefik:1.7.14         "/traefik --api       3 minutes ago   Up 3 minutes          0.0.0.0:80-&gt;80/tcp   traefik
</code></pre>

<h2>Cleanup</h2>

<p>We can delete our containers by running:</p>

<pre><code>terraform destroy -auto-approve
</code></pre>

<h2>Thank You</h2>

<p>Thanks for reading, if you like my content, check out my <strong><a href="https://ruan.dev">website</a></strong> or follow me at <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong> on Twitter.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Traefik Version 2 on Docker]]></title>
    <link href="https://blog.ruanbekker.com/blog/2021/11/03/setup-traefik-version-2-on-docker/"/>
    <updated>2021-11-03T01:20:27-04:00</updated>
    <id>https://blog.ruanbekker.com/blog/2021/11/03/setup-traefik-version-2-on-docker</id>
    <content type="html"><![CDATA[<p>In this tutorial we will be setting up <a href="https://traefik.io">Traefik </a> v2 as our reverse proxy with port 80 and 443 enabled, and then hook up a example application behind the application load balancer, and route incoiming requests via host headers.</p>

<h2>What is Traefik</h2>

<p>Traefik is a modern HTTP reverse proxy and load balancer that makes deploying microservices super easy by making use of docker labels to route your traffic based on host headers, path prefixes etc. Please check out <a href="https://doc.traefik.io/traefik/">their website</a> to find out more about them.</p>

<h2>Use Case</h2>

<p>In our example we want to route traefik from <code>http://app.selfhosted.co.za</code> to hit our proxy on port 80, then we want traefik to redirect port 80 to the 443 port configured on the proxy which is configured with letsencrypt and reverse proxy the connection to our application.</p>

<p>The application is being configured via docker labels, which we will get into later.</p>

<h2>Our Environment</h2>

<p>I will be using the domain <code>selfhosted.co.za</code>, so if you are following along, you can just replace this domain with yours.</p>

<p>For this demonstration I have spun up a VM at <a href="https://civo.com">Civo</a> as you can see below:</p>

<p><img src="https://user-images.githubusercontent.com/567298/125192278-5023a200-e247-11eb-97c6-cebd65f22f07.png" alt="image" /></p>

<p>From the provided public IP address, we will be creating a DNS A record for our domain, and then create a wildcard entry to CNAME to our initial dns name:</p>

<p><img src="https://user-images.githubusercontent.com/567298/125192297-6b8ead00-e247-11eb-9c01-740557838a12.png" alt="image" /></p>

<p>You might not want to point all the subdomains to that entry, but to simplify things, every application that needs to be routed via traefik, I can manage from a traefik config level, since my dns is already pointing to the public ip where traefik is running on.</p>

<p>So if I spin up a new container, lets say <code>bitwarden</code>, I can just set <code>bitwarden.selfhosted.co.za</code> in the labels of that container and due to the dns already pointing to traefik, traefik will route the connection to the correct container.</p>

<h2>Pre-Requisites</h2>

<p>In order to follow along you will need <a href="https://docs.docker.com/get-docker/">docker</a> and <a href="https://docs.docker.com/compose/install/">docker-compose</a> to be installed, and can be validated using:</p>

<pre><code>docker -v
Docker version 20.10.7, build f0df350

docker-compose -v
docker-compose version 1.28.6, build 5db8d86f
</code></pre>

<h2>Traefik on Docker</h2>

<p>We will have one <code>docker-compose.yml</code> file which has the proxy and the example application. Be sure to change the following to suite your environment:
- <code>traefik.http.routers.api.rule=Host()'</code>
- <code>--certificatesResolvers.letsencrypt.acme.email=youremail@yourdomain.net</code></p>

<p>The compose:</p>

<pre><code class="yaml">---
version: '3.8'

services:
  traefik:
    image: traefik:2.4
    container_name: traefik
    restart: unless-stopped
    volumes:
      - ./traefik/acme.json:/acme.json
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - docknet
    labels:
      - 'traefik.enable=true'
      - 'traefik.http.routers.api.rule=Host(`traefik.selfhosted.co.za`)'
      - 'traefik.http.routers.api.entrypoints=https'
      - 'traefik.http.routers.api.service=api@internal'
      - 'traefik.http.routers.api.tls=true'
      - 'traefik.http.routers.api.tls.certresolver=letsencrypt'
    ports:
      - 80:80
      - 443:443
    command:
      - '--api'
      - '--providers.docker=true'
      - '--providers.docker.exposedByDefault=false'
      - '--entrypoints.http=true'
      - '--entrypoints.http.address=:80'
      - '--entrypoints.http.http.redirections.entrypoint.to=https'
      - '--entrypoints.http.http.redirections.entrypoint.scheme=https'
      - '--entrypoints.https=true'
      - '--entrypoints.https.address=:443'
      - '--certificatesResolvers.letsencrypt.acme.email=youremail@yourdomain.net'
      - '--certificatesResolvers.letsencrypt.acme.storage=acme.json'
      - '--certificatesResolvers.letsencrypt.acme.httpChallenge.entryPoint=http'
      - '--log=true'
      - '--log.level=INFO'
    logging:
      driver: "json-file"
      options:
        max-size: "1m"

  webapp:
    image: traefik/whoami
    container_name: webapp
    restart: unless-stopped
    networks:
      - docknet
    labels:
      - 'traefik.enable=true'
      - 'traefik.http.routers.webapp.rule=Host(`app.selfhosted.co.za`)'
      - 'traefik.http.routers.webapp.entrypoints=https'
      - 'traefik.http.routers.webapp.tls=true'
      - 'traefik.http.routers.webapp.tls.certresolver=letsencrypt'
      - 'traefik.http.routers.webapp.service=webappservice'
      - 'traefik.http.services.webappservice.loadbalancer.server.port=80'
    logging:
      driver: "json-file"
      options:
        max-size: "1m"

networks:
  docknet:
    name: docknet
</code></pre>

<p>Prepare the <code>./traefik/acme.json</code> file:</p>

<pre><code>mkdir traefik
touch traefik/acme.json
chmod 600 traefik/acme.json
</code></pre>

<p>As you can see in order to wire a application onto the proxy we need the following labels:</p>

<pre><code class="yaml">      - 'traefik.enable=true'
      - 'traefik.http.routers.webapp.rule=Host(`app.selfhosted.co.za`)'
      - 'traefik.http.routers.webapp.entrypoints=https'
      - 'traefik.http.routers.webapp.tls=true'
      - 'traefik.http.routers.webapp.tls.certresolver=letsencrypt'
      - 'traefik.http.routers.webapp.service=webappservice'
      - 'traefik.http.services.webappservice.loadbalancer.server.port=80'
</code></pre>

<p>Now boot our stack using docker-compose:</p>

<pre><code class="bash">docker-compose up -d
</code></pre>

<p>You can follow the logs to ensure everything works as expected:</p>

<pre><code>docker-compose logs -f
Attaching to webapp, traefik
traefik    | time="2021-07-11T11:02:22Z" level=info msg="Configuration loaded from flags."
traefik    | time="2021-07-11T11:02:22Z" level=info msg="Starting provider aggregator.ProviderAggregator {}"
traefik    | time="2021-07-11T11:02:22Z" level=info msg="Starting provider *traefik.Provider {}"
traefik    | time="2021-07-11T11:02:22Z" level=info msg="Starting provider *docker.Provider {\"watch\":true,\"endpoint\":\"unix:///var/run/docker.so                                              ck\",\"defaultRule\":\"Host(``)\",\"swarmModeRefreshSeconds\":\"15s\"}"
traefik    | time="2021-07-11T11:02:22Z" level=info msg="Starting provider *acme.ChallengeTLSALPN {\"Timeout\":4000000000}"
traefik    | time="2021-07-11T11:02:22Z" level=info msg="Starting provider *acme.Provider {\"email\":\"youremail@domain.com\",\"caServer\":\"https://                                              acme-v02.api.letsencrypt.org/directory\",\"storage\":\"acme.json\",\"keyType\":\"RSA4096\",\"httpChallenge\":{\"entryPoint\":\"http\"},\"ResolverNam                                              e\":\"letsencrypt\",\"store\":{},\"TLSChallengeProvider\":{\"Timeout\":4000000000},\"HTTPChallengeProvider\":{}}"
traefik    | time="2021-07-11T11:02:22Z" level=info msg="Testing certificate renew..." providerName=letsencrypt.acme
traefik    | time="2021-07-11T11:02:24Z" level=info msg=Register... providerName=letsencrypt.acme
webapp     | Starting up on port 80
</code></pre>

<p>The certificate process might take anything from 5-30s in my experience.</p>

<h2>Test the Application</h2>

<p>Now that our <code>webapp</code> container is running, make a http request using curl against the configured host rule, which is <code>app.selfhosted.co.za</code> on <code>http</code> so that we can validate if traefik is doing a redirect to <code>https</code>:</p>

<pre><code class="bash">curl -IL http://app.selfhosted.co.za:80

HTTP/1.1 308 Permanent Redirect
Location: https://app.selfhosted.co.za/
Date: Sun, 11 Jul 2021 11:05:47 GMT
Content-Length: 18
Content-Type: text/plain; charset=utf-8

HTTP/2 200
content-type: text/plain; charset=utf-8
date: Sun, 11 Jul 2021 11:05:47 GMT
content-length: 343
</code></pre>

<p>If we access our <code>webapp</code> service in our web browser, we will see the following:</p>

<p><img src="https://user-images.githubusercontent.com/567298/125192768-c1fceb00-e249-11eb-8b67-7347b4d16a8f.png" alt="image" /></p>

<p>We can also validate that the certificate is valid:</p>

<p><img src="https://user-images.githubusercontent.com/567298/125196546-a9490100-e25a-11eb-8e94-0d7af307d2fb.png" alt="image" /></p>

<p>We can also access the traefik dashboard using the configured domain, in this case <code>traefik.selfhosted.co.za</code>, and you should see the pretty traefik dashboard:</p>

<p><img src="https://user-images.githubusercontent.com/567298/125196448-4bb4b480-e25a-11eb-906b-a221d1415f38.png" alt="image" /></p>

<h2>Future Posts</h2>

<p>In future posts I will be using this post as the base setup on getting traefik up and running, and future posts that uses traefik will be tagged under <a href="https://containers.fan/tags/traefik/">#traefik</a>.</p>

<h2>Thank You</h2>

<p>Thanks for reading, if you like my content, check out my <strong><a href="https://ruan.dev">website</a></strong> or follow me at <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong> on Twitter.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Traefik Ingress for OpenFaas on Kubernetes (K3d)]]></title>
    <link href="https://blog.ruanbekker.com/blog/2020/02/17/traefik-ingress-for-openfaas-on-kubernetes-k3d/"/>
    <updated>2020-02-17T23:36:33+02:00</updated>
    <id>https://blog.ruanbekker.com/blog/2020/02/17/traefik-ingress-for-openfaas-on-kubernetes-k3d</id>
    <content type="html"><![CDATA[<p>In this post we will deploy <a href="https://www.openfaas.com/">OpenFaas</a> on Kubernetes locally using <a href="https://github.com/alexellis/k3sup">k3sup</a> and <a href="https://github.com/rancher/k3d">k3d</a>, then deploy a Traefik Ingress so that we can access the OpenFaas Gateway on HTTP over the standard port 80.</p>

<p>K3d is a amazing wrapper that deploys a k3s cluster on docker, and k3sup makes it very easy to provision OpenFaas to your Kubernetes cluster.</p>

<h2>Deploy a Kubernetes Cluster</h2>

<p>If you have not installed k3d, you can install k3d on mac with brew:</p>

<pre><code>$ brew install k3d
</code></pre>

<p>We will deploy our cluster with 2 worker nodes and publish port 80 to the containers port 80:</p>

<pre><code>$ k3d create --name="demo" --workers="2" --publish="80:80"
</code></pre>

<p>Point the kubeconfig to the location that k3d generated:</p>

<pre><code>$ export KUBECONFIG="$(k3d get-kubeconfig --name='demo')"
</code></pre>

<h2>Deploy OpenFaas</h2>

<p>First we need to get k3sup:</p>

<pre><code>$ curl -sLfS https://get.k3sup.dev | sudo sh
</code></pre>

<p>Once k3sup is installed, deploy OpenFaas to your cluster:</p>

<pre><code>$ k3sup app install openfaas
</code></pre>

<p>Give it a minute or so and check if everything is running:</p>

<pre><code>$ kubectl get pods -n openfaas
NAMESPACE     NAME                                 READY   STATUS      RESTARTS   AGE
openfaas      alertmanager-546f66b6c6-qtb69        1/1     Running     0          5m
openfaas      basic-auth-plugin-79b9878b7b-7vlln   1/1     Running     0          4m59s
openfaas      faas-idler-db8cd9c7d-8xfpp           1/1     Running     2          4m57s
openfaas      gateway-7dcc6d694d-dmvqn             2/2     Running     0          4m56s
openfaas      nats-d6d574749-rt9vw                 1/1     Running     0          4m56s
openfaas      prometheus-d99669d9b-mfxc8           1/1     Running     0          4m53s
openfaas      queue-worker-75f44b56b9-mhhbv        1/1     Running     0          4m52s
</code></pre>

<h2>Traefik Ingress</h2>

<p>In my scenario, I am using <code>openfaas.localdns.xyz</code> which resolves to <code>127.0.0.1</code>. Next we need to know to which service to route the traffic to, we can find that by:</p>

<pre><code>$ kubectl get svc/gateway -n openfaas
NAME      TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
gateway   ClusterIP   10.43.174.57   &lt;none&gt;        8080/TCP   23m
</code></pre>

<p>Below is our ingress.yml:</p>

<pre><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: openfaas-gateway-ingress
  namespace: openfaas
  annotations:
    kubernetes.io/ingress.class: traefik
spec:
  rules:
  - host: openfaas.localdns.xyz
    http:
      paths:
      - backend:
          serviceName: gateway
          servicePort: 8080
</code></pre>

<p>Apply the ingress:</p>

<pre><code>$ kubectl apply -f ingress.yml
ingress.extensions/openfaas-gateway-ingress created
</code></pre>

<p>We can the verify that our ingress is visible:</p>

<pre><code>$ kubectl get ingress -n openfaas
NAMESPACE   NAME                       HOSTS               ADDRESS      PORTS   AGE
openfaas    openfaas-gateway-ingress   openfaas.co.local   172.25.0.4   80      28s
</code></pre>

<h2>OpenFaas CLI</h2>

<p>Install the OpenFaas CLI:</p>

<pre><code>$ curl -SLsf https://cli.openfaas.com | sudo sh
</code></pre>

<p>Export the <code>OPENFAAS_URL</code> to our ingress endpoint and <code>OPENFAAS_PREFIX</code> for your dockerhub username:</p>

<pre><code>$ export OPENFAAS_URL=http://openfaas.localdns.xyz
$ export OPENFAAS_PREFIX=ruanbekker # change to your username
</code></pre>

<p>Get your credentials for the OpenFaas Gateway and login with the OpenFaas CLI:</p>

<pre><code>$ PASSWORD=$(kubectl get secret -n openfaas basic-auth -o jsonpath="{.data.basic-auth-password}" | base64 --decode; echo)
$ echo -n $PASSWORD | faas-cli login --username admin --password-stdin
</code></pre>

<h2>Deploy a Function</h2>

<p>Deploy the figlet function as an example:</p>

<pre><code>$ faas-cli store deploy figlet

Deployed. 202 Accepted.
URL: http://openfaas.localdns.xyz/function/figlet
</code></pre>

<p>Invoke the function:</p>

<pre><code>$ curl http://openfaas.localdns.xyz/function/figlet -d 'hello, world'
 _          _ _                             _     _
| |__   ___| | | ___    __      _____  _ __| | __| |
| '_ \ / _ \ | |/ _ \   \ \ /\ / / _ \| '__| |/ _` |
| | | |  __/ | | (_) |   \ V  V / (_) | |  | | (_| |
|_| |_|\___|_|_|\___( )   \_/\_/ \___/|_|  |_|\__,_|
                    |/
</code></pre>

<h2>Delete the Cluster</h2>

<p>Delete your k3d Kubernetes Cluster:</p>

<pre><code>$ k3d delete --name demo
</code></pre>

<h2>Thank You</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Integrating Google OAuth With Traefik]]></title>
    <link href="https://blog.ruanbekker.com/blog/2019/11/10/integrating-google-oauth-with-traefik/"/>
    <updated>2019-11-10T20:03:06+02:00</updated>
    <id>https://blog.ruanbekker.com/blog/2019/11/10/integrating-google-oauth-with-traefik</id>
    <content type="html"><![CDATA[<p><a href="https://saythanks.io/to/ruanbekker"><img src="https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg" alt="Say Thanks!" /></a> <a href="https://linux-hackers-slack.herokuapp.com/"><img src="https://linux-hackers-slack.herokuapp.com/badge.svg" alt="Slack Status" /></a> <a href="https://linux-hackers.slack.com/"><img src="https://img.shields.io/badge/chat-on_slack-orange.svg" alt="Chat on Slack" /></a> <a href="https://github.com/ruanbekker"><img src="https://img.shields.io/github/followers/ruanbekker.svg?label=Follow&amp;style=social" alt="GitHub followers" /></a></p>

<p><a href="https://twitter.com/ruanbekker?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @ruanbekker</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>I stumbled upon a really cool <a href="https://github.com/thomseddon/traefik-forward-auth">project: Traefik Forward Auth</a> that provides Google OAuth based Login and Authentication for <a href="https://traefik.io/">Traefik</a></p>

<p>This means that you can secure your Traefik backend services by using Google for authentication to access your backends. Authorizing who can logon, get&rsquo;s managed on the forward proxy.</p>

<p>If you have not worked with Traefik, Traefik is one amazing dynamic and modern reverse proxy / load balancer built for micro services.</p>

<h2>What are we doing today</h2>

<p>In this demonstration we will setup a new google application, setup the forward-auth proxy and spin up a service that we will use google to authenticate against to access our application on Docker Swarm.</p>

<p>Step by step tutorial has been published on my sysadmins blog, <strong><a href="https://sysadmins.co.za/integrating-google-oauth-with-traefik/?referral=blog.ruanbekker.com">read more here</a></strong></p>

<p><a href="https://sysadmins.co.za/integrating-google-oauth-with-traefik/?referral=blog.ruanbekker.com"><img src="https://user-images.githubusercontent.com/567298/68548655-10644180-03f8-11ea-96fe-47f01b1dd635.png" alt="" /></a></p>

<h2>Thank You</h2>

<p>Let me know what you think. If you liked my content, feel free to checkout my content on <strong><a href="https://ruan.dev/">ruan.dev</a></strong> or follow me on twitter at <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong></p>

<center><script type='text/javascript' src='https://ko-fi.com/widgets/widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Buy Me a Coffee', '#46b798', 'A6423ZIQ');kofiwidget2.draw();</script></center>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy Traefik Using Bekker Stacks]]></title>
    <link href="https://blog.ruanbekker.com/blog/2019/09/04/deploy-traefik-using-bekker-stacks/"/>
    <updated>2019-09-04T21:46:35+02:00</updated>
    <id>https://blog.ruanbekker.com/blog/2019/09/04/deploy-traefik-using-bekker-stacks</id>
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/50801771/64287218-67b0e600-cf5f-11e9-8fe7-f36cb8e71f6f.png" alt="image" /></p>

<p><a href="https://saythanks.io/to/ruanbekker"><img src="https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg" alt="Say Thanks!" /></a> <a href="https://linux-hackers-slack.herokuapp.com/"><img src="https://linux-hackers-slack.herokuapp.com/badge.svg" alt="Slack Status" /></a> <a href="https://linux-hackers.slack.com/"><img src="https://img.shields.io/badge/chat-on_slack-orange.svg" alt="Chat on Slack" /></a> <a href="https://github.com/bekkerstacks/traefik"><img src="https://img.shields.io/github/followers/ruanbekker.svg?label=Follow&amp;style=social" alt="GitHub followers" /></a></p>

<p><a href="https://twitter.com/ruanbekker?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @ruanbekker</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>After a year or two spending quite a lot of time into docker and more specifically docker swarm, I found it quite tedious to write up docker-compose files for specific stacks that you are working on. I also felt the need for a docker swarm compose package manager.</p>

<p>Fair enough, you store them on a central repository and then you can reuse them as you go, and that is exactly what I did, but I felt that perhaps other people have the same problem.</p>

<h2>The Main Idea</h2>

<p>So the main idea is to have a central repository with docker swarm stacks, that you can pick and choose what you want, pull down the repository and use environment variables to override the default configuration and use the deploy script to deploy the stack that you want.</p>

<h2>Future Ideas</h2>

<p>In the future I would like to create a cli tool that you can use to list stacks, as example:</p>

<pre><code>$ bstacks list
traefik
monitoring-cpang (cAdvisor, Prometheus, Alertmanager, Node-Exporter, Grafana)
monitoring-tig   (Telegraf, InfluxDB, Grafana)
logging-efk      (Elasticsearch, Filebeat, Kibana)
...
</code></pre>

<p>Listing stacks by category:</p>

<pre><code>$ bstacks list --category logging
logging-efk
...
</code></pre>

<p>Deploying a stack:</p>

<pre><code>$ bstacks deploy --stack traefik --stack-name proxy --env-file ./stack.env
Username for Traefik UI: ruan
Password for Traefik UI: deploying traefik stack in http mode
Creating network public
Creating config proxy_traefik_htpasswd
Creating service proxy_traefik
Traefik UI is available at:
- http://traefik.localhost
</code></pre>

<p>At the time of writing the cli tool is not available yet, but the list of available templated docker stack repositories are availabe at <a href="https://github.com/bekkerstacks?tab=repositories">github.com/bekkerstacks</a></p>

<h2>What are we doing today</h2>

<p>In this tutorial we will deploy a <a href="https://github.com/bekkerstacks/traefik">Traefik</a> proxy on Docker Swarm. I will be demonstrating the deployment on my Mac, and currently I have only docker installed, without a swarm being initialized.</p>

<p>If you already have a swarm initialized and running this on servers, you can skip the local dev section.</p>

<h2>Local Dev</h2>

<p>We will be initializing a 3 node docker swarm on a mac using docker-in-docker. Get the repository:</p>

<pre><code>$ git clone https://github.com/bekkerstacks/docker-swarm
</code></pre>

<p>Switch to the directory and deploy the swarm:</p>

<pre><code>$ bash deploy.sh

ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
lkyjkvuc5uobzgps4m7e98l0u *   docker-desktop      Ready               Active              Leader              19.03.1
6djgz804emj89rs8icd53wfgn     worker-1            Ready               Active                                  18.06.3-ce
gcz6ou0s5p8kxve63ihnky7ai     worker-2            Ready               Active                                  18.06.3-ce
ll8zfvuaek8q4x9nlijib0dfa     worker-3            Ready               Active                                  18.06.3-ce
</code></pre>

<p>As you can see we have a 4 node docker swarm running on our local dev environment to continue.</p>

<h2>Deploy Traefik</h2>

<p>To deploy traefik in HTTPS mode, we need to set 3 environment variables: <code>EMAIL</code>, <code>DOMAIN</code>, <code>PROTOCOL</code>. We also need to setup our DNS to direct traefik to our swarm. In my case I will be using <code>1.2.3.4</code> as the IP of my Manager node and using the domain <code>mydomain.com</code></p>

<p>The DNS setup will look like this:</p>

<pre><code>A Record: mydomain.com -&gt; 1.1.1.1
A Record: *.mydomain.com -&gt; 1.1.1.1
</code></pre>

<p>And if you are using this locally, you can setup your <code>/etc/hosts</code> to <code>127.0.0.1 traefik.mydomain.com</code></p>

<p>Clone the repository:</p>

<pre><code>$ git clone https://github.com/bekkerstacks/traefik
</code></pre>

<p>Change the the repository and deploy the stack:</p>

<pre><code>$ EMAIL=me@mydomain.com DOMAIN=mydomain.com PROTOCOL=https bash deploy.sh
Username for Traefik UI: ruan
Password for Traefik UI: deploying traefik stack in https mode
Creating network public
Creating config proxy_traefik_htpasswd
Creating service proxy_traefik
Traefik UI is available at:
- https://traefik.mydomain.com
</code></pre>

<p>Verify that the Traefik service is running:</p>

<pre><code>$ docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
0wga71zbx1pe        proxy_traefik       replicated          1/1                 traefik:1.7.14      *:80-&gt;80/tcp
</code></pre>

<p>Navigating to the Traefik Dashboard, after providing your username and password, you should see the Traefik UI:</p>

<p><img src="https://user-images.githubusercontent.com/50801771/64284457-eefb5b00-cf59-11e9-90cb-eeb2b417c80c.png" alt="" /></p>

<p>Note: I don&rsquo;t own mydomain.com therefore I am using the traefik default cert, that will be why it&rsquo;s showing not secure.</p>

<h2>Deploy Traefik in HTTP Mode</h2>

<p>If you want to deploy Traefik in HTTP mode rather, you would use:</p>

<pre><code>$ DOMAIN=localhost PROTOCOL=http bash deploy.sh
Username for Traefik UI: ruan
Password for Traefik UI: deploying traefik stack in http mode
Creating network public
Creating config proxy_traefik_htpasswd
Creating service proxy_traefik
Traefik UI is available at:
- http://traefik.localhost
</code></pre>

<p>Navigating to the Traefik Dashboard, after providing your username and password, you should see the Traefik UI:</p>

<p><img src="https://user-images.githubusercontent.com/50801771/64283759-56b0a680-cf58-11e9-9f85-6721ab3b1500.png" alt="" /></p>

<h2>More Info</h2>

<p>In future posts, I will demonstrate how to deploy other stacks using bekkerstacks.</p>

<p>Have a look at the repositories on github for more info:</p>

<ul>
<li><a href="https://github.com/bekkerstacks">https://github.com/bekkerstacks</a></li>
<li><a href="https://github.com/bekkerstacks/docker-swarm">https://github.com/bekkerstacks/docker-swarm</a></li>
<li><a href="https://github.com/bekkerstacks/traefik">https://github.com/bekkerstacks/traefik</a></li>
</ul>


<h2>Thank You</h2>

<p>Let me know what you think. If you liked my content, feel free to checkout my content on <strong><a href="https://ruan.dev/">ruan.dev</a></strong> or follow me on twitter at <strong><a href="https://twitter.com/ruanbekker">@ruanbekker</a></strong></p>

<p><a href="https://twitter.com/ruanbekker?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @ruanbekker</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
]]></content>
  </entry>
  
</feed>
