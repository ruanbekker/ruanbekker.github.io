<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ubuntu | Ruan Bekker's Blog]]></title>
  <link href="http://blog.ruanbekker.com/blog/categories/ubuntu/atom.xml" rel="self"/>
  <link href="http://blog.ruanbekker.com/"/>
  <updated>2018-05-09T18:13:55-04:00</updated>
  <id>http://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Create a Logical Volume Using LVM on Ubuntu]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/03/30/create-a-logical-volume-using-lvm-on-ubuntu/"/>
    <updated>2018-03-30T20:38:18-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/03/30/create-a-logical-volume-using-lvm-on-ubuntu</id>
    <content type="html"><![CDATA[<p>Logical Volume Manager (LVM) - adds an extra layer between the physical disks and the file system, which allows you to resize your storage on the fly, use multiple disks, instead of one, etc.</p>

<h2>Concepts:</h2>

<p>Physical Volume:
- Physical Volume represents the actual disk / block device.</p>

<p>Volume Group:
- Volume Groups combines the collection of Logical Volumes and Physical Volumes into one administrative unit.</p>

<p>Logical Volume:
- A Logical Volume is the conceptual equivalent of a disk partition in a non-LVM system.</p>

<p>File Systems:
- File systems are built on top of logical volumes.</p>

<h2>What we are doing today:</h2>

<p>We have a disk installed on our server which is 150GB that is located on <code>/dev/vdb</code>, which we will manage via LVM and will be mounted under <code>/mnt</code></p>

<h2>Dependencies:</h2>

<p>Update and Install LVM:</p>

<pre><code>$ apt update &amp;&amp; apt upgrade -y
$ apt install lvm2 -y
$ systemctl enable lvm2-lvmetad
$ systemctl start lvm2-lvmetad
</code></pre>

<h2>Create the Logical Volume:</h2>

<p>Initialize the Physical Volume to be managed by LVM, then create the Volume Group, then go ahead to create the Logical Volume:</p>

<pre><code>$ pvcreate /dev/vdb
$ vgcreate vg1 /dev/vdb
$ lvcreate -l 100%FREE -n vol1 vg1
</code></pre>

<p>Build the Linux Filesystem with ext4 and mount the volume to the <code>/mnt</code> partition:</p>

<pre><code>$ mkfs.ext4 /dev/vg1/vol1
$ mount /dev/vg1/vol1 /mnt
$ echo '/dev/mapper/vg1-vol1 /mnt ext4 defaults,nofail 0 0' &gt;&gt; /etc/fstab
</code></pre>

<h2>Other useful commands:</h2>

<p>To list Physical Volume Info:</p>

<pre><code>$ pvs
PV         VG   Fmt  Attr PSize   PFree
/dev/vdb   vg1  lvm2 a--  139.70g    0
</code></pre>

<p>To list Volume Group Info:</p>

<pre><code>$ vgs
VG   #PV #LV #SN Attr   VSize   VFree
vg1    1   1   0 wz--n- 139.70g    0
</code></pre>

<p>And viewing the logical volume size from the volume group:</p>

<pre><code>$ vgs -o +lv_size,lv_name
VG   #PV #LV #SN Attr   VSize   VFree LSize   LV
vg1    1   1   0 wz--n- 139.70g    0  139.70g vol1
</code></pre>

<p>Information about Logical Volumes:</p>

<pre><code>$ lvs
LV   VG   Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
vol1 vg1  -wi-ao---- 139.70g
</code></pre>

<h2>Resources:</h2>

<ul>
<li><a href="https://www.thegeekdiary.com/redhat-centos-a-beginners-guide-to-lvm-logical-volume-manager/">1</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Payara Application Server on Ubuntu 16.04]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/03/29/setup-payara-application-server-on-ubuntu-16-dot-04/"/>
    <updated>2018-03-29T19:57:40-04:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/03/29/setup-payara-application-server-on-ubuntu-16-dot-04</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/CJMlTj.jpg" alt="" /></p>

<p>Today we will setup Payara 5 on Ubuntu 16.04</p>

<h2>About:</h2>

<p>Payara is an Open Source Java Application Server.</p>

<h2>Pre-Requirements:</h2>

<p>Update and Install Java 8:</p>

<pre><code class="bash">$ apt update &amp;&amp; apt upgrade -y
$ apt-get install wget curl unzip software-properties-common python-software-properties -y
$ add-apt-repository ppa:webupd8team/java
$ apt-get update
$ apt-get install oracle-java8-installer -y
$ source /etc/profile.d/jdk.sh
</code></pre>

<h2>Install Payara:</h2>

<p>Download and Install Payara 5:</p>

<pre><code class="bash">$ cd /usr/local
$ wget --content-disposition 'https://info.payara.fish/cs/c/?cta_guid=b9609f35-f630-492f-b3c0-238fc55f489b&amp;placement_guid=7cca6202-06a3-4c29-aee0-ca58af60528a&amp;portal_id=334594&amp;redirect_url=APefjpGt1aFvHUflpzz7Lec8jDz7CbeIIHZmgORmDSpteTCT2XjiMvjEzeY8yte3kiHi7Ph9mWDB7qUDEr96P0JS8Ev2ZFqahif2huSBfQV6lt4S6YUQpzPMrpHgf_n4VPV62NjKe8vLZBLnYkUALyR2mkrU3vWe7ME9XjHJqYPsHtxkHn-W7bYPFgY2LjEzKIYrdUsCviMgGrUh_LIbLxCESBa0N90vzaWKjK5EwZT021VaPP0jgfgvt0gF2UdtBQGcsTHrAlrb&amp;hsutk=c279766888b67917a591ec4e209cb29a&amp;canon=https%3A%2F%2Fwww.payara.fish%2Fall_downloads&amp;click=5bad781c-f4f5-422d-ba2b-5e0c2bff7098&amp;utm_referrer=https%3A%2F%2Fwww.google.co.za%2F&amp;__hstc=229474563.c279766888b67917a591ec4e209cb29a.1519832301251.1521408251653.1521485598794.4&amp;__hssc=229474563.7.1521485598794&amp;__hsfp=2442083907'

$ unzip payara-5.181.zip
$ mv payara5 payara
$ rm -rf payara-5.181.zip
</code></pre>

<h2>Permissions:</h2>

<p>Create the Payara user and Grant Permissions:</p>

<pre><code class="bash">$ echo 'export PATH=/usr/local/payara/glassfish/bin:$PATH' &gt; /etc/profile.d/payara.sh
$ addgroup --system payara
$ adduser --system --shell /bin/bash --ingroup payara payara
$ echo 'payara soft nofile 32768' &gt;&gt; /etc/security/limits.conf
$ echo 'payara hard nofile 65536' &gt;&gt; /etc/security/limits.conf
$ chown -R payara:payara /usr/local/payara
</code></pre>

<h2>Setup the Payara Domain:</h2>

<p>Switch to the Payara user, delete the default domain and start the production domain. It is useful to configure the JVM Options under the domains config directory according to your servers resources.</p>

<pre><code class="bash">$ su - payara

$ asadmin delete-domain domain1
$ asadmin change-admin-password --domain_name production # default blank pass for admin
$ asadmin --port 4848 enable-secure-admin production

$ asadmin start-domain production
$ asadmin stop-domain production

$ exit
</code></pre>

<h2>SystemD Unit File:</h2>

<p>Create the SystemD Unit File to be able to manage the state of the Payara Server via SystemD:</p>

<pre><code class="bash">$ cat &gt; /etc/systemd/system/payara.service &lt;&lt; EOF
[Unit]
Description=Payara Server
After=network.target remote-fs.target

[Service]
User=payara
WorkingDirectory=/usr/local/payara/glassfish
Environment=PATH=/usr/local/payara/glassfish/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/bin
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/payara/glassfish/bin/asadmin start-domain production
ExecReload=/usr/local/payara/glassfish/bin/asadmin restart-domain production
ExecStop=/usr/local/payara/glassfish/bin/asadmin stop-domain production
TimeoutStartSec=300
TimeoutStopSec=30

[Install]
WantedBy = multi-user.target
EOF
</code></pre>

<p>Reload the systemd daemon:</p>

<pre><code class="bash">$ systemctl daemon-reload
</code></pre>

<p>Start the Payara Service:</p>

<pre><code class="bash">$ systemctl enable payara
$ systemctl start payara
</code></pre>

<p>Verify that port 4848, 8080 and 8181 is running:</p>

<pre><code class="bash">$ netstat -tulpn | grep java
tcp        0      0 :::8080                     :::*                        LISTEN      24542/java
tcp        0      0 :::4848                     :::*                        LISTEN      24542/java
tcp        0      0 :::8181                     :::*                        LISTEN      24542/java
...
</code></pre>

<h2>Access Payara Admin UI:</h2>

<p>Access the Payara DAS via <code>https://ip-of-payara-server:4848</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a KVM Hypervisor on Ubuntu to Host Virtual Machines]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/02/20/setup-a-kvm-hypervisor-on-ubuntu-to-host-virtual-machines/"/>
    <updated>2018-02-20T06:21:56-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/02/20/setup-a-kvm-hypervisor-on-ubuntu-to-host-virtual-machines</id>
    <content type="html"><![CDATA[<p>Today we will setup a KVM (Kernel Virtual Machine) Hypervisor, where we can host Virtual Machines. In order to do so, your host needs to Support Hardware Virtualization.</p>

<h2>What we will be doing today:</h2>

<ul>
<li>Check if your host supports Hardware Virtualization</li>
<li>Setup the KVM Hypervisor</li>
<li>Setup a Alpine VM</li>
</ul>


<h2>Check for Hardware Virtualization Support:</h2>

<p>We will install the package required to do the check:</p>

<pre><code class="bash">$ sudo apt update &amp;&amp; sudo apt install cpu-checker -y
</code></pre>

<p>Once that is installed, run <code>kvm-ok</code> and if its supported, your output should look something like this:</p>

<pre><code class="bash">$ kvm-ok
INFO: /dev/kvm exists
KVM acceleration can be used
</code></pre>

<h2>Installing KVM</h2>

<p>Update your System and get the Packages required to Setup KVM:</p>

<pre><code class="bash">$ sudo apt update &amp;&amp; sudo apt upgrade -y
$ apt install bridge-utils qemu-kvm libvirt-bin virtinst -y
</code></pre>

<p>Add your user to the libvirtd group:</p>

<pre><code class="bash">$ sudo usermod -G libvirtd $USER
</code></pre>

<p>Check that the libvirtd service is running:</p>

<pre><code class="bash">$ sudo systemctl is-active libvirtd
active
</code></pre>

<p>You will also find that there is a new interface configured called <code>virbr0</code> in my case.</p>

<h2>Provision the Alpine VM and Setup OpenSSH:</h2>

<p>Get the ISO:</p>

<ul>
<li><a href="https://alpinelinux.org/downloads/">https://alpinelinux.org/downloads/</a></li>
</ul>


<pre><code class="bash">$ wget http://dl-cdn.alpinelinux.org/alpine/v3.7/releases/x86_64/alpine-virt-3.7.0-x86_64.iso
</code></pre>

<p>Provision the VM:</p>

<pre><code class="bash">$ virt-install \
--name alpine1 \
--ram 256 \
--disk path=/var/lib/libvirt/images/alpine1.img,size=8 \
--vcpus 1 \
--os-type linux \
--os-variant generic \
--network bridge:virbr0,model=virtio \
--graphics none \
--console pty,target_type=serial \
--cdrom ./alpine-virt-3.7.0-x86_64.iso 
</code></pre>

<p>After this, you will be dropped into the console:</p>

<pre><code class="bash">Starting install...
Allocating 'alpine1.img'                                                                                                           |   8 GB  00:00:01
Creating domain...                                                                                                                 |    0 B  00:00:00
Connected to domain alpine1
Escape character is ^]

ISOLINUX 6.04 6.04-pre1  Copyright (C) 1994-2015 H. Peter Anvin et al
boot:

   OpenRC 0.24.1.a941ee4a0b is starting up Linux 4.9.65-1-virthardened (x86_64)

Welcome to Alpine Linux 3.7
Kernel 4.9.65-1-virthardened on an x86_64 (/dev/ttyS0)

localhost login:
</code></pre>

<p>Login with the <code>root</code> user and no password, then setup the VM by running <code>setup-alpine</code>:</p>

<pre><code class="bash">localhost login: root
Welcome to Alpine!

localhost:~# setup-alpine
</code></pre>

<p>After completing the prompts reboot the VM by running <code>reboot</code>, then you will be dropped out of the console. Check the status of the reboot:</p>

<pre><code class="bash">$ virsh list
 Id    Name                           State
----------------------------------------------------
 2     alpine1                        running
</code></pre>

<p>As we can see our guest is running, lets console to our guest, provide the root user and password that you provided during the setup phase:</p>

<pre><code class="bash">$ virsh console 2
Connected to domain alpine1
Escape character is ^]

alpine1 login: root
Password:
Welcome to Alpine!
</code></pre>

<p>Setup OpenSSH so that we can SSH to our guest over the network:</p>

<pre><code class="bash">$ apk update
$ apk add openssh
</code></pre>

<p>Configure SSH to accept Root Passwords, this is not advisable for production environments, but for testing this is okay. For Production servers, we will rather look at Key Based Authentication etc.</p>

<pre><code class="bash">$ sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/g' /etc/ssh/sshd_config
$ /etc/init.d/sshd restart
</code></pre>

<p>Get the IP Address:</p>

<pre><code>$ ifconfig
eth0      Link encap:Ethernet  HWaddr 52:54:00:D0:48:0C
          inet addr:192.168.122.176  Bcast:192.168.122.255  Mask:255.255.255.0
          inet6 addr: fe80::5054:ff:fed0:480c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:55 errors:0 dropped:28 overruns:0 frame:0
          TX packets:34 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:4545 (4.4 KiB)  TX bytes:3345 (3.2 KiB)
</code></pre>

<p>Exit the guest by running <code>exit</code> and <code>Ctrl + ]</code> to exit the console session.</p>

<p>Now SSH to your Alpine VM:</p>

<pre><code class="bash">$ ssh root@192.168.122.176
root@192.168.122.176's password:
Welcome to Alpine!
</code></pre>

<h2>Some Useful Commands:</h2>

<p>List Running VMs:</p>

<pre><code>$ virsh list
 Id    Name                           State
----------------------------------------------------
 3     alpine1                        running
</code></pre>

<p>Shutdown a VM:</p>

<pre><code class="bash">$ virsh shutdown alpine1
Domain alpine1 is being shutdown
</code></pre>

<p>List all VMs:</p>

<pre><code class="bash">$ virsh list --all
 Id    Name                           State
----------------------------------------------------
 -     alpine1                        shut off
</code></pre>

<p>Delete a VM:</p>

<pre><code class="bash">$ virsh shutdown alpine1 #or to force shutdown:
$ virsh destroy alpine1
$ virsh undefine alpine1
</code></pre>

<p>Any future KVM posts will be tagged under <a href="http://blog.ruanbekker.com/blog/categories/kvm?source_site=blog.ruanbekker.com?source_category=kvm">KVM</a> and Alpine posts will be available under the <a href="http://blog.ruanbekker.com/blog/categories/alpine?source_site=blog.ruanbekker.com?source_category=kvm">Alpine</a> tag.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a NFS Server on Ubuntu]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/02/11/setup-a-nfs-server-on-ubuntu/"/>
    <updated>2018-02-11T17:26:56-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/02/11/setup-a-nfs-server-on-ubuntu</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/3sUALo.jpg" alt="" /></p>

<p>Quick post on how to setup a NFS Server on Ubuntu and how to setup the client to interact with the NFS Server.</p>

<h2>Setup the Dependencies:</h2>

<pre><code class="bash">$ apt update &amp;&amp; sudo apt upgrade -y
$ sudo apt-get install nfs-kernel-server nfs-common -y
</code></pre>

<p>Create the Directory for NFS and set permissions:</p>

<pre><code class="bash">mkdir /vol
chown -R nobody:nogroup /vol
</code></pre>

<h2>Allow the Clients:</h2>

<p>We need to set in the <code>exports</code> file, the clients we would like to allow:</p>

<ul>
<li><code>rw</code>: Allows Client R/W Access to the Volume.</li>
<li><code>sync</code>: This option forces NFS to write changes to disk before replying. More stable and Consistent. Note, it does reduce the speed of file operations.</li>
<li><code>no_subtree_check</code>: This prevents subtree checking, which is a process where the host must check whether the file is actually still available in the exported tree for every request. This can cause many problems when a file is renamed while the client has it opened. In almost all cases, it is better to disable subtree checking.</li>
</ul>


<pre><code class="bash">$ echo '/vol 10.8.133.83(rw,sync,no_subtree_check) 10.8.166.19(rw,sync,no_subtree_check) 10.8.142.195(rw,sync,no_subtree_check)' &gt;&gt; /etc/exports
</code></pre>

<h2>Start the NFS Server:</h2>

<p>Restart the service and enable the service on boot:</p>

<pre><code class="bash">$ sudo systemctl restart nfs-kernel-server
$ sudo systemctl enable nfs-kernel-server
</code></pre>

<h2>Client Side:</h2>

<p>We will mount the NFS Volume to our Clients <code>/mnt</code> partition.</p>

<p>Install the dependencies:</p>

<pre><code class="bash">$ sudo apt-get install nfs-common -y
</code></pre>

<p>Test if we can mount the volume, then unmount it, as we will set the config in our <code>fstab</code>:</p>

<pre><code class="bash">$ sudo mount 10.8.133.83:/vol /mnt
$ sudo umount /mnt
$ df -h
</code></pre>

<p>Set the config in your <code>fstab</code>, then mount it from there:</p>

<pre><code class="bash">$ sudo bash -c "echo '10.8.133.83:/vol /mnt nfs auto,nofail,noatime,nolock,intr,tcp,actimeo=1800 0 0' &gt;&gt; /etc/fstab"
$ sudo mount -a
$ df -h
</code></pre>

<p>Now you shoule be able to write to your NFS Volume from your client.</p>

<p>Sources:
- <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-16-04">1</a> <a href="https://gist.github.com/deviantony/557984d62e867e6f505577b207db6ffc%">2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a Site to Site IPsec VPN With Strongswan and PreShared Key Authentication]]></title>
    <link href="http://blog.ruanbekker.com/blog/2018/02/11/setup-a-site-to-site-ipsec-vpn-with-strongswan-and-preshared-key-authentication/"/>
    <updated>2018-02-11T16:09:37-05:00</updated>
    <id>http://blog.ruanbekker.com/blog/2018/02/11/setup-a-site-to-site-ipsec-vpn-with-strongswan-and-preshared-key-authentication</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/sWn8zc.jpg" alt="" /></p>

<p>Today we will setup a Site to Site ipsec VPN with Strongswan, which will be configured with PreShared Key Authentication.</p>

<p>After our tunnels are established, we will be able to reach the private ips over the vpn tunnels.</p>

<h2>Get the Dependencies:</h2>

<p>Update your repository indexes and install strongswan:</p>

<pre><code class="bash">$ apt update &amp;&amp; sudo apt upgrade -y
$ apt install strongswan -y
</code></pre>

<p>Set the following kernel parameters:</p>

<pre><code class="bash">$ cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOF
echo net.ipv4.ip_forward = 1 
net.ipv4.conf.all.accept_redirects = 0 
net.ipv4.conf.all.send_redirects = 0
EOF

$ sysctl -p /etc/sysctl.conf
</code></pre>

<h2>Generate Preshared Key:</h2>

<p>We will need a preshared key that both servers will use:</p>

<pre><code>$ openssl rand -base64 64
87zRQqylaoeF5I8o4lRhwvmUzf+pYdDpsCOlesIeFA/2xrtxKXJTbCPZgqplnXgPX5uprL+aRgxD8ua7MmdWaQ
</code></pre>

<h2>Details of our 2 Sites:</h2>

<p>Site A:</p>

<pre><code class="bash">Location: Paris, France
External IP: 51.15.139.201
Internal IP: 10.10.27.1/24
</code></pre>

<p>Site B:</p>

<pre><code class="bash">Location: Amsterdam, Netherlands
External IP: 51.15.44.48
Internal IP: 10.9.141.1/24
</code></pre>

<h2>Configure Site A:</h2>

<p>We will setup our VPN Gateway in Site A (Paris), first to setup the <code>/etc/ipsec.secrets</code> file:</p>

<pre><code class="bash">$ cat /etc/ipsec.secrets
# source      destination
51.15.139.201 51.15.44.48 : PSK "87zRQqylaoeF5I8o4lRhwvmUzf+pYdDpsCOlesIeFA/2xrtxKXJTbCPZgqplnXgPX5uprL+aRgxD8ua7MmdWaQ"
</code></pre>

<p>Now to setup our VPN configuration in <code>/etc/ipsec.conf</code>:</p>

<pre><code>cat /etc/ipsec.conf
# basic configuration
config setup
        charondebug="all"
        uniqueids=yes
        strictcrlpolicy=no

# connection to amsterdam datacenter
conn paris-to-amsterdam
    authby=secret
    left=%defaultroute
    leftid=51.15.139.201
    leftsubnet=10.10.27.1/24
    right=51.15.44.48
    rightsubnet=10.9.141.1/24
    ike=aes256-sha2_256-modp1024!
    esp=aes256-sha2_256!
    keyingtries=0
    ikelifetime=1h
    lifetime=8h
    dpddelay=30
    dpdtimeout=120
    dpdaction=restart
    auto=start
</code></pre>

<p>Firewall Rules:</p>

<pre><code class="bash">$ sudo iptables -t nat -A POSTROUTING -s 10.9.141.0/24 -d 10.10.27.0/24 -j MASQUERADE
</code></pre>

<h2>Configure Site B:</h2>

<p>We will setup our VPN Gateway in Site B (Amsterdam), setup the <code>/etc/ipsec.secrets</code> file:</p>

<pre><code class="bash">$ cat /etc/ipsec.secrets
51.15.44.48 51.15.139.201 : PSK "87zRQqylaoeF5I8o4lRhwvmUzf+pYdDpsCOlesIeFA/2xrtxKXJTbCPZgqplnXgPX5uprL+aRgxD8ua7MmdWaQ"
</code></pre>

<p>Next to setup our VPN Configuration:</p>

<pre><code>cat /etc/ipsec.conf
# basic configuration
config setup
        charondebug="all"
        uniqueids=yes
        strictcrlpolicy=no

# connection to paris datacenter
conn amsterdam-to-paris
    authby=secret
    left=%defaultroute
    leftid=51.15.44.48
    leftsubnet=10.9.141.1/24
    right=51.15.139.201
    rightsubnet=10.10.27.1/24
    ike=aes256-sha2_256-modp1024!
    esp=aes256-sha2_256!
    keyingtries=0
    ikelifetime=1h
    lifetime=8h
    dpddelay=30
    dpdtimeout=120
    dpdaction=restart
    auto=start
</code></pre>

<p>Firewall Rules:</p>

<pre><code class="bash">$ sudo iptables -t nat -A POSTROUTING -s 10.10.27.0/24 -d 10.9.41.0/24 -J MASQUERADE
</code></pre>

<h2>Start the VPN:</h2>

<p>Start the VPN on both ends:</p>

<pre><code class="bash">$ sudo ipsec restart
</code></pre>

<p>Get the status of the tunnel, in this case we are logged onto our Site A (Paris) Server:</p>

<pre><code>$ sudo ipsec status
Security Associations (1 up, 0 connecting):
paris-to-amsterdam[2]: ESTABLISHED 14 minutes ago, 10.10.27.161[51.15.139.201]...51.15.44.48[51.15.44.48]
paris-to-amsterdam{1}:  INSTALLED, TUNNEL, reqid 1, ESP in UDP SPIs: c8c868ee_i c9d58dbd_o
paris-to-amsterdam{1}:   10.10.27.1/24 === 10.9.141.1/24
</code></pre>

<p>Test if we can see the remote end on its private range:</p>

<pre><code class="bash">$ ping 10.9.141.97
PING 10.9.141.97 (10.9.141.97) 56(84) bytes of data.
64 bytes from 10.9.141.97: icmp_seq=1 ttl=64 time=14.6 ms
</code></pre>

<p>Set the service to start on boot:</p>

<pre><code class="bash">$ sudo systemctl enable strongswan
</code></pre>

<p>Then your VPN should be setup correctly.</p>

<h2>Other useful commands:</h2>

<p>Start / Stop / Status:</p>

<pre><code class="bash">$ sudo ipsec up connection-name
$ sudo ipsec down connection-name

$ sudo ipsec restart
$ sudo ipsec status
$ sudo ipsec statusall
</code></pre>

<p>Get the Policies and States of the IPsec Tunnel:</p>

<pre><code class="bash">$ sudo ip xfrm state
$ sudo ip xfrm policy
</code></pre>

<p>Reload the secrets, while the service is running:</p>

<pre><code class="bash">$ sudo ipsec rereadsecrets
</code></pre>

<p>Check if traffic flows through the tunnel:</p>

<pre><code class="bash">$ sudo tcpdump esp
</code></pre>

<h2>Adding more connections to your config:</h2>

<p>If you have to add another site to your config, the example of the <code>ipsec.secrets</code> will look like:</p>

<pre><code class="bash">$ cat /etc/ipsec.secrets
51.15.139.201 51.15.44.48 : PSK "87zRQqylaoeF5I8o4lRhwvmUzf+pYdDpsCOlesIeFA/2xrtxKXJTbCPZgqplnXgPX5uprL+aRgxD8ua7MmdWaQ"
51.15.139.201 51.15.87.41  : PSK "87zRQqylaoeF5I8o4lRhwvmUzf+pYdDpsCOlesIeFA/2xrtxKXJTbCPZgqplnXgPX5uprL+aRgxD8ua7MmdWaQ"
</code></pre>

<p>And the <code>ipsec.conf</code>:</p>

<pre><code class="bash">cat /etc/ipsec.conf
# basic configuration
config setup
        charondebug="all"
        uniqueids=yes
        strictcrlpolicy=no

# connection to amsterdam datacenter
conn paris-to-amsterdam
    authby=secret
    left=%defaultroute
    leftid=51.15.139.201
    leftsubnet=10.10.27.161/32
    right=51.15.44.48
    rightsubnet=10.9.141.97/32
    ike=aes256-sha2_256-modp1024!
    esp=aes256-sha2_256!
    keyingtries=0
    ikelifetime=1h
    lifetime=8h
    dpddelay=30
    dpdtimeout=120
    dpdaction=restart
    auto=start

# connection to frankfurt datacenter
conn paris-to-frankfurt
    authby=secret
    left=%defaultroute
    leftid=51.15.139.201
    leftsubnet=10.10.27.1/24
    right=51.15.87.41
    rightsubnet=10.9.137.1/24
    ike=aes256-sha2_256-modp1024!
    esp=aes256-sha2_256!
    keyingtries=0
    ikelifetime=1h
    lifetime=8h
    dpddelay=30
    dpdtimeout=120
    dpdaction=restart
    auto=start
</code></pre>

<p>Just remember to configure the config on the Frankfurt VPN Gateway, and the example of the status output will look like the following:</p>

<pre><code class="bash">$ sudo ipsec status
Security Associations (2 up, 0 connecting):
paris-to-frankfurt[2]: ESTABLISHED 102 seconds ago, 10.10.27.161[51.15.139.201]...51.15.87.41[51.15.87.41]
paris-to-frankfurt{1}:  INSTALLED, TUNNEL, reqid 2, ESP in UDP SPIs: cbc62a1f_i c95b8f78_o
paris-to-frankfurt{1}:   10.10.27.1/24 === 10.9.137.1/24
paris-to-amsterdam[1]: ESTABLISHED 102 seconds ago, 10.10.27.161[51.15.139.201]...51.15.44.48[51.15.44.48]
paris-to-amsterdam{2}:  INSTALLED, TUNNEL, reqid 1, ESP in UDP SPIs: c7b36756_i cc54053c_o
paris-to-amsterdam{2}:   10.10.27.1/24 === 10.9.141.1/24
</code></pre>
]]></content>
  </entry>
  
</feed>
