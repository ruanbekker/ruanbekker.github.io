<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Vpn | Ruan Bekker's Blog]]></title>
  <link href="https://blog.ruanbekker.com/blog/categories/vpn/atom.xml" rel="self"/>
  <link href="https://blog.ruanbekker.com/"/>
  <updated>2020-06-14T16:47:25+02:00</updated>
  <id>https://blog.ruanbekker.com/</id>
  <author>
    <name><![CDATA[Ruan]]></name>
    <email><![CDATA[ruan@ruanbekker.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[IPSec Site to Site VPN With Dynamic IPs With Openswan]]></title>
    <link href="https://blog.ruanbekker.com/blog/2020/04/19/ipsec-site-to-site-vpn-with-dynamic-ips-with-openswan/"/>
    <updated>2020-04-19T20:58:17+02:00</updated>
    <id>https://blog.ruanbekker.com/blog/2020/04/19/ipsec-site-to-site-vpn-with-dynamic-ips-with-openswan</id>
    <content type="html"><![CDATA[<p>In this tutorial we will setup a site to site ipsec vpn with strongswan and we will enable each server to discover the other vpn server via dynamic dns. We will also append to our config the ability of roadwarriors so that you will be able to connect to your homelab from any mobile or laptop device from any remote source.</p>

<h2>Some background</h2>

<p>Me and one of my friends decided to build a site to site vpn with strongswan so that our homelabs could be reachable to each other over private networks.</p>

<p>One challenge that I thought of is that both of our internet providers don&rsquo;t support static ip addressing, so each vpn server needs to know where to connect to whenever the ip address changes.</p>

<h2>What we will be doing</h2>

<p>We will setup strongswan vpn on both servers and allow the private LAN ranges to be reachable for both sides. As I have a domain hosted on cloudflare, I will be using cloudflare&rsquo;s api to update the A record of each sides dns whenever the IP changes.</p>

<h2>Environment</h2>

<p>On my side, which I will be referring to as <strong>Side-A</strong>:</p>

<pre><code>Public DNS Name: side-a.example.com
Private Range: 192.168.0.0/24
VPN Server IP: 192.168.0.2
</code></pre>

<p>On my friend&rsquo;s side, which I will be referring to as <strong>Side-B</strong>:</p>

<pre><code>Public DNS Name: side-b.example.com
Private Range: 192.168.1.0/24
VPN Server IP: 192.168.1.2
</code></pre>

<h2>Cloudflare Dynamic DNS</h2>

<p>You don&rsquo;t need to use Cloudflare, theres services such as dyndns.com, no-ip.com. But for this tutorial I will be using cloudflare to utilize my own domain.</p>

<p>I will be using the <a href="https://github.com/LINKIWI/cloudflare-ddns-client">cloudflare-ddns-client</a></p>

<p>First we need to create a API Token, head over to your dashboard: <a href="https://dash.cloudflare.com">dash.cloudflare.com</a>, head over to &ldquo;my profile&rdquo;, select &ldquo;API Tokens&rdquo;, then allow &ldquo;Read Zones&rdquo; and &ldquo;Edit DNS&rdquo;, then select &ldquo;Create Token&rdquo;. Keep the returned token value in a safe place.</p>

<p>Install the pre-requirements:</p>

<pre><code>$ apt install python python-dev python-pip make curl build-essential -y
</code></pre>

<p>Get the source and install:</p>

<pre><code>$ git clone https://github.com/LINKIWI/cloudflare-ddns-client.git
$ cd cloudflare-ddns-client
$ make install
</code></pre>

<p>We will now configure the cloudflare dynamic dns client, this will be done on both sides, but will only demonstrate for side-a:</p>

<pre><code>$ cloudflare-ddns --configure
Use API token or API key to authenticate?
Choose [T]oken or [K]ey: T
Enter the API token you created at https://dash.cloudflare.com/profile/api-tokens.
Required permissions are READ Account.Access: Organizations, Identity Providers, and Groups; READ Zone.Zone; EDIT Zone.DNS
CloudFlare API token: [redacted]
Enter the domains for which you would like to automatically update the DNS records, delimited by a single comma.
Comma-delimited domains: side-a.example.com
</code></pre>

<p>Testing it out to ensure the A record can be updated:</p>

<pre><code>$ cloudflare-ddns --update-now
Found external IPv4: "1.x.x.x"
Listing all zones.
Finding all DNS records.
Updating the A record (ID x) of (sub)domain side-a.example.com (ID x) to 1.x.x.x.
DNS record updated successfully!
</code></pre>

<p>We can run this command from above in a cron, but I will use a bash script to only run when the public ip changed: <code>/opt/scripts/detect_ip_change.sh</code>:</p>

<pre><code>#!/bin/bash
set -ex
MY_DDNS_HOST="side-a.example.com"

if [ $(dig ${MY_DDNS_HOST} +short) == $(curl -s icanhazip.com) ];
  then exit 0;
  else /usr/local/bin/cloudflare-ddns --update-now;
fi
</code></pre>

<p>Make the file executable: <code>chmod +x /opt/scripts/detect_ip_change.sh</code> then edit your cronjobs: <code>crontab -e</code> and add the script:</p>

<pre><code>* * * * * /opt/scripts/detect_ip_change.sh
</code></pre>

<p>This will keep your DNS updated, this needs to be done on both sides, if you want to use dynamic dns.</p>

<h2>Port Forwarding</h2>

<p>We will need to forward UDP traffic from the router to the VPN server, on both sides:</p>

<pre><code>Port: UDP/500 
Target: VPN-Server-IP:500

Port: UDP/4500
Target: VPN-Server-IP:4500
</code></pre>

<h2>Create a Pre-Shared Key</h2>

<p>Create a preshared key that will be used on both sides to authenticate:</p>

<pre><code>$ openssl rand -base64 36
pgDU4eKZaQNL7GNRWJPvZbaSYFn2PAFjK9vDOvxAQ85p7qc4
</code></pre>

<p>This value will be used on both sides, which we will need later.</p>

<h2>Install Strongswan on Side-A</h2>

<p>Install strongswan and enable the service on boot:</p>

<pre><code>$ apt install strongswan -y
$ systemctl enable strongswan
</code></pre>

<p>The left side will be the side we are configuring and the right side will be the remote side.</p>

<p>Create the config: <code>/etc/ipsec.conf</code> and provide the following config:</p>

<pre><code>config setup
    charondebug="all"
    uniqueids=yes
    virtual_private=
    cachecrls=no

conn vpn-to-side-b
    type=tunnel
    authby=secret
    left=%defaultroute
    leftid=side-a.example.com
    leftsubnet=192.168.0.0/24
    right=%side-b.example.com
    rightid=side-b.example.com
    rightsubnet=192.168.1.0/24
    ike=aes256-sha2_256-modp1024!
    esp=aes256-sha2_256!
    keyingtries=0
    ikelifetime=1h
    lifetime=8h
    dpddelay=30
    dpdtimeout=120
    dpdaction=restart
    auto=start
</code></pre>

<p>Create the secrets file: <code>/etc/ipsec.secrets</code>:</p>

<pre><code>side-b.example.com : PSK "pgDU4eKZaQNL7GNRWJPvZbaSYFn2PAFjK9vDOvxAQ85p7qc4"
</code></pre>

<p>Append the following kernel parameters to <code>/etc/sysctl.conf</code>:</p>

<pre><code>net.ipv4.ip_forward = 1
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0
</code></pre>

<p>Save:</p>

<pre><code>$ sysctl -p
</code></pre>

<p>We now want to add a POSTROUTING and FORWARD rule using iptables:</p>

<pre><code>$ iptables -t nat -A POSTROUTING -s 192.168.1.0/24  -d 192.168.0.0/24 -j MASQUERADE
$ iptables -A FORWARD -s 192.168.1.0/24 -d 192.168.0.0/24 -j ACCEPT
</code></pre>

<p>Now we need to route back:</p>

<pre><code>$ ip route add 192.168.1.0/24 via 192.168.0.2 dev eth0
</code></pre>

<p>We want to persist the iptables and static route across reboots, so edit the <code>/etc/rc.local</code> file, if it&rsquo;s not there create it with the following values:</p>

<pre><code>#!/bin/bash
iptables -t nat -A POSTROUTING -s 192.168.1.0/24  -d 192.168.0.0/24 -j MASQUERADE
iptables -A FORWARD -s 192.168.1.0/24 -d 192.168.0.0/24 -j ACCEPT
ip route add 192.168.1.0/24 via 192.168.0.2 dev eth0
exit 0
</code></pre>

<p>If you created the file, make sure to apply executable permissions:</p>

<pre><code>$ chmod +x /etc/rc.local
</code></pre>

<p>Read the secrets and restart strongswan:</p>

<pre><code>$ ipsec rereadsecrets
$ systemctl restart strongswan
</code></pre>

<h2>Install Strongswan on Side-B</h2>

<p>Install strongswan and enable the service on boot:</p>

<pre><code>$ apt install strongswan -y
$ systemctl enable strongswan
</code></pre>

<p>The left side will be the side we are configuring and the right side will be the remote side.</p>

<p>Create the config: <code>/etc/ipsec.conf</code> and provide the following config:</p>

<pre><code>config setup
    charondebug="all"
    uniqueids=yes
    virtual_private=
    cachecrls=no

conn vpn-to-side-a
    type=tunnel
    authby=secret
    left=%defaultroute
    leftid=side-b.example.com
    leftsubnet=192.168.1.0/24
    right=%side-a.example.com
    rightid=side-a.example.com
    rightsubnet=192.168.0.0/24
    ike=aes256-sha2_256-modp1024!
    esp=aes256-sha2_256!
    keyingtries=0
    ikelifetime=1h
    lifetime=8h
    dpddelay=30
    dpdtimeout=120
    dpdaction=restart
    auto=start
</code></pre>

<p>Create the secrets file: <code>/etc/ipsec.secrets</code>:</p>

<pre><code>side-a.example.com : PSK "pgDU4eKZaQNL7GNRWJPvZbaSYFn2PAFjK9vDOvxAQ85p7qc4"
</code></pre>

<p>Append the following kernel parameters to <code>/etc/sysctl.conf</code>:</p>

<pre><code>net.ipv4.ip_forward = 1
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0
</code></pre>

<p>Save:</p>

<pre><code>$ sysctl -p
</code></pre>

<p>We now want to add a POSTROUTING and FORWARD rule using iptables:</p>

<pre><code>$ iptables -t nat -A POSTROUTING -s 192.168.0.0/24  -d 192.168.1.0/24 -j MASQUERADE
$ iptables -A FORWARD -s 192.168.0.0/24 -d 192.168.1.0/24 -j ACCEPT
</code></pre>

<p>Now we need to route back:</p>

<pre><code>$ ip route add 192.168.0.0/24 via 192.168.1.2 dev eth0
</code></pre>

<p>We want to persist the iptables and static route across reboots, so edit the <code>/etc/rc.local</code> file, if it&rsquo;s not there create it with the following values:</p>

<pre><code>#!/bin/bash
iptables -t nat -A POSTROUTING -s 192.168.0.0/24  -d 192.168.1.0/24 -j MASQUERADE
iptables -A FORWARD -s 192.168.0.0/24 -d 192.168.1.0/24 -j ACCEPT
ip route add 192.168.0.0/24 via 192.168.1.2 dev eth0
exit 0
</code></pre>

<p>If you created the file, make sure to apply executable permissions:</p>

<pre><code>$ chmod +x /etc/rc.local
</code></pre>

<p>Read the secrets and restart strongswan:</p>

<pre><code>$ ipsec rereadsecrets
$ systemctl restart strongswan
</code></pre>

<h2>Verify Status</h2>

<p>Verify that the ipsec tunnel is up on side-a:</p>

<pre><code>$ ipsec statusall

Connections:
  vpn-to-side-b:  %any...side-b.example.com,0.0.0.0/0,::/0  IKEv1/2
  vpn-to-side-b:   local:  [side-a.example.com] uses pre-shared key authentication
  vpn-to-side-b:   remote: [side-b.example.com] uses pre-shared key authentication
  vpn-to-side-b:   child:  192.168.0.0/24 === 192.168.1.0/24 TUNNEL
Security Associations (1 up, 0 connecting):
  vpn-to-side-b[1]: ESTABLISHED 28 minutes ago, 192.168.0.2[side-a.example.com]...4x.x.x.214[side-b.example.com]
  vpn-to-side-b[1]: IKEv2 SPIs: 81996170df1c927d_i e8294946491ddf08_r, pre-shared key reauthentication in 2 hours
  vpn-to-side-b[1]: IKE proposal: AES_CBC_128/HMAC_SHA2_256_128/PRF_HMAC_SHA2_256/ECP_256
  vpn-to-side-b{2}:  INSTALLED, TUNNEL, reqid 1, ESP in UDP SPIs: cc4504be_i c294cb26_o
  vpn-to-side-b{2}:  AES_CBC_128/HMAC_SHA2_256_128, 0 bytes_i, 240 bytes_o (4 pkts, 7s ago), rekeying in 18 minutes
  vpn-to-side-b{2}:   192.168.0.0/24 === 192.168.1.0/24
</code></pre>

<p>Verify that the ipsec tunnel is up on side-b:</p>

<pre><code>$ ipsec statusall

Connections:
 vpn-to-side-a:  %any...side-a.example.com,0.0.0.0/0,::/0  IKEv1/2
 vpn-to-side-a:   local:  [side-b.example.com] uses pre-shared key authentication
 vpn-to-side-a:   remote: [side-a.example.com] uses pre-shared key authentication
 vpn-to-side-a:   child:  192.168.1.0/24 === 192.168.0.0/24 TUNNEL
Security Associations (1 up, 0 connecting):
 vpn-to-side-a[2]: ESTABLISHED 20 minutes ago, 192.168.1.2[side-b.example.com]...14x.x.x.x[side-a.example.com]
 vpn-to-side-a[2]: IKEv2 SPIs: 81996170df1c927d_i e8294946491ddf08_r, pre-shared key reauthentication in 2 hours
 vpn-to-side-a[2]: IKE proposal: AES_CBC_128/HMAC_SHA2_256_128/PRF_HMAC_SHA2_256/ECP_256
 vpn-to-side-a{2}:  INSTALLED, TUNNEL, reqid 1, ESP in UDP SPIs: c294cb26_i cc4504be_o
 vpn-to-side-a{2}:  AES_CBC_128/HMAC_SHA2_256_128, 0 bytes_i, 0 bytes_o, rekeying in 26 minutes
 vpn-to-side-a{2}:   192.168.1.0/24 === 192.168.0.0/24
</code></pre>

<p>From side-a (192.168.0.2) ping the gateway on side-b (192.168.1.1):</p>

<pre><code>$ $ ping -c2 192.168.1.1
PING 10.3.96.2 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=62 time=11.9 ms
</code></pre>

<p>If you want to be able to reach the private range of the other side of the vpn from any device on your network, you should add a static route on your router to inform your default gateway where to route traffic to.</p>

<p>In this case on side-a (192.168.0.0/24) we want to inform our default gateway to route (192.168.1.0/24) to the VPN as it knows to route that destination over the VPN.</p>

<p>On side-a, on your router, add a static route:</p>

<pre><code>Route: 192.168.1.0
Subnet: 255.255.255.0
Gateway: 192.168.0.2
</code></pre>

<p>On side-b, on your router, add a static route:</p>

<pre><code>Route: 192.168.0.0
Subnet: 255.255.255.0
Gateway: 192.168.1.2
</code></pre>

<h2>Optional: Roadwarrior VPN Clients</h2>

<p>This step is optional, but since we can access each others homelabs, we thought it would be nice to be able to access the resources from mobile devices or laptops when we are on remote locations.</p>

<p>We made it that each VPN owner will connect to its own endpoint (for roadwarriors), so side-a (which will be me) will connect to its own dns endpoint to connect when away from home..</p>

<p>I will only demonstrate how to append your config to add the ability for a roadwarrion vpn connection, append to the <code>/etc/ipsec.conf</code>:</p>

<pre><code># ...
conn ikev2-vpn
    auto=add
    type=tunnel
    authby=secret
    left=%any
    leftid=side-a.roadwarrior
    leftsubnet=0.0.0.0/0
    right=%any
    rightid=%any
    rightsourceip=10.10.0.0/24
    rightdns=192.168.0.1,8.8.8.8
    auto=start
</code></pre>

<p>Append the secret in <code>/etc/ipsec.secrets</code>:</p>

<pre><code># ...
side-a.roadwarrior my-laptop : PSK "MySuperSecureSecret123"
</code></pre>

<p>Add the vpn ip&rsquo;s that we will assign to the roardwarrior clients to the routing table:</p>

<pre><code>$ ip route add 10.10.0.0/24 via 192.168.0.2 dev eth0
</code></pre>

<p>If you only want the roadwarriors to be able to reach your network, you will only forward to the local network such as:</p>

<pre><code>$ iptables -A FORWARD -s 10.10.0.0/24 -d 192.168.0.0/24 -j ACCEPT
</code></pre>

<p>But we will be forwarding traffic to all destinations:</p>

<pre><code>$ iptables -A FORWARD -s 10.10.0.0/24 -d 0.0.0.0/0 -j ACCEPT
$ iptables -t nat -A POSTROUTING -s 10.10.0.0/24 -d 0.0.0.0/0 -j MASQUERADE
</code></pre>

<p>Remember to append the routes to <code>/etc/rc.local</code> to persist across reboots.</p>

<p>Reread the secrets and restart strongswan:</p>

<pre><code>$ ipsec rereadsecrets
$ systemctl restart strongswan
</code></pre>

<p>Connecting your VPN Client, I will be using my Laptop, with the following details:</p>

<pre><code>VPN Type: IKEv2
Description: Home VPN
Server: side-a.example.com
Remote ID: side-a.roadwarrior
Local ID: my-laptop
User Authentication: None
Secret: MySuperSecureSecret123
</code></pre>

<h2>Thank You</h2>

<p>In this tutorial I demonstrated how to setup a site to site ipsec vpn between 2 sides that consists of internet connections that has dynamic ip&rsquo;s and also appending roadwarrior config so that you can connect to your homelab from anywhere in the world.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a WireGuard VPN Server on Linux]]></title>
    <link href="https://blog.ruanbekker.com/blog/2020/01/11/setup-a-wireguard-vpn-server-on-linux/"/>
    <updated>2020-01-11T23:37:03+02:00</updated>
    <id>https://blog.ruanbekker.com/blog/2020/01/11/setup-a-wireguard-vpn-server-on-linux</id>
    <content type="html"><![CDATA[<h2>Installation</h2>

<p>I will be installing my wireguard vpn server on a ubuntu 18 server, for other distributions you can have a look at their <a href="https://www.wireguard.com/install/">docs</a></p>

<pre><code>$ sudo add-apt-repository ppa:wireguard/wireguard
$ sudo apt update
$ sudo apt install wireguard -y
</code></pre>

<h2>Configuration</h2>

<p>On the Server, create they keys directory where we will save our keys:</p>

<pre><code>$ mkdir -p /etc/wireguard/keys
</code></pre>

<p>Create the private and public key:</p>

<pre><code>$ wg genkey | tee privatekey | wg pubkey &gt; publickey
</code></pre>

<p>Generate the pre-shared key:</p>

<pre><code>$ wg genpsk &gt; client.psk
</code></pre>

<p>On the client, create the keys directory:</p>

<pre><code>$ mkdir -p ~/wireguard/keys
</code></pre>

<p>Create the private and public keys:</p>

<pre><code>$ cd ~/wireguard/keys
$ wg genkey | tee privatekey | wg pubkey &gt; publickey
</code></pre>

<p>Populate the server config:</p>

<pre><code>$ cat /etc/wireguard/wg0.conf
[Interface]
PrivateKey = &lt;output-of-client.privatekey&gt;
Address = 192.168.199.1/32
ListenPort = 8999
PostUp = sysctl -w net.ipv4.ip_forward=1; iptables -A FORWARD -i %i -j ACCEPT; iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -t nat -D POSTROUTING -o ens3 -j MASQUERADE

[Peer]
PublicKey = &lt;output-of-server.publickey&gt;
PresharedKey = &lt;output-of-client.psk&gt;
AllowedIPs = 192.168.199.2/32
</code></pre>

<p>Populate the client config:</p>

<pre><code>$ cat ~/wireguard/wg0.conf
[Interface]
PrivateKey = &lt;output-of-client.privatekey&gt;
Address = 192.168.199.2/24
DNS = 1.1.1.1

[Peer]
PublicKey = &lt;output-of-server.publickey&gt;
PresharedKey = &lt;output-of-client.psk&gt;
Endpoint = &lt;server-public-ip&gt;:8999
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25
</code></pre>

<h2>Start the Server</h2>

<p>On the server, enable and start the service:</p>

<pre><code>$ systemctl enable wg-quick@wg0.service
$ wg-quick up wg0
</code></pre>

<p>On the client, connect the VPN:</p>

<pre><code>$ wg-quick up ~/wireguard/wg0.conf
</code></pre>

<p>Verify the status:</p>

<pre><code>$ wg show
interface: wg0
  public key: +Giwk8Y5KS5wx9mw0nEIdQODI+DsR+3TcbMxjJqfZys=
  private key: (hidden)
  listening port: 8999

peer: Q8LGMj6CeCYQJp+sTu74mLMRoPFAprV8PsnS0cu9fDI=
  preshared key: (hidden)
  endpoint: 102.132.208.80:57800
  allowed ips: 192.168.199.2/32
  latest handshake: 22 seconds ago
  transfer: 292.00 KiB received, 322.15 KiB sent
</code></pre>

<p>Check if you can ping the private ip address of the VPN:</p>

<pre><code>$ ping 192.168.199.2
PING 192.168.199.2 (192.168.199.2): 56 data bytes
64 bytes from 192.168.199.2: icmp_seq=0 ttl=63 time=304.844 ms
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a PPTP VPN on Ubuntu]]></title>
    <link href="https://blog.ruanbekker.com/blog/2018/06/27/setup-a-pptp-vpn-on-ubuntu/"/>
    <updated>2018-06-27T10:18:51+02:00</updated>
    <id>https://blog.ruanbekker.com/blog/2018/06/27/setup-a-pptp-vpn-on-ubuntu</id>
    <content type="html"><![CDATA[<p>In this post we will setup a <a href="https://en.wikipedia.org/wiki/Point-to-Point_Tunneling_Protocol">PPTP</a> VPN on Ubuntu 16.04</p>

<script id="mNCC" language="javascript">
    medianet_width = "728";
    medianet_height = "90";
    medianet_crid = "218284798";
    medianet_versionId = "3111299"; 
  </script>


<script src="//contextual.media.net/nmedianet.js?cid=8CUD78FSV"></script>


<h2>Disable IPv6 Networking:</h2>

<p>Edit the grub config:</p>

<pre><code class="bash">$ vi /etc/default/grub
</code></pre>

<p>Make the following changes:</p>

<pre><code>GRUB_CMDLINE_LINUX_DEFAULT="ipv6.disable=1"
GRUB_CMDLINE_LINUX="ipv6.disable=1"
</code></pre>

<p>Update Grub and Reboot:</p>

<pre><code class="bash">$ update-grub
$ reboot
</code></pre>

<h2>Updates and Install PPTP:</h2>

<p>Update Repositories and install PPTPD:</p>

<pre><code class="bash">$ apt update &amp;&amp; apt upgrade -y
$ apt install pptpd -y
</code></pre>

<p>Configure your Authentication</p>

<pre><code class="bash">$ vi /etc/ppp/chap-secrets
</code></pre>

<pre><code># client    server  secret          IP addresses
youruser    pptpd   yourpass        *
</code></pre>

<p>Configure Local and Remote IP, in this case I want 10.1.1.2 to 10.1.5.1-254</p>

<pre><code class="bash">$ vi /etc/pptpd.conf
</code></pre>

<pre><code>option /etc/ppp/pptpd-options
logwtmp
connections 10000
localip 10.1.1.1
remoteip 10.1.1.2-254,10.1.2.1-254,10.1.3.2-254,10.1.4.1-254,10.1.5.1-254
# for a /24 you can set
# remoteip 10.1.1.2-254
</code></pre>

<h2>Enable IP Forwarding:</h2>

<p>Edit the sysctl.conf and enable IP Forwarding:</p>

<pre><code class="bash">$ vim /etc/sysctl.conf
</code></pre>

<p>Populate the following value:</p>

<pre><code>net.ipv4.ip_forward=1
</code></pre>

<p>Update the Changes:</p>

<pre><code class="bash">$ sysctl -p
</code></pre>

<h2>Enable and Start PPTPD:</h2>

<p>Enable the service on boot and start the service:</p>

<pre><code class="bash">$ systemctl enable pptpd
$ systemctl start pptpd
$ systemctl status pptpd
</code></pre>

<p>Connect to your VPN.</p>

<h2>Resources:</h2>

<ul>
<li><a href="https://www.vultr.com/docs/setup-a-pptp-vpn-server-on-ubuntu">https://www.vultr.com/docs/setup-a-pptp-vpn-server-on-ubuntu</a></li>
<li><a href="https://github.com/viljoviitanen/setup-simple-pptp-vpn">https://github.com/viljoviitanen/setup-simple-pptp-vpn</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a Peer to Peer VPN With VPNCloud on Ubuntu]]></title>
    <link href="https://blog.ruanbekker.com/blog/2018/06/02/setup-a-peer-to-peer-vpn-with-vpncloud-on-ubuntu/"/>
    <updated>2018-06-02T20:15:33+02:00</updated>
    <id>https://blog.ruanbekker.com/blog/2018/06/02/setup-a-peer-to-peer-vpn-with-vpncloud-on-ubuntu</id>
    <content type="html"><![CDATA[<p>So I got 3 Dedicated Servers each having its own Static IP and I wanted a way to build a private network between these servers.</p>

<script id="mNCC" language="javascript">
    medianet_width = "728";
    medianet_height = "90";
    medianet_crid = "218284798";
    medianet_versionId = "3111299"; 
  </script>


<script src="//contextual.media.net/nmedianet.js?cid=8CUD78FSV"></script>


<h2>The Scenario:</h2>

<p>3 Servers with the following IP&rsquo;s (not real IP addresses):</p>

<pre><code>- Server 1: 52.1.99.10
- Server 2: 52.1.84.20
- Server 3: 52.1.49.30
</code></pre>

<p>So I want to have a private network, so that I can have the following internal network:</p>

<pre><code>- Server 1: 10.0.1.1
- Server 2: 10.0.1.2
- Server 3: 10.0.1.3
</code></pre>

<p>A couple of years ago, I accomplished the end goal using GRE Tunnels, which works well, but wanted to try something different.</p>

<h2>VPNCloud</h2>

<p>So I stumbled upon VPNCloud.rs, which is a peer to peer VPN. Their description, quoted from their Github page:</p>

<p>&ldquo;VpnCloud is a simple VPN over UDP. It creates a virtual network interface on the host and forwards all received data via UDP to the destination. VpnCloud establishes a fully-meshed VPN network in a peer-to-peer manner. It can work on TUN devices (IP based) and TAP devices (Ethernet based).&rdquo;</p>

<p>This is exactly what I was looking for.</p>

<h2>Setting up a 3 node Private Network:</h2>

<p>Given the IP configuration above, we will setup a Private network between our 3 hosts.</p>

<p>Do some updates then grab the package from <a href="https://github.com/dswd/vpncloud.rs/releases">Github</a> and install VPNCloud:</p>

<pre><code class="bash ">$ apt update &amp;&amp; apt ugprade -y
$ wget https://github.com/dswd/vpncloud.rs/releases/download/v0.8.1/vpncloud_0.8.1_amd64.deb
$ dpkg -i ./vpncloud_0.8.1_amd64.deb
</code></pre>

<p>Let&rsquo;s start the configuration on Server-1, this config should also be setup on the other 2 servers, the config will remain the same, except for the <code>ifup</code> command. The other servers will look like:</p>

<pre><code>Server-2: -&gt; ifup: "ifconfig $IFNAME 10.0.1.2/24 mtu 1400"
Server-3: -&gt; ifup: "ifconfig $IFNAME 10.0.1.3/24 mtu 1400"
</code></pre>

<p>Getting back to the Server-1 config:</p>

<pre><code class="bash">$ vim /etc/vpncloud/private.net
</code></pre>

<p>Example Config that I am using:</p>

<pre><code class="bash"># each vpn running on their own port
port: 3210

# members of our private network
peers:
  - srv2.domain.com:3210
  - srv3.domain.com:3210

# timeouts
peer_timeout: 1800
dst_timeout: 300

# token that identifies the network and helps to distinguish from other networks
magic: "76706e01"

# pre shared key
shared_key: "VeryStrongPreSharedKey_ThatShouldBeChanged"

# encryption
crypto: aes256

# device info
device_name: "vpncloud%d"
device_type: tap

# vpn modes: hub / switch / router / normal
mode: normal

# subnet to be used for our private network
subnets:
  - 10.0.1.0/24

# command to setup the network
ifup: "ifconfig $IFNAME 10.0.1.1/24 mtu 1400"
ifdown: "ifconfig $IFNAME down"

# user/group owning the process
user: "root"
group: "root"
</code></pre>

<p>Repeat the config on the other servers.</p>

<h2>Start the VPN Service:</h2>

<p>Restart the VPNCloud Service on all the Servers:</p>

<pre><code class="bash">$ service vpncloud@private start
</code></pre>

<p>Check the status:</p>

<pre><code class="bash">$ service vpncloud@private status
</code></pre>

<p>Check if the interface is up:</p>

<pre><code class="bash">$ ifconfig vpncloud0
vpncloud0 Link encap:Ethernet  HWaddr aa:bb:cc:dd:ee:ff
          inet addr:10.0.1.1  Bcast:10.0.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1400  Metric:1
          RX packets:55 errors:0 dropped:0 overruns:0 frame:0
          TX packets:71 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:5046 (5.0 KB)  TX bytes:5526 (5.5 KB)
</code></pre>

<p>Ping the 3rd server via the private network:</p>

<pre><code class="bash">$ ping -c 3 10.0.1.3
PING 10.0.1.2 (10.0.1.3) 56(84) bytes of data.
64 bytes from 10.0.1.3: icmp_seq=1 ttl=64 time=0.852 ms
64 bytes from 10.0.1.3: icmp_seq=2 ttl=64 time=0.831 ms
64 bytes from 10.0.1.3: icmp_seq=3 ttl=64 time=0.800 ms

--- 10.0.1.3 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2028ms
rtt min/avg/max/mdev = 0.800/0.827/0.852/0.039 ms
</code></pre>

<p>Awesome service, please check their <a href="https://github.com/dswd/vpncloud.rs">Github Repo</a> out.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup a Site to Site IPsec VPN With Strongswan and PreShared Key Authentication]]></title>
    <link href="https://blog.ruanbekker.com/blog/2018/02/11/setup-a-site-to-site-ipsec-vpn-with-strongswan-and-preshared-key-authentication/"/>
    <updated>2018-02-11T23:09:37+02:00</updated>
    <id>https://blog.ruanbekker.com/blog/2018/02/11/setup-a-site-to-site-ipsec-vpn-with-strongswan-and-preshared-key-authentication</id>
    <content type="html"><![CDATA[<p><img src="https://i.snag.gy/sWn8zc.jpg" alt="" /></p>

<p>Today we will setup a Site to Site ipsec VPN with Strongswan, which will be configured with PreShared Key Authentication.</p>

<p>After our tunnels are established, we will be able to reach the private ips over the vpn tunnels.</p>

<p><a href="https://bekkerclothing.com/collections/developer?utm_source=blog.ruanbekker.com&utm_medium=blog&utm_campaign=leaderboard_ad" target="_blank"><img alt="bekker-clothing-developer-tshirts" src="https://user-images.githubusercontent.com/567298/70170981-7c278a80-16d6-11ea-9759-6621d02c1423.png"></a></p>

<h2>Get the Dependencies:</h2>

<p>Update your repository indexes and install strongswan:</p>

<pre><code class="bash">$ apt update &amp;&amp; sudo apt upgrade -y
$ apt install strongswan -y
</code></pre>

<p>Set the following kernel parameters:</p>

<pre><code class="bash">$ cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOF
net.ipv4.ip_forward = 1 
net.ipv4.conf.all.accept_redirects = 0 
net.ipv4.conf.all.send_redirects = 0
EOF

$ sysctl -p /etc/sysctl.conf
</code></pre>

<h2>Generate Preshared Key:</h2>

<p>We will need a preshared key that both servers will use:</p>

<pre><code>$ openssl rand -base64 64
87zRQqylaoeF5I8o4lRhwvmUzf+pYdDpsCOlesIeFA/2xrtxKXJTbCPZgqplnXgPX5uprL+aRgxD8ua7MmdWaQ
</code></pre>

<h2>Details of our 2 Sites:</h2>

<p>Site A:</p>

<pre><code class="bash">Location: Paris, France
External IP: 51.15.139.201
Internal IP: 10.10.27.1/24
</code></pre>

<p>Site B:</p>

<pre><code class="bash">Location: Amsterdam, Netherlands
External IP: 51.15.44.48
Internal IP: 10.9.141.1/24
</code></pre>

<h2>Configure Site A:</h2>

<p>We will setup our VPN Gateway in Site A (Paris), first to setup the <code>/etc/ipsec.secrets</code> file:</p>

<pre><code class="bash">$ cat /etc/ipsec.secrets
# source      destination
51.15.139.201 51.15.44.48 : PSK "87zRQqylaoeF5I8o4lRhwvmUzf+pYdDpsCOlesIeFA/2xrtxKXJTbCPZgqplnXgPX5uprL+aRgxD8ua7MmdWaQ"
</code></pre>

<p>Now to setup our VPN configuration in <code>/etc/ipsec.conf</code>:</p>

<pre><code>cat /etc/ipsec.conf
# basic configuration
config setup
        charondebug="all"
        uniqueids=yes
        strictcrlpolicy=no

# connection to amsterdam datacenter
conn paris-to-amsterdam
    authby=secret
    left=%defaultroute
    leftid=51.15.139.201
    leftsubnet=10.10.27.1/24
    right=51.15.44.48
    rightsubnet=10.9.141.1/24
    ike=aes256-sha2_256-modp1024!
    esp=aes256-sha2_256!
    keyingtries=0
    ikelifetime=1h
    lifetime=8h
    dpddelay=30
    dpdtimeout=120
    dpdaction=restart
    auto=start
</code></pre>

<p>Firewall Rules:</p>

<pre><code class="bash">$ sudo iptables -t nat -A POSTROUTING -s 10.9.141.0/24 -d 10.10.27.0/24 -j MASQUERADE
</code></pre>

<h2>Configure Site B:</h2>

<p>We will setup our VPN Gateway in Site B (Amsterdam), setup the <code>/etc/ipsec.secrets</code> file:</p>

<pre><code class="bash">$ cat /etc/ipsec.secrets
51.15.44.48 51.15.139.201 : PSK "87zRQqylaoeF5I8o4lRhwvmUzf+pYdDpsCOlesIeFA/2xrtxKXJTbCPZgqplnXgPX5uprL+aRgxD8ua7MmdWaQ"
</code></pre>

<p>Next to setup our VPN Configuration:</p>

<pre><code>cat /etc/ipsec.conf
# basic configuration
config setup
        charondebug="all"
        uniqueids=yes
        strictcrlpolicy=no

# connection to paris datacenter
conn amsterdam-to-paris
    authby=secret
    left=%defaultroute
    leftid=51.15.44.48
    leftsubnet=10.9.141.1/24
    right=51.15.139.201
    rightsubnet=10.10.27.1/24
    ike=aes256-sha2_256-modp1024!
    esp=aes256-sha2_256!
    keyingtries=0
    ikelifetime=1h
    lifetime=8h
    dpddelay=30
    dpdtimeout=120
    dpdaction=restart
    auto=start
</code></pre>

<p>Firewall Rules:</p>

<pre><code class="bash">$ sudo iptables -t nat -A POSTROUTING -s 10.10.27.0/24 -d 10.9.41.0/24 -J MASQUERADE
</code></pre>

<h2>Start the VPN:</h2>

<p>Start the VPN on both ends:</p>

<pre><code class="bash">$ sudo ipsec restart
</code></pre>

<p>Get the status of the tunnel, in this case we are logged onto our Site A (Paris) Server:</p>

<pre><code>$ sudo ipsec status
Security Associations (1 up, 0 connecting):
paris-to-amsterdam[2]: ESTABLISHED 14 minutes ago, 10.10.27.161[51.15.139.201]...51.15.44.48[51.15.44.48]
paris-to-amsterdam{1}:  INSTALLED, TUNNEL, reqid 1, ESP in UDP SPIs: c8c868ee_i c9d58dbd_o
paris-to-amsterdam{1}:   10.10.27.1/24 === 10.9.141.1/24
</code></pre>

<p>Test if we can see the remote end on its private range:</p>

<pre><code class="bash">$ ping 10.9.141.97
PING 10.9.141.97 (10.9.141.97) 56(84) bytes of data.
64 bytes from 10.9.141.97: icmp_seq=1 ttl=64 time=14.6 ms
</code></pre>

<p>Set the service to start on boot:</p>

<pre><code class="bash">$ sudo systemctl enable strongswan
</code></pre>

<p>Then your VPN should be setup correctly.</p>

<h2>Other useful commands:</h2>

<p>Start / Stop / Status:</p>

<pre><code class="bash">$ sudo ipsec up connection-name
$ sudo ipsec down connection-name

$ sudo ipsec restart
$ sudo ipsec status
$ sudo ipsec statusall
</code></pre>

<p>Get the Policies and States of the IPsec Tunnel:</p>

<pre><code class="bash">$ sudo ip xfrm state
$ sudo ip xfrm policy
</code></pre>

<p>Reload the secrets, while the service is running:</p>

<pre><code class="bash">$ sudo ipsec rereadsecrets
</code></pre>

<p>Check if traffic flows through the tunnel:</p>

<pre><code class="bash">$ sudo tcpdump esp
</code></pre>

<h2>Adding more connections to your config:</h2>

<p>If you have to add another site to your config, the example of the <code>ipsec.secrets</code> will look like:</p>

<pre><code class="bash">$ cat /etc/ipsec.secrets
51.15.139.201 51.15.44.48 : PSK "87zRQqylaoeF5I8o4lRhwvmUzf+pYdDpsCOlesIeFA/2xrtxKXJTbCPZgqplnXgPX5uprL+aRgxD8ua7MmdWaQ"
51.15.139.201 51.15.87.41  : PSK "87zRQqylaoeF5I8o4lRhwvmUzf+pYdDpsCOlesIeFA/2xrtxKXJTbCPZgqplnXgPX5uprL+aRgxD8ua7MmdWaQ"
</code></pre>

<p>And the <code>ipsec.conf</code>:</p>

<pre><code class="bash">cat /etc/ipsec.conf
# basic configuration
config setup
        charondebug="all"
        uniqueids=yes
        strictcrlpolicy=no

# connection to amsterdam datacenter
conn paris-to-amsterdam
    authby=secret
    left=%defaultroute
    leftid=51.15.139.201
    leftsubnet=10.10.27.161/32
    right=51.15.44.48
    rightsubnet=10.9.141.97/32
    ike=aes256-sha2_256-modp1024!
    esp=aes256-sha2_256!
    keyingtries=0
    ikelifetime=1h
    lifetime=8h
    dpddelay=30
    dpdtimeout=120
    dpdaction=restart
    auto=start

# connection to frankfurt datacenter
conn paris-to-frankfurt
    authby=secret
    left=%defaultroute
    leftid=51.15.139.201
    leftsubnet=10.10.27.1/24
    right=51.15.87.41
    rightsubnet=10.9.137.1/24
    ike=aes256-sha2_256-modp1024!
    esp=aes256-sha2_256!
    keyingtries=0
    ikelifetime=1h
    lifetime=8h
    dpddelay=30
    dpdtimeout=120
    dpdaction=restart
    auto=start
</code></pre>

<p>Just remember to configure the config on the Frankfurt VPN Gateway, and the example of the status output will look like the following:</p>

<pre><code class="bash">$ sudo ipsec status
Security Associations (2 up, 0 connecting):
paris-to-frankfurt[2]: ESTABLISHED 102 seconds ago, 10.10.27.161[51.15.139.201]...51.15.87.41[51.15.87.41]
paris-to-frankfurt{1}:  INSTALLED, TUNNEL, reqid 2, ESP in UDP SPIs: cbc62a1f_i c95b8f78_o
paris-to-frankfurt{1}:   10.10.27.1/24 === 10.9.137.1/24
paris-to-amsterdam[1]: ESTABLISHED 102 seconds ago, 10.10.27.161[51.15.139.201]...51.15.44.48[51.15.44.48]
paris-to-amsterdam{2}:  INSTALLED, TUNNEL, reqid 1, ESP in UDP SPIs: c7b36756_i cc54053c_o
paris-to-amsterdam{2}:   10.10.27.1/24 === 10.9.141.1/24
</code></pre>
]]></content>
  </entry>
  
</feed>
